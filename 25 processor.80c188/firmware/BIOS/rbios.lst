     1                                  	%ifndef SOFT_DEBUG
     2                                  	;;%define SOFT_DEBUG 1
     3                                  	%endif
     4                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  	; RBIOS.ASM - - Relocatable BIOS for the RetroBrew SBC - 188 v.0.4 to 3.1
     6                                  	; Updated for the Duodyne 80c188 SBC 10 / 2024
     7                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     8                                  	;
     9                                  	; This version is for assembly by NASM 0.98.39 or later
    10                                  	;
    11                                  	; Copyright (C) 2011 - 2017 John R. Coffman. All rights reserved.
    12                                  	; Provided for hobbyist use on the RetroBrew SBC - 188 board.
    13                                  	;
    14                                  	; This program is free software: you can redistribute it and / or modify
    15                                  	; it under the terms of the GNU General Public License as published by
    16                                  	; the Free Software Foundation, either version 3 of the License, or
    17                                  	; (at your option) any later version.
    18                                  	;
    19                                  	; This program is distributed in the hope that it will be useful,
    20                                  	; but WITHOUT ANY WARRANTY; without even the implied warranty of
    21                                  	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    22                                  	; GNU General Public License for more details.
    23                                  	;
    24                                  	; You should have received a copy of the GNU General Public License
    25                                  	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
    26                                  	;
    27                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                                  
    29                                  	cpu 186
    30                                  
    31                                  
    32                                  
    33                                  
    34                                  	%include "config.asm"
    35                              <1> ;/*
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; ANSI.CFG
    38                              <1> ;   Copied to CONFIG.ASM for general release.
    39                              <1> ;
    40                              <1> ;       Modify the parameters below to reflect your system
    41                              <1> ;
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    46                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    48                              <1> ;
    49                              <1> ; Define the serial terminal that the Video BIOS must emulate
    50                              <1> ; Set one of the following to 1
    51                              <1> ; If you have no idea what to choose, set TTY to 1
    52                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    53                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    54                              <1> ANSI    equ     1       ; very smart, like a VT-100
    55                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    56                              <1> ; others may get added in the future
    57                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    58                              <1> ;
    59                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    60                              <1> ;UART_RATE	equ	0		; 1200
    61                              <1> ;UART_RATE	equ	1		; 2400
    62                              <1> ;UART_RATE	equ	2		; 4800
    63                              <1> UART_RATE	equ	3		; 9600
    64                              <1> ;UART_RATE	equ	4		; 19200
    65                              <1> ;UART_RATE	equ	5		; 38400
    66                              <1> ;UART_RATE	equ	6		; 57600
    67                              <1> ;UART_RATE	equ	7		; 115200
    68                              <1> 
    69                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    70                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    71                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    72                              <1> 						; but not ANSI
    73                              <1> ; Define the size of the ROM image on the system in Kilobytes
    74                              <1> ; It may be smaller than the actual EPROM in use.
    75                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    76                              <1> %ifndef ROM
    77                              <1> ROM             equ     32              ; 64 is the default
    78                              <1> %endif
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the ROM operates
    81                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    82                              <1> 
    83                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    84                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    85                              <1> RAM_DOS         equ     640
    86                              <1> 
    87                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    88                              <1> ; the default is 512 kilobytes
    89                              <1> RAM             equ     512             ; (512 is the default)
    90                              <1> 
    91                              <1> ; Define the number of Wait States at which the RAM operates
    92                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    93                              <1> 
    94                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    95                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    96                              <1> 
    97                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    98                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    99                              <1> 
   100                              <1> ; Define the time zone in which we build the Relocatable BIOS
   101                              <1> %ifndef TIMEZONE
   102                              <1> %define TIMEZONE "CST"
   103                              <1> %endif
   104                              <1> 
   105                              <1> ; Has the REDBUG debugger been loaded?
   106                              <1> %ifndef SOFT_DEBUG
   107                              <1> %define SOFT_DEBUG 0
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   111                              <1> %ifndef TBASIC
   112                              <1> TBASIC          equ     1		; default is 1
   113                              <1> %endif
   114                              <1> 
   115                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   116                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   117                              <1> %ifndef FPEM
   118                              <1> FPEM            equ     1               ; default is 1
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   122                              <1> ; or at locations 0280h..3FFh in low memory?
   123                              <1> %if SOFT_DEBUG
   124                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   125                              <1> %else
   126                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Define the size of the EPROM that is to be installed on the system
   130                              <1> ; It may be larger than the actual ROM image to be generated.
   131                              <1> %ifndef CHIP
   132                              <1> CHIP            equ     64
   133                              <1> %endif
   134                              <1> 
   135                              <1> ; Define the UART oscillator speed
   136                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   137                              <1> 
   138                              <1> 
   139                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   140                              <1> ; end of the User configuration
   141                              <1> ;       Do Not modify anything below this point
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> 
   144                              <1> ; Define existence of any uart chip
   145                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   146                              <1> startuplength   equ     512                     ; may be up to 1024
   147                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   148                              <1> highrom         equ     (ROM*400h)&0FFFFh
   149                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   150                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   151                              <1> 
   152                              <1> 
   153                              <1> %define ARG(n) [bp+2+(n)*2]
   154                              <1> 
   155                              <1> %macro  check   1.nolist
   156                              <1>  %if (%1)
   157                              <1>    %error Check Failure: %1
   158                              <1>  %endif
   159                              <1> %endm
   160                              <1> %macro  range   3.nolist
   161                              <1>  %if (%1)<(%2)
   162                              <1>    %error Out of Range: %1
   163                              <1>  %elif (%1)>(%3)
   164                              <1>    %error Out of Range: %1
   165                              <1>  %endif
   166                              <1> %endm
   167                              <1> _terminal equ UART
   168                              <1>  check   RAM_DOS&15
   169                              <1>  check   RAM&(RAM-1)
   170                              <1>  check   ROM&(ROM-1)
   171                              <1>  range   RAM,32,512
   172                              <1>  range   ROM,32,256
   173                              <1>  range   RAM_WS,0,3
   174                              <1>  range   ROM_WS,0,3
   175                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   176                              <1>  range   LCL_IO_WS,0,3
   177                              <1>  range   BUS_IO_WS,0,3
   178                              <1>  range   UART_OSC,500000,16000000
   179                              <1>  range   UART_RATE,0,7
   180                              <1>  range	 UART,0,1
   181                              <1>  range	 _terminal,1,2
   182                              <1> 
   183                              <1> %ifndef SOFT_DEBUG
   184                              <1> %define SOFT_DEBUG 0
   185                              <1> %endif
   186                              <1> 
   187                              <1> %ifndef TRACE
   188                              <1> %define TRACE 0
   189                              <1> %endif
   190                              <1> 
   191                              <1> %ifdef MAKE_OBJECT_FILE
   192                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   193                              <1>         export _ROMsize
   194                              <1>         export _CHIPsize
   195                              <1> _ROMsize        dw      ROM
   196                              <1> _CHIPsize       dw      CHIP
   197                              <1> %endif
   198                              <1> ; end of the Hardware configuration file
   199                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   200                              <1> ;*/
    35                                  	%include "cpuregs.asm"
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; CPUREGS.ASM
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    41                              <1> ;
    42                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    43                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    44                              <1> ;
    45                              <1> ; This program is free software: you can redistribute it and/or modify
    46                              <1> ; it under the terms of the GNU General Public License as published by
    47                              <1> ; the Free Software Foundation, either version 3 of the License, or
    48                              <1> ; (at your option) any later version.
    49                              <1> ;
    50                              <1> ; This program is distributed in the hope that it will be useful,
    51                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    52                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    53                              <1> ; GNU General Public License for more details.
    54                              <1> ;
    55                              <1> ; You should have received a copy of the GNU General Public License
    56                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    57                              <1> ;
    58                              <1> ; Updated for the Duodyne 80c188 SBC
    59                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                              <1> %include	"macros.inc"
    61                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <2> ; MACROS.INC  
    63                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <2> ;
    65                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    66                              <2> ;
    67                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    68                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    69                              <2> ;
    70                              <2> ; This program is free software: you can redistribute it and/or modify
    71                              <2> ; it under the terms of the GNU General Public License as published by
    72                              <2> ; the Free Software Foundation, either version 3 of the License, or
    73                              <2> ; (at your option) any later version.
    74                              <2> ;
    75                              <2> ; This program is distributed in the hope that it will be useful,
    76                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    77                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    78                              <2> ; GNU General Public License for more details.
    79                              <2> ;
    80                              <2> ; You should have received a copy of the GNU General Public License
    81                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    82                              <2> ;
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> 
    85                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    86                              <2> ;
    87                              <2> ;
    88                              <2> %ifndef __MACROS_DEFINED_
    89                              <2> %define __MACROS_DEFINED_ 1
    90                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    91                              <2> ;
    92                              <2> ; some useful macros:
    93                              <2> ;
    94                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                              <2> ;
    96                              <2> 	cpu	186
    97                              <2> 
    98                              <2> %imacro setloc  1.nolist
    99                              <2>  times   (%1-($-$$)) db 0FFh
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro db_lo   1
   103                              <2>  db (%1)&255
   104                              <2> %endm
   105                              <2> 
   106                              <2> %imacro cnop    0.nolist
   107                              <2> %if SOFT_DEBUG
   108                              <2>         nop
   109                              <2> %endif
   110                              <2> %endm
   111                              <2> 
   112                              <2> %imacro popm 1-*.nolist
   113                              <2> %rep %0
   114                              <2> %ifidni %1,ALL
   115                              <2>  popa
   116                              <2> %elifidni %1,F
   117                              <2>  popf
   118                              <2> %else
   119                              <2>  pop %1
   120                              <2> %ifidni %1,DS
   121                              <2>  cnop
   122                              <2> %elifidni %1,ES
   123                              <2>  cnop
   124                              <2> %endif
   125                              <2> %endif
   126                              <2> %rotate 1
   127                              <2> %endrep
   128                              <2> %endm
   129                              <2> 
   130                              <2> %imacro pushm 1-*.nolist
   131                              <2> %rep %0
   132                              <2> %rotate -1
   133                              <2> %ifidni %1,ALL
   134                              <2>  pusha
   135                              <2> %elifidni %1,F
   136                              <2>  pushf
   137                              <2> %else
   138                              <2>  push %1
   139                              <2> %endif
   140                              <2> %endrep
   141                              <2> %endm
   142                              <2> 
   143                              <2> ;
   144                              <2> ; added from the 386EX project
   145                              <2> ;
   146                              <2> 
   147                              <2> ; call arguments
   148                              <2> %define ARG(n) [bp+2+(n)*2]
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the BYTE initialization table:  address, byte
   152                              <2> ;
   153                              <2> %imacro  binit 2
   154                              <2>         dw      %1
   155                              <2>         db      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> ;
   160                              <2> ; format of the WORD initialization table:  address, word
   161                              <2> ;
   162                              <2> %imacro  winit 2
   163                              <2>         dw      %1
   164                              <2>         dw      %2
   165                              <2> %endmacro
   166                              <2> ; end with DW -1
   167                              <2> 
   168                              <2> 
   169                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   170                              <2> %imacro get_bda	1.nolist
   171                              <2> 	push	0x0040
   172                              <2> 	pop	%1
   173                              <2> 	cnop
   174                              <2> %endm
   175                              <2> 
   176                              <2> 
   177                              <2> %endif
    61                              <1> 
    62                              <1> 	cpu     186
    63                              <1> ;
    64                              <1> ;
    65                              <1> ; IBM model byte -- must be less than a 286
    66                              <1> ;
    67                              <1> 
    68                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    69                              <1> SUBMODEL_BYTE		equ	00h	;  "
    70                              <1> 
    71                              <1> 
    72                              <1> ; 80188 peripheral control register block address
    73                              <1> CPU_CSCR	        equ	0FF00h
    74                              <1> 
    75                              <1> ; Compatible Mode registers
    76                              <1> 
    77                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    78                              <1> 
    79                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    80                              <1> 
    81                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    82                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    83                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    84                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    85                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    86                              <1> 
    87                              <1> ; Enhanced Mode registers
    88                              <1> 
    89                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    90                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    91                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    92                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    93                              <1> 
    94                              <1> 
    95                              <1> ; On-board internal peripheral equates
    96                              <1> ; Programmable Interrupt Controller
    97                              <1> PIC	        equ	CPU_CSCR+020H
    98                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    99                              <1> PIC_POLLR	equ	PIC+4
   100                              <1> PIC_POLLSR	equ	PIC+6
   101                              <1> PIC_IMASK	equ	PIC+8
   102                              <1> PIC_PMREG	equ	PIC+0AH
   103                              <1> PIC_SRVR	equ	PIC+0CH
   104                              <1> PIC_IRQR	equ	PIC+0EH
   105                              <1> PIC_IRQSR	equ	PIC+10H
   106                              <1> PIC_TCR	        equ	PIC+12H
   107                              <1> PIC_DMA0CR	equ	PIC+14H
   108                              <1> PIC_DMA1CR	equ	PIC+16H
   109                              <1> PIC_I0CON	equ	PIC+18H
   110                              <1> PIC_I1CON	equ	PIC+1AH
   111                              <1> PIC_I2CON	equ	PIC+1CH
   112                              <1> PIC_I3CON	equ	PIC+1EH
   113                              <1> 
   114                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   115                              <1> 
   116                              <1> ; Interrupt masks (Master Mode)
   117                              <1> ;
   118                              <1> mask_timer_all          equ     0001h
   119                              <1> mask_dma0               equ     0004h
   120                              <1> mask_dma1               equ     0008h
   121                              <1> mask_int0               equ     0010h
   122                              <1> mask_int1               equ     0020h
   123                              <1> mask_int2               equ     0040h
   124                              <1> mask_int3               equ     0080h
   125                              <1> 
   126                              <1> 
   127                              <1> 
   128                              <1> ; Timers
   129                              <1> TIM0	        equ	CPU_CSCR+050H
   130                              <1> TIM1	        equ	CPU_CSCR+058H
   131                              <1> TIM2	        equ	CPU_CSCR+060H
   132                              <1> 
   133                              <1> TCNT	        equ	0	; count register
   134                              <1> CMPA	        equ	2	; max count A
   135                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   136                              <1> TCON	        equ	6	; mode/control word
   137                              <1> 
   138                              <1> ; Timer control bits:
   139                              <1> tc_EN           equ     8000h   ; Enable bit
   140                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   141                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   142                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   143                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   144                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   145                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   146                              <1> tc_EXT          equ     0004h   ; External clock
   147                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   148                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   149                              <1> 
   150                              <1> 
   151                              <1> 
   152                              <1> 
   153                              <1> ; DMA
   154                              <1> DMA0	        equ	CPU_CSCR+0C0H
   155                              <1> DMA1	        equ	CPU_CSCR+0D0H
   156                              <1> DMASPL	        equ	0	; source pointer low
   157                              <1> DMASPU	        equ	2	; source pointer high
   158                              <1> DMADPL	        equ	4	; destination pointer low
   159                              <1> DMADPU	        equ	6	; destination pointer high
   160                              <1> DMATC	        equ	8	; terminal count
   161                              <1> DMACW	        equ	0AH	; control word
   162                              <1> 
   163                              <1> 
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   168                              <1> ;
   169                              <1> ;       SBC-188 external devices
   170                              <1> ;
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> 
   173                              <1> IO_BASE			equ	0400h
   174                              <1> 
   175                              <1> 
   176                              <1> 
   177                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   178                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   180                              <1> 
   181                              <1> uart_base               equ     IO_BASE+0280h
   182                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   183                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   184                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   185                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   186                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   187                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   188                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   189                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   190                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   191                              <1> uart_sr			equ	uart_base+7	;Scratch
   192                              <1> 
   193                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   194                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   195                              <1> 
   196                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   197                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   198                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199                              <1> CTRL259		equ	IO_BASE+0238H
   200                              <1> ; LEDS are at addresses 0..3
   201                              <1> ; other control ports on 4..7
   202                              <1> LED0		equ	CTRL259+0
   203                              <1> LED1		equ	LED0+1
   204                              <1> LED2		equ	LED0+2
   205                              <1> LED3		equ	LED0+3
   206                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   207                              <1> ;unused		equ	CTRL259+5
   208                              <1> ;unused		equ	CTRL259+6
   209                              <1> ;unused		equ	CTRL259+7
   210                              <1> 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   215                              <1> 
   216                              <1> 
   217                              <1> 
   218                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                              <1> ; Floppy controller (Duodyne Disk IO)
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> FDC	        equ	IO_BASE+0080H
   222                              <1> FDC_MSR         equ     FDC
   223                              <1> FDC_DATA        equ     FDC+1
   224                              <1> FDC_TC	        equ	FDC+2
   225                              <1> FDC_RES	        equ	FDC+3
   226                              <1> FDC_LDCR	equ	FDC+5
   227                              <1> FDC_LDOR	equ	FDC+6
   228                              <1> FDC_DACK        equ	FDC+6
   229                              <1> FDC_DACK_TC     equ     FDC+7
   230                              <1> 
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> ; CH376 controller (Duodyne Multi IO)
   233                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                              <1> CH376	        equ	IO_BASE+004EH
   235                              <1> 
   236                              <1> 
   237                              <1> 
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   240                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   241                              <1> RTC	equ	IO_BASE+0094H
   242                              <1> 
   243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   244                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   245                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   246                              <1> PPI	        equ	IO_BASE+0088H
   247                              <1> 
   248                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   249                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   250                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   251                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   252                              <1> 
   253                              <1> portA           equ     PPI+0   ;
   254                              <1> portB           equ     PPI+1   ;
   255                              <1> portC           equ     PPI+2   ;
   256                              <1> 
   257                              <1> ; end CPUREGS.ASM
    36                                  	%include "date.asm"
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> ; date.asm
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    41                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    42                              <1> ;
    43                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    44                              <1> ;
    45                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    46                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    47                              <1> ;
    48                              <1> ; Definitions for version 3.5-2:
    49                              <1> ;
    50                              <1> ; Updated for the Duodyne 80c188 SBC
    51                              <1> 
    52                              <1> %define DATE_STRING0	"10/27/24"
    53                              <1> %define DATE_STRING1	"27-Oct-2024"
    54                              <1> 
    55                              <1> %define VERSION_MAJOR		3
    56                              <1> %define VERSION_MINOR		5
    57                              <1> %define VERSION_REVISION	2
    58                              <1> %define VERSION_SUFFIX		""
    59                              <1> %define VERSION_SEQUENCE	66
    60                              <1> 
    61                              <1> %define VERSION_STRING		"3.5-D",VERSION_SUFFIX
    62                              <1> 
    63                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <1> ; Revision information:
    65                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    66                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    67                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    68                              <1> ;	    &  Dual SDcard & Minix boot
    69                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    70                              <1> ;	3.0 -- VGA3 support
    71                              <1> ;	3.1 -- SBC-188 v.3 board support
    72                              <1> ;	3.2 -- IDE8 support on the v.3 board
    73                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    74                              <1> ;	3.4 -- floppy drives did not work
    75                              <1> ;	3.5 -- back to 3.3, sequence #51
    76                              <1> ;		change NVRAM battery backup setup to #53
    77                              <1> ;		re-install 3.4 boot fix for FreeDOS
    78                              <1> ;       3.5-D  Remove SBC-188 specific items and customize for Duodyne
    79                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                                  	%include "equates.asm"
    38                              <1> ;========================================================================
    39                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    40                              <1> ;========================================================================
    41                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    46                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;
    48                              <1> ; This program is free software: you can redistribute it and/or modify
    49                              <1> ; it under the terms of the GNU General Public License as published by
    50                              <1> ; the Free Software Foundation, either version 3 of the License, or
    51                              <1> ; (at your option) any later version.
    52                              <1> ;
    53                              <1> ; This program is distributed in the hope that it will be useful,
    54                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    55                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    56                              <1> ; GNU General Public License for more details.
    57                              <1> ;
    58                              <1> ; You should have received a copy of the GNU General Public License
    59                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    60                              <1> ;
    61                              <1> ;========================================================================
    62                              <1> 
    63                              <1>         global  FPEM_segment
    64                              <1> 
    65                              <1> 
    66                              <1> %include "segdef.asm"
    67                              <2> ;========================================================================
    68                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    69                              <2> ;========================================================================
    70                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    71                              <2> ;
    72                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    73                              <2> ;
    74                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    75                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    76                              <2> ;
    77                              <2> ; This program is free software: you can redistribute it and/or modify
    78                              <2> ; it under the terms of the GNU General Public License as published by
    79                              <2> ; the Free Software Foundation, either version 3 of the License, or
    80                              <2> ; (at your option) any later version.
    81                              <2> ;
    82                              <2> ; This program is distributed in the hope that it will be useful,
    83                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    84                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    85                              <2> ; GNU General Public License for more details.
    86                              <2> ;
    87                              <2> ; You should have received a copy of the GNU General Public License
    88                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    89                              <2> ;
    90                              <2> ;========================================================================
    91                              <2> 
    92                              <2> %ifndef __SEGDEF_
    93                              <2> %define __SEGDEF_
    94                              <2> 
    95                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    96                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    97                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    98                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    99                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   100                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   101                              <2> 
   102                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   103                              <2> 
   104                              <2> %endif
   105                              <2> 
    67                              <1> %include "ascii.asm"
    68                              <2> ; ascii.asm
    69                              <2> ;
    70                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    71                              <2> 
    72                              <2> NUL     equ     00h
    73                              <2> BEL     equ     (CTRL & 'G')
    74                              <2> BS      equ     08h		; ^H
    75                              <2> HT      equ     09h		; ^I
    76                              <2> LF	equ	0Ah		; ^J
    77                              <2> NL      equ     LF
    78                              <2> VT	equ	0Bh		; ^K
    79                              <2> FWD	equ	0Ch		; ^L
    80                              <2> CR	equ	0Dh
    81                              <2> XON     equ     (CTRL & 'Q')
    82                              <2> XOFF    equ     (CTRL & 'S')
    83                              <2> DC1     equ     XON
    84                              <2> DC3     equ     XOFF
    85                              <2> ESC     equ	1Bh
    86                              <2> 
    87                              <2> 
    68                              <1> 
    69                              <1> 
    70                              <1> ; POST error codes. Presently one byte but can expand to word.
    71                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    72                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    73                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    74                              <1> ER_FDC	equ	08h		; Bad FDC
    75                              <1> ER_UNK1	equ	10h		; {unassigned}
    76                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    77                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    78                              <1> ER_UNK2	equ	80h		; {unassigned}
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ;; ************************ BIOS Data Segment ******************************
    83                              <1> ;; BIOS data segment - not all will  be used
    84                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    85                              <1> %include "bda.inc"
    86                              <2> ;/*======================================================================
    87                              <2> ; bda.inc -- BIOS data area definitions
    88                              <2> ;========================================================================
    89                              <2> ;   for the N8VEM SBC-188
    90                              <2> ;
    91                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    92                              <2> ;
    93                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    94                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    95                              <2> ;
    96                              <2> ; This program is free software: you can redistribute it and/or modify
    97                              <2> ; it under the terms of the GNU General Public License as published by
    98                              <2> ; the Free Software Foundation, either version 3 of the License, or
    99                              <2> ; (at your option) any later version.
   100                              <2> ;
   101                              <2> ; This program is distributed in the hope that it will be useful,
   102                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   103                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   104                              <2> ; GNU General Public License for more details.
   105                              <2> ;
   106                              <2> ; You should have received a copy of the GNU General Public License
   107                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   108                              <2> ;
   109                              <2> ;========================================================================
   110                              <2> 
   111                              <2> 			;*/ extern				/*
   112                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   113 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   114 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   115 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   116                              <2> ;	dw	?		; 40:10 	; Equipment present word
   117                              <2> ;  						;  = (1 iff floppies) *     1.
   118                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   119                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   120                              <2> ;  						;  + (init crt mode ) *    16.
   121                              <2> ;  						;  + (# of floppies ) *    64.
   122                              <2> ;  						;  + (# serial ports) *   512.
   123                              <2> ;  						;  + (1 iff toy port) *  4096.
   124                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   125                              <2> ;  						;  + (# parallel LPT) * 16384.
   126 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   127 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   128                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   129 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   130 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   131                              <2> ;;---------------[Keyboard data area]------------;
   132 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   133                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;
   134 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   135 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   136 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   137 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   138                              <2> kbd_buffer_last	equ	$	;*/				/*
   139                              <2> ;;---------------[Diskette data area]------------;
   140 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   141 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   142 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   143 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   144                              <2> ;				Floppy return code stat byte
   145                              <2> ;				;  1 = bad ic 765 command req.
   146                              <2> ;				;  2 = address mark not found
   147                              <2> ;				;  3 = write to protected disk
   148                              <2> ;				;  4 = sector not found
   149                              <2> ;				;  8 = data late (DMA overrun)
   150                              <2> ;				;  9 = DMA failed 64K page end
   151                              <2> ;				; 16 = bad CRC on floppy read
   152                              <2> ;				; 32 = bad NEC 765 controller
   153                              <2> ;				; 64 = seek operation failed
   154                              <2> ;				;128 = disk drive timed out
   155 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   156                              <2> ;;---------------[Video display area]------------;
   157 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   158                              <2> ;			 	; Current CRT mode  (software)
   159                              <2> ;				;  0 = 40 x 25 text (no color)
   160                              <2> ;				;  1 = 40 x 25 text (16 color)
   161                              <2> ;				;  2 = 80 x 25 text (no color)
   162                              <2> ;				;  3 = 80 x 25 text (16 color)
   163                              <2> ;				;  4 = 320 x 200 grafix 4 color
   164                              <2> ;				;  5 = 320 x 200 grafix 0 color
   165                              <2> ;				;  6 = 640 x 200 grafix 0 color
   166                              <2> ;				;  7 = 80 x 25 text (mono card)
   167 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   168 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   169 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   170 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   171 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   172 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   173 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   174 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   175 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   176                              <2> ;;---------------[Used to setup ROM]-------------;
   177 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   178 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   179                              <2> ;;---------------[Timer data area]---------------;
   180 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   181 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   182                              <2> ;;---------------[System data area]--------------;
   183 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   184 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   185                              <2> ;;---------------[Hard disk scratchpad]----------;
   186 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   187                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   188 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   189 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   190                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   191 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   192 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   193                              <2> ;;---------------[EGA stuff]---------------------;
   194 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   195                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   196 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   197 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   198 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   199 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   200 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   201                              <2> ;;---------------[Additional KBD flags]----------------;
   202 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   203 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   204                              <2> ;;---------------[RTC/timer1 data]---------------------;
   205 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   206 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   207 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h,
   208                              <2> ;;---------------[Cassette I/O stuff]------------------;
   209 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   210 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   211                              <2> ;									Post Acknowleged=00;
   212 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   213 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   214 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   215                              <2> ;
   216 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   217 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   218 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   219 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   220                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   221 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   222 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   223 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   224 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   225 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   226 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   227 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   228 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   229 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   230 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   231 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   232 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   233 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   234 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   235 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   236                              <2> ;
   237                              <2> ;
   238                              <2> 
   239 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   240                              <2> 
   241 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   242                              <2> 
   243 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   244 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   245                              <2> 
   246 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib
   247                              <2> 
   248 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   249                              <2> 
   250 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   251                              <2> 
   252 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz
   253                              <2> ;								   CPU clock is half of this
   254                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <2> ;
   256                              <2> ;  System configuration stuff below
   257                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   258                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <2> %if 0				;*/
   260                              <2> #define FIXED_DISK_MAX 4		/*
   261                              <2> %else
   262                              <2> %define FIXED_DISK_MAX 4
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define PPIDE_driver 1		/*
   266                              <2> %else
   267                              <2> %define PPIDE_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define USB_driver 1		/*
   271                              <2> %else
   272                              <2> %define USB_driver 1
   273                              <2> %endif
   274                              <2> 				;*/
    86                              <1> 
    87                              <1> ;  this must be the same in EQUATES.H */
    88                              <1> %if SOFT_DEBUG
    89                              <1> %define NBREAK  8
    90                              <1> %endif
    91                              <1> 
    92                              <1> 
    93                              <1> %if 0
    94                              <1>         segment _TEXT
    95                              <1> ;; *************************************************************************
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ;; ************************ DOS Data Segment *******************************
   101                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   102                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   103                              <1> ;						;  1 if PrtSc xeroxing screen
   104                              <1> ;						;255 if PrtSc error in xerox
   105                              <1> ;						;  ...non-grafix PrtSc in bios
   106                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   107                              <1> ;						;  ...IBMBIO.COM buffers the
   108                              <1> ;						;  ...directory of the boot
   109                              <1> ;						;  ...device here at IPL time
   110                              <1> ;						;  ...when locating the guts
   111                              <1> ;						;  ...of the operating system
   112                              <1> ;						;  ...filename "IBMDOS.COM"
   113                              <1> ;dosdir	ends
   114                              <1> ;; *************************************************************************
   115                              <1> ;; ************************ DOS IPL Segment ********************************
   116                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   117                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   118                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   119                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   120                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   121                              <1> ;dosseg	ends					;			      !
   122                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   123                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   124                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   125                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   126                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   127                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   128                              <1> ;iplseg	ends
   129                              <1> 
   130                              <1> %endif
    38                                  
    39                                  	%define VERSION VERSION_STRING
    40                                  	%define DATE DATE_STRING1
    41                                  
    42                                  	;; global begin_here
    43                                  	global cold_boot
    44                                  	global initialization
    45                                  	extern ident2
    46                                  	extern _cprintf
    47                                  	%if TRACE
    48                                  	extern int_trace
    49                                  	%endif                       ; TRACE
    50                                  
    51                                  
    52                                  	segment _TEXT
    53                                  
    54                                  cold_boot:
    55 00000000 FA                      	cli                          ; Should be clear already
    56 00000001 89C3                    	mov bx, ax                   ; save board revision in BX
    57                                  	%if SOFT_DEBUG
    58                                  	mov dx, FRONT_PANEL_LED
    59                                  	mov al, 0A5h                 ; A5 to the LITES
    60                                  	out dx, al
    61                                  	%endif
    62 00000003 B84000                  	mov ax, bios_data_seg
    63 00000006 8ED0                    	mov ss, ax
    64 00000008 BC0070                  	mov sp, 7000h                ; Stack should be out of the way
    65                                  	; cannot use the stack yet, since memory is not tested
    66                                  	%if 0
    67                                  	ss mov bx, word [warm_boot]  ; check for 1234h == Warm Boot
    68                                  	%else
    69 0000000B 30FF                    	xor bh, bh                   ; not warm boot
    70 0000000D 36813E72003412          	ss cmp word [warm_boot], 1234h
    71 00000014 7504                    	jne .1
    72 00000016 FEC7                    	inc bh                       ; it IS a warm boot
    73 00000018 EB08                    	jmp cold_continue            ; JRC - DEBUG test
    74                                  .1:
    75                                  	%endif
    76                                  	%if SOFT_DEBUG
    77                                  	push 5Ah
    78                                  	call lites
    79                                  	%endif
    80                                  memory_testing:
    81                                  	; Immediately test low memory
    82 0000001A 31C0                    	xor ax, ax                   ; Segment 0
    83 0000001C BD[2200]                	mov bp, .0                   ; return address
    84 0000001F E9DB03                  	jmp memtest0                 ; don't use the stack
    85                                  .0:
    86                                  	; BX was preserved by 'memtest0'
    87                                  
    88                                  	%if SOFT_DEBUG
    89                                  	jnc cold_continue
    90                                  	mov dx, FRONT_PANEL_LED
    91                                  	mov al, 0F1h                 ; F1 to the LITES
    92                                  	out dx, al
    93                                  .1:
    94                                  	hlt
    95                                  	jmp .1                       ; solid halt on error
    96                                  	%endif
    97                                  
    98                                  cold_continue:
    99 00000022 FC                      	cld                          ; Clear the direction flag
   100 00000023 31C0                    	xor ax, ax
   101 00000025 8EC0                    	mov es, ax
   102                                  	cnop
   103 00000027 89C7                    	mov di, ax
   104 00000029 B90003                  	mov cx, 600h / 2             ; clear segments 00h, 040h and 050h
   105 0000002C F3AB                    	rep stosw                    ; clear out BIOS DATA AREA
   106                                  
   107                                  	%if 0
   108                                  	ss mov word [warm_boot], bx  ; save only warm boot flag
   109                                  	%else
   110 0000002E 36881E1600              	ss mov byte [sbc188_rev], bl ; save board revision
   111 00000033 36891E7200              	ss mov word [warm_boot], bx  ; save warm boot garbage
   112 00000038 08FF                    	or bh, bh                    ; test for warm boot
   113 0000003A 7407                    	jz .3
   114 0000003C 36C70672003412          	ss mov word [warm_boot], 1234h ; restore warm boot code
   115                                  .3:
   116                                  	%endif
   117 00000043 E84903                  	call get_ramsize
   118 00000046 C1E006                  	shl ax, 6                    ; convert to Segment address
   119                                  	%if SOFT_DEBUG
   120                                  	mov cx, _BSS                 ; paragraph of _BSS segment
   121                                  	; since the BSS is of length 0000, this is beyond all data
   122                                  
   123                                  	mov bx, cs                   ; Code Segment
   124                                  	sub cx, bx                   ; Code paragraphs
   125                                  	push cx
   126                                  	mov bx, ax                   ; Save HMA in K
   127                                  	sub bx, cx                   ; new Code segment
   128                                  	mov es, bx                   ; Destination
   129                                  	cnop
   130                                  	mov ax, bx                   ; Paragraph address to AX
   131                                  
   132                                  	push cs
   133                                  	popm ds                      ; Source
   134                                  	xor si, si
   135                                  	xor di, di
   136                                  	pop cx                       ; Code length in Paragraphs
   137                                  	shl cx, 3                    ; Code length in words
   138                                  	rep movsw                    ; move all of it
   139                                  	push es                      ; new Code segment
   140                                  	push word SOFT_continue      ; IP
   141                                  	retf
   142                                  
   143                                  	global SOFT_continue
   144                                  SOFT_continue:                ; Continue here in soft memory
   145                                  	;
   146                                  	; Allocate the DEBUG static area
   147                                  	;
   148                                  	mov cx, (NBREAK + 1) * 8 + 15
   149                                  	shr cx, 4                    ; CX=needed paragraphs
   150                                  	sub ax, cx                   ; allocate space
   151                                  	ss mov [debug_static_ptr + 2], ax ; setup static area segment
   152                                  	ss mov word [debug_static_ptr], 0 ; and offset
   153                                  	shl cx, 4                    ; word count
   154                                  	pushm ax, ax                 ; save segment, twice
   155                                  	popm es                      ; set segment to zap
   156                                  	xor di, di                   ; start at offset 0
   157                                  	mov ax, di                   ; AL=0
   158                                  	rep stosb                    ; Zap memory
   159                                  	popm ax                      ; restore AX, EBDA paragraph segment
   160                                  	%endif
   161                                  	;
   162                                  	; Save the memory pointers
   163                                  	;
   164 00000049 36A3F200                	ss mov [EBDA_paragraph], ax
   165 0000004D C1E806                  	shr ax, 6
   166 00000050 36A31300                	ss mov [memory_size], ax
   167                                  
   168 00000054 68[ssss]                	push DGROUP
   169 00000057 1F                      	popm ds                      ; This is for the C - programs
   170                                  
   171 00000058 E80102                  	call set_traps               ; setup interrupt table
   172 0000005B E8FD01                  	call set_interrupt_priority  ; set default interrupt priorities
   173                                  
   174 0000005E B80300                  	mov ax, UART_RATE            ; set the default rate
   175                                  	extern @nvram_get_video
   176 00000061 E8(0000)                	call @nvram_get_video
   177                                  	; get RAM_serial byte - UART speed
   178                                  	; returned in AL
   179                                  	%if SOFT_DEBUG
   180                                  	PUSH 3
   181                                  	CALL lites
   182                                  	%endif
   183                                  	extern video_init
   184 00000064 E8(0000)                	call video_init
   185                                  
   186                                  	%if SOFT_DEBUG
   187                                  	PUSH 4
   188                                  	CALL lites
   189                                  	%endif
   190                                  	extern keyboard_init
   191 00000067 E8(0000)                	call keyboard_init
   192                                  
   193                                  	%if SOFT_DEBUG
   194                                  	PUSH 5
   195                                  	CALL lites
   196                                  	%endif
   197 0000006A FB                      	sti                          ; enable interrupts
   198                                  	%if FPEM
   199 0000006B 9BDBE3                  	finit                        ; will allocate memory
   200                                  	%endif
   201                                  	%if SOFT_DEBUG
   202                                  	PUSH 1
   203                                  	CALL lites
   204                                  	%endif
   205                                  
   206 0000006E 6A42                    	push VERSION_SEQUENCE
   207 00000070 0E                      	push cs
   208 00000071 68[4206]                	push ident1
   209 00000074 E8(0000)                	call _cprintf
   210 00000077 58                      	pop ax
   211 00000078 68[0000]                	push ident2
   212 0000007B E8(0000)                	call _cprintf
   213 0000007E 58                      	pop ax
   214 0000007F 68[FF05]                	push ident3
   215 00000082 E8(0000)                	call _cprintf
   216 00000085 58                      	pop ax
   217 00000086 58                      	pop ax
   218 00000087 58                      	pop ax
   219                                  
   220                                  	%if SOFT_DEBUG
   221                                  	%if SOFT_DEBUG>1
   222                                  	PUSH 2
   223                                  	CALL lites
   224                                  	%endif
   225                                  	extern redbug
   226                                  
   227                                  	pushf                        ; push the flags
   228                                  	push cs                      ; simulate a far call
   229                                  	call redbug                  ; call our weak debugger
   230                                  	es mov cx, [bp + si + 4]
   231                                  	%if SOFT_DEBUG>1
   232                                  	PUSH 3
   233                                  	CALL lites
   234                                  	%endif
   235                                  
   236                                  	%endif
   237                                  
   238                                  	HAS_FLOPPY equ 0000000000000001b
   239                                  	HAS_FPU equ 0000000000000010b
   240                                  	HAS_MOUSE equ 0000000000000100b
   241                                  	VIDEO_EGA equ 0000000000000000b
   242                                  	VIDEO_COLOR_40 equ 0000000000010000b
   243                                  	VIDEO_COLOR_80 equ 0000000000100000b
   244                                  	VIDEO_MONO equ 0000000000110000b
   245                                  	FLOPPIES_1 equ 0000000000000000b
   246                                  	FLOPPIES_2 equ 0000000001000000b
   247                                  	FLOPPIES_3 equ 0000000010000000b
   248                                  	FLOPPIES_4 equ 0000000011000000b
   249                                  	SERIAL_0 equ 0000000000000000b
   250                                  	SERIAL_1 equ 0000001000000000b
   251                                  	SERIAL_2 equ 0000010000000000b
   252                                  	SERIAL_3 equ 0000011000000000b
   253                                  	SERIAL_4 equ 0000100000000000b
   254                                  	SERIAL_5 equ 0000101000000000b
   255                                  	SERIAL_6 equ 0000110000000000b
   256                                  	SERIAL_7 equ 0000111000000000b
   257                                  	PARALLEL_0 equ 0000000000000000b
   258                                  	PARALLEL_1 equ 0100000000000000b
   259                                  	PARALLEL_2 equ 1000000000000000b
   260                                  	PARALLEL_3 equ 1100000000000000b
   261                                  
   262                                  
   263                                  	; setup BIOS data area
   264 00000088 6A40                    	push bios_data_seg
   265 0000008A 1F                      	popm ds
   266 0000008B C606AE0000              	mov byte [lock_count], 0     ; zap the @enable / @disable lock count
   267                                  	; no serial interface - - it is used for the video driver
   268 00000090 B83100                  	mov ax, PARALLEL_0|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   269                                  	%if FPEM
   270 00000093 83C802                  	or ax, HAS_FPU               ; a bit of a lie
   271                                  	%endif
   272 00000096 A31000                  	mov word [equipment_flag], ax
   273                                  
   274                                  	extern _cpu_speed
   275 00000099 E8(0000)                	call _cpu_speed
   276 0000009C 055802                  	add ax, 600
   277 0000009F B9E204                  	mov cx, 1250
   278 000000A2 31D2                    	xor dx, dx
   279 000000A4 F7F1                    	div cx
   280 000000A6 A2FF00                  	mov byte [cpu_xtal], al      ; CPU oscillator frequency
   281                                  
   282 000000A9 FF361300                	push word [memory_size]
   283                                  
   284 000000AD 68[ssss]                	push DGROUP
   285 000000B0 1F                      	popm ds                      ; This is for the C - programs
   286                                  
   287 000000B1 50                      	push ax
   288                                  	extern @timer_init
   289 000000B2 E8(0000)                	call @timer_init
   290 000000B5 58                      	pop ax
   291                                  
   292 000000B6 1E                      	push ds
   293 000000B7 A90100                  	test ax, 1
   294 000000BA 7505                    	jnz .cpu_clock_05
   295 000000BC 68[6D01]                	push msg_cpu_clock_00
   296 000000BF EB03                    	jmp .print_cpu_clock
   297                                  .cpu_clock_05:
   298 000000C1 68[6A01]                	push msg_cpu_clock_05
   299                                  .print_cpu_clock:
   300 000000C4 D1E8                    	shr ax, 1
   301 000000C6 50                      	push ax
   302 000000C7 1E                      	push ds
   303 000000C8 68[3201]                	push msg_cpu_memory
   304 000000CB E8(0000)                	call _cprintf
   305 000000CE 83C40A                  	add sp, 12 - 2
   306                                  	%if 1
   307 000000D1 58                      	pop ax                       ; memory size in K
   308 000000D2 E89403                  	call POST_memory             ; Power On Self Test
   309                                  
   310 000000D5 36C70672003412          	ss mov word [warm_boot], 1234h ; set warm boot code
   311                                  
   312                                  	%endif
   313 000000DC E80F00                  	call nvram_init
   314                                  
   315 000000DF 1E                      	push ds                      ; DS = DGROUP (CONST)
   316 000000E0 68[DB01]                	push msg_floppy
   317 000000E3 E8(0000)                	call _cprintf
   318 000000E6 83C404                  	add sp, 4
   319                                  
   320                                  	extern @floppy_init
   321 000000E9 E8(0000)                	call @floppy_init
   322                                  
   323 000000EC EB6A                    	jmp boot_the_OS
   324                                  
   325                                  
   326                                  	;========================================================================
   327                                  	; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   328                                  	;========================================================================
   329                                  nvram_init:
   330                                  	extern @nvram_check
   331 000000EE E8(0000)                	call @nvram_check
   332 000000F1 09C0                    	or ax, ax
   333 000000F3 740C                    	jz .ask_setup
   334                                  
   335 000000F5 1E                      	push ds
   336 000000F6 68[B101]                	push msg_nvram_bad
   337 000000F9 E8(0000)                	call _cprintf
   338 000000FC 83C404                  	add sp, 4
   339 000000FF EB35                    	jmp .run_setup
   340                                  
   341                                  .ask_setup:
   342 00000101 1E                      	push ds
   343 00000102 68[6E01]                	push msg_setup
   344 00000105 E8(0000)                	call _cprintf
   345 00000108 83C404                  	add sp, 4
   346                                  
   347 0000010B B400                    	mov ah, 0
   348 0000010D CD1A                    	int 1Ah
   349                                  
   350 0000010F BA3006                  	mov dx,FRONT_PANEL_LED
   351 00000112 EC                      	in al, dx
   352 00000113 3CFF                    	cmp al,0FFh
   353 00000115 741F                    	je .run_setup
   354                                  
   355 00000117 89D3                    	mov bx, dx
   356 00000119 83C324                  	add bx, 18 * 2               ; wait 2 seconds
   357                                  .wait_setup:
   358 0000011C B401                    	mov ah, 1
   359 0000011E CD16                    	int 16h
   360 00000120 740A                    	jz .wait_setup_1
   361 00000122 B400                    	mov ah, 0
   362 00000124 CD16                    	int 16h
   363 00000126 0C20                    	or al, 's'^'S'
   364 00000128 3C73                    	cmp al, 's'
   365 0000012A 740A                    	je .run_setup
   366                                  
   367                                  
   368                                  
   369                                  .wait_setup_1:
   370 0000012C B400                    	mov ah, 0
   371 0000012E CD1A                    	int 1Ah
   372 00000130 39DA                    	cmp dx, bx
   373 00000132 72E8                    	jb .wait_setup
   374 00000134 EB03                    	jmp .skip_setup
   375                                  
   376                                  .run_setup:
   377                                  	extern @nvram_setup
   378 00000136 E8(0000)                	call @nvram_setup
   379                                  
   380                                  .skip_setup:
   381                                  	extern @nvram_apply
   382 00000139 E8(0000)                	call @nvram_apply
   383                                  
   384 0000013C E8DD01                  	call ticktime                ; set the tick clock
   385                                  
   386 0000013F C3                      	ret
   387                                  
   388                                  	;========================================================================
   389                                  	; BIOS_call_18h - Start ROM Basic
   390                                  	; Note:
   391                                  	; In this BIOS it prints a "no Basic" message and tries to boot the OS
   392                                  	; or it will run tests if tests are enabled
   393                                  	;========================================================================
   394                                  BIOS_call_18h:
   395 00000140 FB                      	sti
   396                                  	%ifdef TESTS
   397                                  	extern tests
   398                                  	call tests
   399                                  	%else                        ; TESTS
   400                                  
   401                                  	%if TBASIC
   402                                  	;;; extern cbasic
   403                                  	;;; extern end_cbasic
   404                                  	;;; jmp seg cbasic:cbasic
   405 00000141 EA000000F0              jmp 0F000h:0000h
   406                                  	%else
   407                                  	mov ax, bios_data_seg
   408                                  	mov ss, ax                   ; Reset SS
   409                                  	mov sp, 7000h                ; and SP
   410                                  	push DGROUP                  ; just in case DS is not pointing
   411                                  	popm ds                      ; were it should
   412                                  
   413                                  	push ds
   414                                  	push msg_no_basic
   415                                  	call _cprintf
   416                                  	add sp, 4
   417                                  	mov ah, 0                    ; get any keystroke; jrc 2012 / 12 / 02
   418                                  	int 16h
   419                                  	int 19h                      ; reboot the OS
   420                                  	%endif                       ; TBASIC
   421                                  
   422                                  	%endif                       ; TESTS
   423                                  .1:
   424 00000146 F4                      	hlt                          ; we should never get here
   425 00000147 EBFD                    	jmp .1
   426                                  
   427                                  	;========================================================================
   428                                  	; BIOS_call_19h - re - Boot the OS
   429                                  	;========================================================================
   430                                  BIOS_call_19h:
   431 00000149 6A40                    	push bios_data_seg
   432 0000014B 1F                      	popm ds
   433 0000014C C70672003412            	mov word [warm_boot], 1234h  ; set warm boot flag
   434 00000152 FA                      	cli                          ; disable interrupts
   435 00000153 EA0000FFFF              jmp 0FFFFh:0000h              ; go to STARTUP.BIN code
   436                                  
   437                                  
   438                                  
   439                                  
   440                                  	;========================================================================
   441                                  	;========================================================================
   442                                  boot_the_OS:
   443 00000158 B84000                  	mov ax, bios_data_seg
   444 0000015B 8ED0                    	mov ss, ax                   ; Reset SS
   445 0000015D BC0070                  	mov sp, 7000h                ; and SP
   446 00000160 68[ssss]                	push DGROUP                  ; just in case DS is not pointing
   447 00000163 1F                      	popm ds                      ; were it should
   448 00000164 FB                      	sti
   449                                  
   450                                  	; Disable Drive A for the time being . . . DDW 11 - 3 - 24
   451                                  	; push 'A'
   452                                  	; push ds
   453                                  	; push msg_booting
   454                                  	; call _cprintf
   455                                  	; add sp, 6
   456                                  	;
   457                                  	; mov dl, 0
   458                                  	; call boot_drive
   459                                  
   460 00000165 6A43                    	push 'C'
   461 00000167 1E                      	push ds
   462 00000168 68[F401]                	push msg_booting
   463 0000016B E8(0000)                	call _cprintf
   464 0000016E 83C406                  	add sp, 6
   465                                  	%if SOFT_DEBUG>1
   466                                  	int 0
   467                                  	%endif
   468 00000171 B280                    	mov dl, 80h
   469 00000173 E80500                  	call boot_drive
   470                                  
   471 00000176 CD18                    	int 18h                      ; failed to boot, start ROM Basic
   472                                  
   473                                  .1:
   474 00000178 F4                      	hlt                          ; we should never get here
   475 00000179 EBFD                    	jmp .1
   476                                  
   477                                  	;========================================================================
   478                                  	; boot_drive - try to boot from the drive
   479                                  	; Input:
   480                                  	; DL = drive number (00h = first floppy, 80h = first HDD)
   481                                  	;========================================================================
   482                                  boot_drive:
   483 0000017B BE0300                  	mov si, 3                    ; make 3 tries before giving up
   484                                  
   485                                  	%if SOFT_DEBUG>1
   486                                  	nop
   487                                  	int 0
   488                                  	%endif
   489                                  .1:                           ; loop comes back here
   490 0000017E B400                    	mov ah, 0                    ; reset the Disk Controller
   491 00000180 CD13                    	int 13h
   492                                  
   493 00000182 52                      	push dx
   494 00000183 B408                    	mov ah, 8                    ; get drive parameters
   495 00000185 CD13                    	int 13h
   496 00000187 88D0                    	mov al, dl                   ; number of drives
   497 00000189 5A                      	pop dx
   498 0000018A 7213                    	jc .fn8_error
   499                                  
   500                                  
   501                                  	%if SOFT_DEBUG > 2
   502                                  	nop
   503                                  	int 0
   504                                  
   505                                  	mov ax, 0401h                ; verify sector
   506                                  	mov cx, 1                    ; track 0, sector 1
   507                                  	mov dh, 0                    ; head 0
   508                                  	int 13h
   509                                  
   510                                  	nop
   511                                  	int 0
   512                                  	%endif
   513                                  
   514 0000018C B80102                  	mov ax, 0201h                ; read one sector
   515 0000018F B90100                  	mov cx, 1                    ; track 0, sector 1
   516 00000192 B600                    	mov dh, 0                    ; head 0
   517 00000194 31DB                    	xor bx, bx
   518 00000196 8EC3                    	mov es, bx                   ; ES = 0
   519 00000198 BB007C                  	mov bx, 7C00h                ; ES:BX = 0000:7C00
   520 0000019B CD13                    	int 13h
   521 0000019D 730F                    	jnc .read_ok
   522                                  
   523                                  .fn8_error:
   524 0000019F 4E                      	dec si                       ; go back and reset the controller
   525 000001A0 75DC                    	jnz .1                       ; make several tries
   526                                  
   527 000001A2 50                      	push ax
   528 000001A3 1E                      	push ds
   529 000001A4 68[1302]                	push msg_boot_err
   530 000001A7 E8(0000)                	call _cprintf
   531 000001AA 83C406                  	add sp, 4 + 2
   532 000001AD C3                      	ret
   533                                  
   534                                  .read_ok:
   535 000001AE 52                      	push dx
   536                                  
   537 000001AF B80480                  	mov ax, 8004h                ; NVRAM bits
   538 000001B2 E8D603                  	call rtc_get_loc
   539 000001B5 A802                    	test al, 2                   ; RAM_bits_AA55 flag
   540 000001B7 7538                    	jnz .cpm_bootsec
   541 000001B9 26813EFE7D55AA          	es cmp word [7C00h + 1FEh], 0AA55h
   542 000001C0 7415                    	je .good_signature
   543 000001C2 26813EBC7D55AA          	es cmp word [7C00h + 1BCh], 0AA55h
   544 000001C9 7420                    	je .minix_bootsec
   545 000001CB 1E                      	push ds
   546 000001CC 68[2D02]                	push msg_no_boot
   547 000001CF E8(0000)                	call _cprintf
   548 000001D2 83C404                  	add sp, 4                    ; remove DX also
   549 000001D5 5A                      	pop dx                       ; * *
   550 000001D6 C3                      	ret
   551                                  .good_signature:
   552 000001D7 26833E007C00            	es cmp word [7C00h + 000h], 0
   553 000001DD 751C                    	jne .good_bootsec
   554 000001DF 1E                      	push ds
   555 000001E0 68[4702]                	push msg_no_loader
   556 000001E3 E8(0000)                	call _cprintf
   557 000001E6 83C404                  	add sp, 4                    ; remove DX also
   558 000001E9 5A                      	pop dx                       ; * *
   559 000001EA C3                      	ret
   560                                  
   561                                  .minix_bootsec:
   562 000001EB 1E                      	push ds                      ; alternate boot signature
   563 000001EC 68[7D02]                	push msg_alt_disk
   564 000001EF EB04                    	jmp short .cpmbs2
   565                                  .cpm_bootsec:
   566 000001F1 1E                      	push ds
   567 000001F2 68[6902]                	push msg_cpm_disk
   568 000001F5 E8(0000)                .cpmbs2: call _cprintf
   569 000001F8 83C404                  	add sp, 4
   570                                  .good_bootsec:
   571 000001FB 1E                      	push ds
   572 000001FC 68[6502]                	push msg_boot_ok
   573 000001FF E8(0000)                	call _cprintf
   574 00000202 83C404                  	add sp, 4
   575                                  
   576 00000205 5A                      	pop dx
   577                                  
   578                                  	%if SOFT_DEBUG>1
   579                                  	global major_debug
   580                                  major_debug:
   581                                  	cmp dl, 0
   582                                  	jne .999
   583                                  
   584                                  	xor bx, bx
   585                                  	push bx
   586                                  	popm es                      ; ES = 0
   587                                  	mov bx, 7C00h                ; ES:BX = 0000:7C00
   588                                  	int 0
   589                                  
   590                                  	mov ax, 0201h
   591                                  	inc cl
   592                                  	int 13h
   593                                  
   594                                  	mov ax, 0201h
   595                                  	mov cl, 10h
   596                                  	int 13h
   597                                  
   598                                  	mov ax, 0201h
   599                                  	mov dh, 1
   600                                  	int 13h
   601                                  
   602                                  	mov ax, 0201h
   603                                  	mov ch, 1                    ; cylinder 1
   604                                  	int 13h
   605                                  
   606                                  	mov ax, 0201h
   607                                  	mov ch, 23h
   608                                  	int 13h
   609                                  
   610                                  	mov ax, 0201h
   611                                  	mov cx, 1
   612                                  	mov dh, 0
   613                                  	int 13h
   614                                  
   615                                  .999:
   616                                  	%endif
   617                                  	%if SOFT_DEBUG
   618                                  	push 7
   619                                  	call lites
   620                                  	int 0
   621                                  	%endif
   622 00000206 EA007C0000              jmp 0000:7C00h                ; execute the boot sector
   623                                  
   624                                  
   625                                  
   626                                  	%if 0                        ; now part of 2P1S from R. Cini (RAC)
   627                                  	;========================================================================
   628                                  	; BIOS_call_14h - Serial port communication services
   629                                  	;========================================================================
   630                                  BIOS_call_14h:
   631                                  	%if TRACE
   632                                  	call int_trace
   633                                  	%endif                       ; TRACE
   634                                  	xor ax, ax
   635                                  	iret
   636                                  
   637                                  	;========================================================================
   638                                  	; BIOS_call_17h - Print services
   639                                  	;========================================================================
   640                                  BIOS_call_17h:
   641                                  	%if TRACE
   642                                  	call int_trace
   643                                  	%endif                       ; TRACE
   644                                  	mov ah, 0
   645                                  	iret
   646                                  
   647                                  	%endif
   648                                  	;========================================================================
   649                                  
   650                                  interrupt_table:
   651                                  
   652                                  	%if SOFT_DEBUG
   653                                  	db 0                         ; Int 0 - divide by zero
   654                                  	extern zero_divide
   655                                  	dw zero_divide
   656                                  
   657                                  	db 1                         ; Int 1 - single step
   658                                  	extern single_step
   659                                  	dw single_step
   660                                  
   661                                  	db 2                         ; Int 2 - NMI interrupt
   662                                  	extern nmi_interrupt
   663                                  	dw nmi_interrupt
   664                                  
   665                                  	db 3                         ; Int 3 - breakpoint
   666                                  	extern breakpoint
   667                                  	dw breakpoint
   668                                  
   669                                  	db 4                         ; Int 4 - interrupt on overflow (INTO instruction)
   670                                  	extern INTO_trap
   671                                  	dw INTO_trap
   672                                  
   673                                  	db 5                         ; Int 5 - bound check error
   674                                  	extern bound_trap
   675                                  	dw bound_trap
   676                                  
   677                                  	db 6                         ; Int 6 - invalid opcode
   678                                  	extern undefined_op
   679                                  	dw undefined_op
   680                                  	%endif                       ; SOFT_DEBUG
   681                                  
   682                                  	%if FPEM
   683                                  	%if 0
   684                                  	db 7                         ; ESC opcode / Floating Point
   685                                  	extern vector7
   686                                  	dw vector7
   687                                  	%endif
   688                                  	%else
   689                                  	%if SOFT_DEBUG
   690                                  	db 7                         ; Int 7 - math coprocessor not present
   691                                  	dw undefined_op
   692                                  	%endif                       ; SOFT_DEBUG
   693                                  	%endif
   694                                  
   695 0000020B 08                      	db 8                         ; Timer 0 interrupt
   696                                  	extern timer0_interrupt
   697 0000020C [0000]                  	dw timer0_interrupt
   698                                  
   699 0000020E 0A                      	db 0Ah                       ; DMA 0 interrupt
   700 0000020F [4702]                  	dw end_of_interrupt
   701                                  
   702 00000211 0B                      	db 0Bh                       ; DMA 1 interrupt
   703 00000212 [4702]                  	dw end_of_interrupt
   704                                  
   705 00000214 0C                      	db 0Ch                       ; INT0 - UART
   706                                  	; eventually this will be PIC code here
   707                                  	%if UART
   708                                  	extern uart_int
   709 00000215 [0000]                  	dw uart_int
   710                                  	%else
   711                                  	dw end_of_interrupt
   712                                  	%endif
   713                                  
   714 00000217 0D                      	db 0Dh                       ; INT1
   715 00000218 [4702]                  	dw end_of_interrupt
   716                                  
   717 0000021A 0E                      	db 0Eh                       ; INT1 -
   718 0000021B [4702]                  	dw end_of_interrupt
   719                                  
   720 0000021D 0F                      	db 0Fh
   721 0000021E [4702]                  	dw end_of_interrupt
   722                                  
   723                                  
   724 00000220 10                      	db 10h                       ; BIOS - Video display services
   725                                  	extern BIOS_call_10h
   726 00000221 [0000]                  	dw BIOS_call_10h
   727                                  
   728 00000223 11                      	db 11h                       ; BIOS - Return equipment list
   729 00000224 [D603]                  	dw BIOS_call_11h             ; in memory.asm
   730                                  
   731 00000226 12                      	db 12h                       ; BIOS - Return conventional memory size
   732 00000227 [E003]                  	dw BIOS_call_12h             ; (shared with Timer 1)
   733                                  	;;; dw timer1_interrupt ; non INT 12h passed to timer1
   734                                  
   735 00000229 13                      	db 13h                       ; BIOS - Disk services
   736                                  	%if PPIDE_driver
   737                                  	extern FIXED_BIOS_call_13h
   738 0000022A [0000]                  	dw FIXED_BIOS_call_13h       ; (shared with Timer 2, prescaler, NOT USED)
   739                                  
   740 0000022C 40                      	db 40h                       ; Floppy Driver
   741                                  	%endif
   742                                  	extern BIOS_call_13h
   743 0000022D [0000]                  	dw BIOS_call_13h
   744                                  
   745 0000022F 14                      	db 14h                       ; BIOS - Serial port communication
   746                                  	extern BIOS_call_14h
   747 00000230 [0000]                  	dw BIOS_call_14h
   748                                  
   749 00000232 15                      	db 15h                       ; BIOS - Miscellaneous system services support routines
   750                                  	extern BIOS_call_15h
   751 00000233 [0000]                  	dw BIOS_call_15h
   752                                  
   753 00000235 16                      	db 16h                       ; BIOS - Keyboard services
   754                                  	extern BIOS_call_16h
   755 00000236 [0000]                  	dw BIOS_call_16h
   756                                  
   757 00000238 17                      	db 17h
   758                                  	extern BIOS_call_17h
   759 00000239 [0000]                  	dw BIOS_call_17h             ; BIOS - Print services
   760                                  
   761                                  	%if TBASIC==0
   762                                  	db 18h                       ; BIOS - Start ROM Basic
   763                                  	dw BIOS_call_18h
   764                                  	%endif
   765                                  
   766 0000023B 19                      	db 19h                       ; BIOS - Boot the OS
   767 0000023C [4901]                  	dw BIOS_call_19h
   768                                  
   769 0000023E 1A                      	db 1Ah                       ; BIOS - RTC (real time clock) services
   770                                  	extern BIOS_call_1Ah
   771 0000023F [0000]                  	dw BIOS_call_1Ah
   772                                  
   773 00000241 1C                      	db 1Ch
   774                                  	extern BIOS_call_1Ch
   775 00000242 [0000]                  	dw BIOS_call_1Ch
   776                                  
   777 00000244 70                      	db 70h                       ; RTC timer tick on IRQ8
   778                                  	extern rtc_interrupt
   779 00000245 [0000]                  	dw rtc_interrupt             ; 1024 Hz timer
   780                                  
   781                                  	num_vectors equ (($ - interrupt_table) / 3)
   782                                  
   783                                  	;========================================================================
   784                                  	; end_of_interrupt - signal end of interrupt to the interrupt controller
   785                                  	;========================================================================
   786                                  end_of_interrupt:
   787 00000247 5250                    	pushm ax, dx
   788 00000249 BA22FF                  	mov dx, PIC_EOI              ; EOI register
   789 0000024C B80080                  	mov ax, EOI_NSPEC            ; non - specific end of interrupt
   790 0000024F EF                      	out dx, ax                   ; signal it
   791 00000250 585A                    	popm ax, dx
   792 00000252 CF                      	iret
   793                                  
   794                                  skip_trap:
   795                                  	%if TRACE
   796                                  	call int_trace
   797                                  	%endif                       ; TRACE
   798 00000253 CF                      	iret                         ; return from interrupt is a null trap
   799                                  
   800                                  
   801                                  	;========================================================================
   802                                  	; Interrupt priority re - assignments
   803                                  	;========================================================================
   804                                  	MASK equ 08h                 ; mask interrupt
   805                                  	LTM equ 10h                  ; Level Trigger Mode
   806                                  interrupt_priority:
   807 00000254 0E                      	db 6 | MASK                  ; Timers - - timer_init clears the mask
   808 00000255 02                      	db 2                         ; DMA0
   809 00000256 0A                      	db 2 | MASK                  ; DMA1
   810 00000257 0C                      	db 4 | MASK                  ; INT0 - - external / INT (keyboard)
   811 00000258 04                      	db 4                         ; INT1 - - UART
   812 00000259 0F                      	db 7 | MASK                  ; INT2
   813 0000025A 1B                      	db 3 | LTM + MASK            ; INT3 - - floppy disk
   814                                  	lth_int_priority equ $ - interrupt_priority
   815                                  
   816                                  set_interrupt_priority:
   817                                  	%if 0
   818                                  	 / * for now * /
   819                                  	mov dx, PIC_TCR
   820                                  	mov si, interrupt_priority
   821                                  	xor ax, ax                   ; zap AH
   822                                  	mov cx, lth_int_priority
   823                                  sip_loop:
   824                                  	cs lodsb                     ; get priority level
   825                                  	out dx, ax
   826                                  	add dx, 2                    ; PIC control regs are even
   827                                  	loop sip_loop
   828                                  	%endif
   829 0000025B C3                      	ret
   830                                  
   831                                  	;========================================================================
   832                                  	; set_traps - setup interrupt table
   833                                  	;========================================================================
   834                                  set_traps:
   835 0000025C 1E                      	push ds
   836                                  
   837 0000025D 8CCA                    	mov dx, cs
   838 0000025F B90001                  	mov cx, 0100h                ; number of interrupt vectors
   839 00000262 B300                    	mov bl, 0                    ; start with int 0
   840 00000264 B8[5302]                	mov ax, skip_trap
   841                                  .set_default_loop:
   842 00000267 E83E00                  	call set_vector
   843 0000026A FEC3                    	inc bl
   844 0000026C E2F9                    	loop .set_default_loop
   845                                  
   846 0000026E 8EDA                    	mov ds, dx                   ; for LODS CS==DX==DS
   847                                  	cnop
   848 00000270 BE[0B02]                	mov si, interrupt_table      ; load address to start
   849 00000273 B91400                  	mov cx, num_vectors
   850                                  	; note DX = CS
   851                                  .set_vectors_loop:
   852 00000276 AC                      	lodsb
   853 00000277 88C3                    	mov bl, al
   854 00000279 AD                      	lodsw
   855 0000027A E82B00                  	call set_vector
   856 0000027D E2F7                    	loop .set_vectors_loop
   857                                  
   858                                  	%if TBASIC
   859 0000027F B318                    	mov bl, 18h                  ; int 18h is Tiny Basic
   860 00000281 31C0                    	xor ax, ax
   861 00000283 BA00F0                  	mov dx, 0F000h               ; absolute segment load @ 00K
   862 00000286 E81F00                  	call set_vector
   863                                  	%endif
   864                                  	%if FPEM
   865 00000289 B307                    	mov bl, 07h                  ; vector 7 is FPU emulator
   866 0000028B 31C0                    	xor ax, ax
   867 0000028D BA80F4                  	mov dx, 0F480h               ; absolute segment load @ 18K
   868 00000290 E81500                  	call set_vector
   869                                  	%endif
   870                                  
   871 00000293 1F                      	popm ds
   872 00000294 C3                      	ret
   873                                  
   874                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   875                                  	; get_vector
   876                                  	; Get an interrupt vector
   877                                  	;
   878                                  	; Enter with vector number in BL
   879                                  	; Exit with vector in DX:AX
   880                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   881                                  	global get_vector
   882                                  get_vector:
   883 00000295 1E53                    	pushm bx, ds                 ; register saves
   884                                  
   885 00000297 31C0                    	xor ax, ax                   ; zero BX
   886 00000299 8ED8                    	mov ds, ax                   ; set DS=0
   887                                  	cnop
   888 0000029B B700                    	mov bh, 0
   889 0000029D C1E302                  	shl bx, 2                    ; index * 4
   890                                  
   891 000002A0 8B07                    	mov ax, [bx]                 ; load the vector
   892 000002A2 8B5702                  	mov dx, [bx + 2]             ;
   893                                  
   894 000002A5 5B1F                    	popm bx, ds                  ; register restores
   895 000002A7 C3                      	ret                          ; result in DX:AX
   896                                  
   897                                  
   898                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   899                                  	; set_vector
   900                                  	; Set an interrupt vector
   901                                  	;
   902                                  	; Enter with vector number in BL
   903                                  	; vector in DX:AX
   904                                  	;
   905                                  	; All registers preserved
   906                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   907                                  	global set_vector
   908                                  set_vector:
   909 000002A8 1E5351                  	pushm cx, bx, ds             ; register saves
   910                                  
   911 000002AB 31C9                    	xor cx, cx
   912 000002AD 8ED9                    	mov ds, cx                   ; set DS=0
   913                                  	cnop
   914 000002AF B700                    	mov bh, 0
   915 000002B1 C1E302                  	shl bx, 2                    ; index * 4
   916                                  
   917 000002B4 8907                    	mov [bx], ax                 ; set offset
   918 000002B6 895702                  	mov [bx + 2], dx             ; set segment
   919                                  
   920 000002B9 595B1F                  	popm cx, bx, ds              ; register restores
   921 000002BC C3                      	ret                          ; return
   922                                  
   923                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   924                                  	; cpu_table_init
   925                                  	;
   926                                  	; call cpu_table_init
   927                                  	; dw <table> ; table in the Code segment
   928                                  	; <return here>
   929                                  	; AX, CX, DX are trashed
   930                                  	;
   931                                  	;
   932                                  	; table:
   933                                  	; db_lo <cpu_register>
   934                                  	; dw <contents>
   935                                  	; ...
   936                                  	; db 0 ; ends table
   937                                  	;
   938                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   939                                  	global cpu_table_init
   940                                  cpu_table_init:
   941                                  	; get the table address
   942 000002BD 89F1                    	mov cx, si                   ; save SI
   943 000002BF 5E                      	pop si                       ; get the return address
   944 000002C0 2EAD                    	cs lodsw                     ; get the table address
   945 000002C2 56                      	push si                      ; save incremented return address
   946 000002C3 51                      	push cx                      ; save former SI
   947                                  
   948 000002C4 89C6                    	mov si, ax                   ; CS:SI is table pointer
   949 000002C6 B6FF                    	mov dh, cpu_relocation>>8
   950                                  .1:
   951 000002C8 2EAC                    	cs lodsb                     ; get low device code
   952 000002CA 84C0                    	test al, al
   953 000002CC 7407                    	jz .9                        ; done with table on zero low device code
   954 000002CE 88C2                    	mov dl, al
   955 000002D0 2EAD                    	cs lodsw                     ; get cpu register data
   956 000002D2 EF                      	out dx, ax                   ; output a full word
   957 000002D3 EBF3                    	jmp .1
   958                                  .9:
   959 000002D5 5E                      	pop si                       ; restore SI
   960 000002D6 C3                      	ret                          ;
   961                                  
   962                                  
   963                                  	%if 1
   964                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   965                                  	; C - callable:
   966                                  	; dword __fastcall divLS(dword dividend, word divisor);
   967                                  	;
   968                                  	; double word divided by word
   969                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   970                                  	global @divLS
   971                                  @divLS:
   972                                  	; DX:AX is dividend
   973                                  	; BX is divisor
   974 000002D7 09D2                    	or dx, dx
   975 000002D9 7505                    	jnz .3
   976 000002DB F7F3                    	div bx
   977 000002DD 31D2                    	xor dx, dx
   978 000002DF C3                      	ret
   979                                  
   980 000002E0 89C1                    .3: mov cx, ax                ; save low dividend in CX
   981 000002E2 89D0                    	mov ax, dx
   982 000002E4 31D2                    	xor dx, dx                   ; 0:DX div BX
   983 000002E6 F7F3                    	div bx
   984 000002E8 91                      	xchg cx, ax                  ; CX is high quotient
   985 000002E9 F7F3                    	div bx
   986 000002EB 89CA                    	mov dx, cx
   987 000002ED C3                      	ret
   988                                  
   989                                  	%ifndef HAS_FASTCALL
   990                                  	global _divLS
   991                                  _divLS: push bp
   992                                  	mov bp, sp
   993                                  	mov ax, ARG(1)
   994                                  	mov dx, ARG(2)
   995                                  	mov bx, ARG(3)
   996                                  	call @divLS
   997                                  	leave
   998                                  	ret
   999                                  
  1000                                  	global _remLS
  1001                                  _remLS: push bp
  1002                                  	mov bp, sp
  1003                                  	mov ax, ARG(1)
  1004                                  	mov dx, ARG(2)
  1005                                  	mov bx, ARG(3)
  1006                                  	call @remLS
  1007                                  	leave
  1008                                  	ret
  1009                                  	%endif
  1010                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1011                                  	; C - callable:
  1012                                  	; word __fastcall remLS(dword dividend, word divisor);
  1013                                  	;
  1014                                  	; remainder of:
  1015                                  	; double word divided by word
  1016                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1017                                  	global @remLS
  1018                                  @remLS:
  1019                                  	; DX:AX is dividend
  1020                                  	; BX is divisor
  1021 000002EE 09D2                    	or dx, dx
  1022 000002F0 740A                    	jz .5
  1023 000002F2 89C1                    	mov cx, ax                   ; save low dividend in CX
  1024 000002F4 89D0                    	mov ax, dx
  1025 000002F6 31D2                    	xor dx, dx                   ; 0:DX div BX
  1026 000002F8 F7F3                    	div bx                       ; discard quotient in AX
  1027 000002FA 89C8                    	mov ax, cx                   ; restore low dividend
  1028 000002FC F7F3                    .5: div bx
  1029 000002FE 89D0                    	mov ax, dx                   ; remainder to AX
  1030 00000300 C3                      	ret
  1031                                  
  1032                                  
  1033                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1034                                  	; C - callable:
  1035                                  	; dword __fastcall mulLS(dword factor1, word factor2);
  1036                                  	;
  1037                                  	; double word multiplied by word
  1038                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1039                                  	global @mulLS
  1040                                  @mulLS:
  1041                                  	; DX:AX is factor1
  1042                                  	; BX is factor2
  1043 00000301 09D2                    	or dx, dx
  1044 00000303 7503                    	jnz .1                       ; dx != 0
  1045 00000305 F7E3                    	mul bx
  1046 00000307 C3                      	ret
  1047 00000308 89C1                    .1: mov cx, ax                ; save low part of factor1 in CX
  1048 0000030A 89D0                    	mov ax, dx
  1049 0000030C F7E3                    	mul bx
  1050 0000030E 91                      	xchg cx, ax                  ; CX is a product of high part of factor1 and factor2
  1051 0000030F F7E3                    	mul bx
  1052 00000311 01CA                    	add dx, cx
  1053 00000313 C3                      	ret
  1054                                  	%endif
  1055                                  
  1056                                  
  1057                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1058                                  	; microsecond
  1059                                  	; Enter with CX = delay time in microseconds
  1060                                  	; Exit with CX = 0
  1061                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1062                                  	global @microsecond
  1063                                  	global microsecond
  1064                                  @microsecond:                 ; C - callable with __fastcall
  1065 00000314 89C1                    	mov cx, ax
  1066                                  microsecond:
  1067 00000316 E303                    	jcxz .9
  1068 00000318 90                      .1: 	nop                       ; 4 clocks
  1069 00000319 E2FD                    	loop .1                      ; 15 clocks loop is 19 clocks (approx.)
  1070 0000031B C3                      .9: ret
  1071                                  
  1072                                  
  1073                                  	%if 0
  1074                                  	;========================================================================
  1075                                  	; wout - nobody calls it, but unasm defines it as an extenal symbol
  1076                                  	; XXX: Need to recompile unasm and kill it
  1077                                  	;========================================================================
  1078                                  	global wout
  1079                                  wout:
  1080                                  	ret
  1081                                  	%endif
  1082                                  
  1083                                  
  1084                                  	%macro binary 1
  1085                                  	mov ah, %1
  1086                                  	shr ax, 4
  1087                                  	shr al, 4
  1088                                  	aad
  1089                                  	mov %1, al
  1090                                  	%endm
  1091                                  
  1092                                  
  1093                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1094                                  	; ticktime - - set the tick count from the CMOS clock
  1095                                  	;
  1096                                  	; Preserves all registers
  1097                                  	;
  1098                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1099                                  	global ticktime
  1100                                  ticktime:
  1101 0000031C 60                      	pushm ALL
  1102                                  
  1103 0000031D B402                    	mov ah, 2                    ; get Time
  1104 0000031F CD1A                    	int 1Ah
  1105                                  
  1106                                  	binary dh
  1085 00000321 88F4                <1>  mov ah, %1
  1086 00000323 C1E804              <1>  shr ax, 4
  1087 00000326 C0E804              <1>  shr al, 4
  1088 00000329 D50A                <1>  aad
  1089 0000032B 88C6                <1>  mov %1, al
  1107                                  	binary cl
  1085 0000032D 88CC                <1>  mov ah, %1
  1086 0000032F C1E804              <1>  shr ax, 4
  1087 00000332 C0E804              <1>  shr al, 4
  1088 00000335 D50A                <1>  aad
  1089 00000337 88C1                <1>  mov %1, al
  1108                                  	binary ch
  1085 00000339 88EC                <1>  mov ah, %1
  1086 0000033B C1E804              <1>  shr ax, 4
  1087 0000033E C0E804              <1>  shr al, 4
  1088 00000341 D50A                <1>  aad
  1089 00000343 88C5                <1>  mov %1, al
  1109                                  	; mov al, ch
  1110 00000345 88E5                    	mov ch, ah                   ; CH = 0
  1111 00000347 B23C                    	mov dl, 60                   ; 60 min / hr, 60 sec / min
  1112 00000349 F6E2                    	mul dl
  1113 0000034B 01C8                    	add ax, cx                   ; AX = hr * 60 + min
  1114 0000034D 88F1                    	mov cl, dh                   ; CX = sec
  1115 0000034F 88EE                    	mov dh, ch                   ; DH = 0
  1116 00000351 F7E2                    	mul dx                       ;
  1117 00000353 01C8                    	add ax, cx
  1118 00000355 83D200                  	adc dx, 0                    ; DX:AX = time in seconds
  1119                                  
  1120 00000358 BBFA00                  	mov bx, 250
  1121 0000035B 89D1                    	mov cx, dx                   ; CX:AX is time in seconds
  1122 0000035D F7E3                    	mul bx
  1123 0000035F 91                      	xchg ax, cx                  ; CX is low result
  1124 00000360 F6E3                    	mul bl
  1125 00000362 01D0                    	add ax, dx                   ; AX:CX is 250 * maxseconds
  1126                                  
  1127 00000364 C1E302                  	shl bx, 2                    ; BX = 1000
  1128 00000367 91                      	xchg ax, cx                  ; CX:AX is 250 * maxseconds
  1129 00000368 F7E3                    	mul bx                       ; DX:AX is partial product
  1130 0000036A 91                      	xchg ax, cx
  1131 0000036B 87D3                    	xchg dx, bx                  ; BX:CX is partial product
  1132 0000036D F7E2                    	mul dx
  1133 0000036F 01D8                    	add ax, bx
  1134 00000371 83D200                  	adc dx, 0                    ; DX:AX:CX is product
  1135                                  
  1136 00000374 BBA335                  	mov bx, 54924 / 4            ; = 13731 (divisor)
  1137 00000377 F7F3                    	div bx
  1138 00000379 91                      	xchg ax, cx                  ; CX is high quotient
  1139 0000037A F7F3                    	div bx                       ; CX:AX is quotient, DX is remainder
  1140                                  	; round the result
  1141 0000037C 29D3                    	sub bx, dx                   ; if DX > BX / 2
  1142 0000037E 39D3                    	cmp bx, dx                   ;
  1143 00000380 7706                    	ja .3
  1144 00000382 83C001                  	add ax, 1
  1145 00000385 83D100                  	adc cx, 0
  1146                                  .3:
  1147 00000388 92                      	xchg ax, dx                  ; CX:DX is tick count to set
  1148 00000389 B401                    	mov ah, 1
  1149 0000038B CD1A                    	int 1Ah                      ; set tick count
  1150                                  
  1151 0000038D 61                      	popm ALL
  1152 0000038E C3                      	ret
  1153                                  
  1154                                  
  1155                                  
  1156                                  
  1157                                  	;========================================================================
  1158                                  
  1159                                  	%include "memory.asm"
  1160                              <1> ;========================================================================
  1161                              <1> ; MEMORY.ASM -- Memory management routines
  1162                              <1> ;========================================================================
  1163                              <1> ;
  1164                              <1> ;   This version is for assembly by  NASM
  1165                              <1> ;
  1166                              <1> ; Copyright (C) 2011   John R. Coffman
  1167                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1168                              <1> ;
  1169                              <1> ; This program is free software: you can redistribute it and/or modify
  1170                              <1> ; it under the terms of the GNU General Public License as published by
  1171                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1172                              <1> ; (at your option) any later version.
  1173                              <1> ;
  1174                              <1> ; This program is distributed in the hope that it will be useful,
  1175                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1176                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1177                              <1> ; GNU General Public License for more details.
  1178                              <1> ;
  1179                              <1> ; You should have received a copy of the GNU General Public License
  1180                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1181                              <1> ;
  1182                              <1> ;========================================================================
  1183                              <1> 
  1184                              <1>         segment         _TEXT
  1185                              <1> 
  1186                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1187                              <1> ;  get_ramsize
  1188                              <1> ;
  1189                              <1> ;       Return the number of 1k blocks of RAM in AX
  1190                              <1> ;
  1191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1192                              <1> get_ramsize:
  1193 0000038F 1E                  <1>         push    ds
  1194 00000390 53                  <1>         push    bx
  1195 00000391 51                  <1>         push    cx
  1196 00000392 31C0                <1>         xor     ax,ax           ; count of 1k intervals
  1197 00000394 89C3                <1>         mov     bx,ax           ; segment address
  1198                              <1> .1:
  1199 00000396 8EDB                <1>         mov     ds,bx           ; set pointer
  1200                              <1>         cnop
  1201 00000398 8B0E0000            <1>         mov     cx,word [0]     ; save contents
  1202 0000039C C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
  1203 000003A2 89DB                <1>         mov     bx,bx
  1204 000003A4 89C0                <1>         mov     ax,ax           ; waste time
  1205 000003A6 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
  1206 000003AC 7524                <1>         jne     .9
  1207 000003AE 890E0000            <1>         mov     word [0],cx     ; restore
  1208 000003B2 8B0EFC03            <1>         mov     cx,word [1020]
  1209 000003B6 C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
  1210 000003BC 89C0                <1>         mov     ax,ax
  1211 000003BE 89DB                <1>         mov     bx,bx
  1212 000003C0 813EFC03325A        <1>         cmp     word [1020],05a32h
  1213 000003C6 750A                <1>         jne     .9
  1214 000003C8 890EFC03            <1>         mov     word [1020],cx  ; restore
  1215                              <1> 
  1216                              <1> ; Memory test succeeded at the address
  1217                              <1> 
  1218 000003CC 40                  <1>         inc     ax              ; count 1k
  1219 000003CD 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
  1220 000003D0 EBC4                <1>         jmp     .1
  1221                              <1> 
  1222                              <1> .9:
  1223 000003D2 59                  <1>         pop     cx
  1224 000003D3 5B                  <1>         pop     bx
  1225 000003D4 1F                  <1>         pop     ds
  1226 000003D5 C3                  <1>         ret
  1227                              <1> 
  1228                              <1> 
  1229                              <1> 
  1230                              <1> 
  1231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1232                              <1> ;  BIOS_call_11h
  1233                              <1> ;
  1234                              <1> ;       Get Equipment Configuration
  1235                              <1> ;
  1236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1237                              <1> BIOS_call_11h:
  1238 000003D6 FB                  <1>         sti
  1239 000003D7 1E                  <1>         push    ds
  1240 000003D8 6A40                <1>         push    bios_data_seg
  1241 000003DA 1F                  <1>         pop     ds
  1242 000003DB A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
  1243 000003DE 1F                  <1>         pop     ds
  1244 000003DF CF                  <1>         iret
  1245                              <1> 
  1246                              <1> 
  1247                              <1> 
  1248                              <1> 
  1249                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1250                              <1> ;  BIOS_call_12h
  1251                              <1> ;
  1252                              <1> ;       Get Conventional Memory Size
  1253                              <1> ;
  1254                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
  1255                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
  1256                              <1> ;       we assume this was a Timer 1 interrupt.
  1257                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1258                              <1> ; stack
  1259                              <1> offset_SI	equ	0
  1260                              <1> offset_DS	equ	offset_SI+2
  1261                              <1> offset_IP       equ     offset_DS+2
  1262                              <1> offset_CS       equ     offset_IP+2
  1263                              <1> offset_FLAGS    equ     offset_CS+2
  1264                              <1> 
  1265                              <1> BIOS_call_12h:
  1266 000003E0 1E                  <1>         push    ds
  1267 000003E1 56                  <1>         push    si
  1268 000003E2 89E6                <1>         mov     si,sp           ; establish stack addressing
  1269 000003E4 36C57404            <1>    ss   lds     si,[offset_IP+si]
  1270                              <1>         cnop
  1271 000003E8 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
  1272 000003ED 5E                  <1>         pop     si
  1273 000003EE 7404                <1>         je      .4
  1274 000003F0 1F                  <1>         popm	ds
  1275                              <1> ; since the segment is already correct...
  1276                              <1> 	extern	timer1_interrupt
  1277 000003F1 E9(0000)            <1> 	jmp	timer1_interrupt
  1278                              <1> 
  1279 000003F4 6A40                <1> .4:     push    bios_data_seg
  1280 000003F6 1F                  <1>         pop     ds
  1281 000003F7 A11300              <1>         mov     ax,[memory_size]
  1282 000003FA 1F                  <1>         pop     ds
  1283 000003FB CF                  <1>         iret
  1284                              <1> 
  1285                              <1> 
  1286                              <1> 
  1287                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1288                              <1> ;  Memory Test
  1289                              <1> ;       Enter with segment to test in AX
  1290                              <1> ;
  1291                              <1> ;       Return: C=1 if error, (DI==loc)
  1292                              <1> ;               C=0 if no error
  1293                              <1> ;
  1294                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
  1295                              <1> ;       DS, BX & SI are preserved
  1296                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1297                              <1> memtest:
  1298 000003FC 5D                  <1>         pop     bp              ; save return address in BP
  1299                              <1> memtest0:                       ; entry to test page 0
  1300 000003FD FC                  <1>         cld                     ; clear the direction flag
  1301 000003FE 8EC0                <1>         mov     es,ax           ; set segment
  1302 00000400 31FF                <1>         xor     di,di
  1303 00000402 B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
  1304 00000405 B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
  1305 00000408 F3AB                <1>         rep stosw               ;
  1306 0000040A B580                <1>         mov     ch,80h          ; 32K count of words
  1307 0000040C F3AF                <1>         repe scasw
  1308 0000040E 754F                <1>         jne     .3
  1309                              <1> 
  1310 00000410 86C4                <1>         xchg    al,ah           ; second pattern
  1311 00000412 B580                <1>         mov     ch,80h          ; 32K count of words
  1312 00000414 F3AB                <1>         rep stosw
  1313 00000416 B580                <1>         mov     ch,80h          ; 32K count of words
  1314 00000418 F3AF                <1>         repe scasw
  1315 0000041A 7543                <1>         jne     .3
  1316                              <1> %if 1
  1317                              <1> seed1   equ     47F8h           ; NOT a random value
  1318                              <1>                                 ; Seed values are chosen to have a relatively
  1319                              <1>                                 ; prime cycle length, and to never produce a zero
  1320                              <1>                                 ; Most random values will produce a zero!!!!
  1321                              <1> 
  1322 0000041C B8F847              <1>         mov     ax,seed1        ; seed value (critical)
  1323                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
  1324 0000041F B580                <1>         mov     ch,80h          ; 32K words
  1325                              <1> .t1:
  1326 00000421 268905              <1>     es  mov     [di],ax         ; store the value
  1327 00000424 F7E0                <1>         mul     ax
  1328 00000426 47                  <1>         inc     di
  1329 00000427 88E0                <1>         mov     al,ah           ; generate the next bit pattern
  1330 00000429 47                  <1>         inc     di
  1331 0000042A 88D4                <1>         mov     ah,dl
  1332                              <1> %if 0
  1333                              <1> .t102:  or      ax,ax           ; trap a bad seed value
  1334                              <1>         jz      .t102
  1335                              <1> %endif
  1336 0000042C E2F3                <1>         loop    .t1             ; fill memory with the pattern
  1337                              <1> 
  1338 0000042E B8F847              <1>         mov     ax,seed1
  1339 00000431 B580                <1>         mov     ch,80h          ; 32K words
  1340                              <1> .t11:
  1341 00000433 263B05              <1>     es  cmp     ax,[di]
  1342 00000436 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
  1343 00000439 7524                <1>         jne     .3
  1344 0000043B F7E0                <1>         mul     ax
  1345 0000043D 88E0                <1>         mov     al,ah
  1346 0000043F 88D4                <1>         mov     ah,dl
  1347 00000441 E2F0                <1>         loop    .t11
  1348                              <1> 
  1349                              <1> %endif
  1350 00000443 B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
  1351 00000446 B580                <1>         mov     ch,80h          ; 32K count of words
  1352 00000448 F3AB                <1>         rep stosw
  1353 0000044A B580                <1>         mov     ch,80h          ; 32K count of words
  1354 0000044C F3AF                <1>         repe scasw
  1355 0000044E 750F                <1>         jne     .3
  1356                              <1> 
  1357 00000450 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
  1358 00000452 B580                <1>         mov     ch,80h          ; 32K count of words
  1359 00000454 F3AB                <1>         rep stosw
  1360 00000456 B580                <1>         mov     ch,80h          ; 32K count of words
  1361 00000458 F3AF                <1>         repe scasw
  1362 0000045A 7503                <1>         jne     .3
  1363                              <1> 
  1364 0000045C F8                  <1>         clc                     ; no error
  1365 0000045D FFE5                <1>         jmp     bp
  1366                              <1> 
  1367                              <1> .3: ; ERROR in scan string
  1368 0000045F 4F                  <1>         dec     di
  1369 00000460 263A25              <1>    es   cmp     ah,[di]
  1370 00000463 7401                <1>         je      .4
  1371 00000465 4F                  <1>         dec     di
  1372                              <1> .4:
  1373 00000466 F9                  <1>         stc
  1374 00000467 FFE5                <1>         jmp     bp
  1375                              <1> 
  1376                              <1> 
  1377                              <1> 
  1378                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1379                              <1> ; POST_memory -- Power On Self Test of Memory
  1380                              <1> ;
  1381                              <1> ;
  1382                              <1> ;  Enter with:
  1383                              <1> ;       AX = memory limit in kilobytes
  1384                              <1> ;	DS = DGROUP
  1385                              <1> ;	SS = bios_data_seg
  1386                              <1> ;
  1387                              <1> ;  Watch out, "memtest" clobbers segment registers
  1388                              <1> ;
  1389                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1390                              <1> POST_memory:
  1391 00000469 0660                <1>         pushm   ALL,es	; ,ds
  1392 0000046B 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
  1393 00000472 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
  1394 00000479 7507                <1>     	jne	.001
  1395 0000047B 1E                  <1> 	push	ds
  1396 0000047C 68[5000]            <1> 	push	msg_mem_bypass
  1397 0000047F E99800              <1> 	jmp	.print
  1398                              <1> .001:
  1399 00000482 C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
  1400 00000485 89C3                <1>         mov     bx,ax                   ; save in BX
  1401                              <1> .1:
  1402 00000487 BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
  1403 0000048A 29D3                <1>         sub     bx,dx
  1404 0000048C 7432                <1>         jz      .8                      ; done if down to zero
  1405 0000048E 39D3                <1>         cmp     bx,dx
  1406 00000490 7302                <1>         jae     .2
  1407 00000492 89D3                <1>         mov     bx,dx
  1408                              <1> .2:
  1409 00000494 53                  <1>         push    bx
  1410                              <1> 
  1411 00000495 53                  <1>         push    bx
  1412 00000496 1E                  <1>         push    ds		;DGROUP
  1413 00000497 68[0000]            <1>         push    msg_mem_test
  1414 0000049A E8(0000)            <1>         call    _cprintf
  1415 0000049D 83C406              <1>         add     sp,6
  1416                              <1> 
  1417 000004A0 5B                  <1>         pop     bx
  1418 000004A1 89D8                <1>         mov     ax,bx                   ; AX is segment tested
  1419 000004A3 E856FF              <1>         call    memtest
  1420                              <1> 
  1421                              <1> %if 0
  1422                              <1> ;  induce an error to see printout
  1423                              <1>         mov     di,3465h
  1424                              <1>         stc
  1425                              <1> %endif
  1426 000004A6 73DF                <1>         jnc     .1
  1427                              <1> ; make an error report
  1428                              <1> 
  1429 000004A8 89FA                <1>         mov     dx,di           ; copy byte address
  1430 000004AA C1EF04              <1>         shr     di,4            ; convert to paragraphs
  1431 000004AD 01DF                <1>         add     di,bx           ; DI is total paragraphs
  1432 000004AF 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
  1433 000004B2 52                  <1>         push    dx
  1434 000004B3 57                  <1>         push    di
  1435 000004B4 1E                  <1>         push    ds		; DGROUP
  1436 000004B5 68[7400]            <1>         push    msg_mem_error
  1437 000004B8 E8(0000)            <1>         call    _cprintf
  1438 000004BB 83C408              <1>         add     sp,8
  1439                              <1> 
  1440 000004BE EBC7                <1>         jmp     .1
  1441                              <1> 
  1442                              <1> .8:
  1443                              <1> %if SOFT_DEBUG==0
  1444                              <1> ; tested down to 1000:0000
  1445                              <1> ; now do the test at loc. 0  (watch out for the stack)
  1446 000004C0 53                  <1>         push    bx                      ; BX is zero
  1447 000004C1 1E                  <1>         push    ds		; DGROUP
  1448 000004C2 68[0000]            <1>         push    msg_mem_test
  1449 000004C5 E8(0000)            <1>         call    _cprintf
  1450 000004C8 83C406              <1>         add     sp,6
  1451                              <1> 
  1452 000004CB 1E9C                <1>         pushm   f,ds
  1453 000004CD FA                  <1>         cli                             ; disable interrupts
  1454                              <1> 
  1455 000004CE 6A00                <1>         push    0
  1456 000004D0 1F                  <1>         pop     ds                      ; source is 0000:xxxx
  1457 000004D1 680010              <1>         push    1000h
  1458 000004D4 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
  1459 000004D5 31F6                <1>         xor     si,si
  1460 000004D7 31FF                <1>         xor     di,di
  1461 000004D9 B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1462 000004DC F3A5                <1>         rep movsw
  1463                              <1> 
  1464 000004DE 31C0                <1>         xor     ax,ax
  1465 000004E0 BD[E604]            <1>         mov     bp,.85
  1466 000004E3 E917FF              <1>         jmp     memtest0
  1467                              <1> .85:
  1468                              <1> %if 0
  1469                              <1>         stc
  1470                              <1>         mov     di,8765h                ; force error reporting
  1471                              <1> %endif
  1472 000004E6 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
  1473 000004E8 89FB                <1>         mov     bx,di                   ; save error location
  1474                              <1> 
  1475 000004EA 680010              <1>         push    1000h                   ; source is 1000:xxxx
  1476 000004ED 1F                  <1>         pop     ds
  1477 000004EE 6A00                <1>         push    0
  1478 000004F0 07                  <1>         pop     es                      ; restore 0000:xxxx
  1479 000004F1 31F6                <1>         xor     si,si
  1480 000004F3 31FF                <1>         xor     di,di
  1481 000004F5 B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1482 000004F8 F3A5                <1>         rep movsw
  1483                              <1> 
  1484 000004FA 1E                  <1>         push    ds
  1485 000004FB 07                  <1>         pop     es
  1486 000004FC 31C0                <1>         xor     ax,ax
  1487 000004FE B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
  1488 00000500 F3AB                <1>         rep stosw
  1489                              <1> 
  1490 00000502 9D1F                <1>         popm    f,ds
  1491                              <1> %endif
  1492 00000504 D1EA                <1>         shr     dx,1                    ; set the carry
  1493 00000506 730E                <1>         jnc     .89
  1494                              <1> 
  1495                              <1> ; make the page 0 error report
  1496 00000508 53                  <1>         push    bx
  1497 00000509 1E                  <1>         push    ds			; DGROUP
  1498 0000050A 68[9200]            <1>         push    msg_mem_error0
  1499 0000050D E8(0000)            <1>         call    _cprintf
  1500 00000510 83C406              <1>         add     sp,6
  1501                              <1> 
  1502 00000513 F4                  <1> .88:    hlt
  1503 00000514 EBFD                <1>         jmp     .88
  1504                              <1> 
  1505                              <1> .89:
  1506 00000516 1E                  <1>         push    ds			; DGROUP
  1507 00000517 68[2000]            <1>         push    msg_mem_done
  1508                              <1> .print:
  1509 0000051A E8(0000)            <1>         call    _cprintf
  1510 0000051D 83C404              <1>         add     sp,4
  1511                              <1> .9:
  1512 00000520 6107                <1>         popm    ALL,es ; ,ds
  1513 00000522 C3                  <1>         ret
  1514                              <1> 
  1515                              <1> 
  1516                              <1>         segment CONST
  1517                              <1> msg_mem_test:
  1518 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
  1518 00000009 6E67206D656D6F7279- <1>
  1518 00000012 206174202537612530- <1>
  1518 0000001B 34783A3000          <1>
  1519                              <1> msg_mem_done:
  1520 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
  1520 00000029 2E542E206F66206D65- <1>
  1520 00000032 6D6F72792025313061- <1>
  1520 0000003B 535543434553534655- <1>
  1520 00000044 4C2020202020202020  <1>
  1521                              <1> msg_mem_double:
  1522 0000004D 0A0A00              <1>         db      NL,NL,NUL
  1523                              <1> msg_mem_bypass:
  1524 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
  1524 00000059 2E542E206F66206D65- <1>
  1524 00000062 6D6F72792042595041- <1>
  1524 0000006B 5353454420200A0A00  <1>
  1525                              <1> msg_mem_error:
  1526 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
  1526 0000007D 6F7279206572726F72- <1>
  1526 00000086 206174202530347825- <1>
  1526 0000008F 780A00              <1>
  1527                              <1> msg_mem_error0:
  1528 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
  1528 0000009B 6F7279206572726F72- <1>
  1528 000000A4 206174203025303478- <1>
  1528 000000AD 0A0A                <1>
  1529 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
  1529 000000B8 2A2A2A2A2A2A2A2A2A- <1>
  1529 000000C1 2A2A2A2A2A2A2A2A0A  <1>
  1530 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
  1530 000000D3 415354524F50484521- <1>
  1530 000000DC 212120202020202A0A  <1>
  1531 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
  1531 000000EE 2A2A2A2A2A2A2A2A2A- <1>
  1531 000000F7 2A2A2A2A2A2A2A2A0A- <1>
  1531 00000100 0A                  <1>
  1532 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
  1532 0000010A 756520746F20657272- <1>
  1532 00000113 6F7220696E20736567- <1>
  1532 0000011C 6D656E742030303030- <1>
  1532 00000125 3A78787878070A      <1>
  1533 0000012C 00                  <1>         db      NUL
  1534 0000012D 00                  <1> 	db	0
  1160                                  	%include "ds1302.asm"
  1161                              <1> 	;========================================================================
  1162                              <1> 	; DS1302.ASM - - support on the SBC - 188 for the DS1302 chip
  1163                              <1> 	;========================================================================
  1164                              <1> 	;
  1165                              <1> 	; This version is for assembly by NASM 2.08
  1166                              <1> 	;
  1167                              <1> 	; Copyright (C) 2010 John R. Coffman
  1168                              <1> 	; Provided for hobbyist use on the N8VEM SBC - 188 board
  1169                              <1> 	;
  1170                              <1> 	; This program is free software: you can redistribute it and / or modify
  1171                              <1> 	; it under the terms of the GNU General Public License as published by
  1172                              <1> 	; the Free Software Foundation, either version 3 of the License, or
  1173                              <1> 	; (at your option) any later version.
  1174                              <1> 	;
  1175                              <1> 	; This program is distributed in the hope that it will be useful,
  1176                              <1> 	; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1177                              <1> 	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  1178                              <1> 	; GNU General Public License for more details.
  1179                              <1> 	;
  1180                              <1> 	; You should have received a copy of the GNU General Public License
  1181                              <1> 	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
  1182                              <1> 	;
  1183                              <1> 	; Updated for the Duodyne 80c188 SBC
  1184                              <1> 	;========================================================================
  1185                              <1> 
  1186                              <1> 	segment _TEXT
  1187                              <1> 
  1188                              <1> 	rtc_data equ 80H             ; Data mask bit
  1189                              <1> 	rtc_wren equ 20H             ; Write enable bit
  1190                              <1> 	rtc_clk equ 40H              ; Clock signal
  1191                              <1> 	rtc_ce equ 10H               ; ce bit
  1192                              <1> 
  1193                              <1> 
  1194                              <1> 	; global _rtc_reset
  1195                              <1> rtc_reset:
  1196 00000523 BA9404              <1> 	mov dx, RTC                  ; set the device code
  1197 00000526 B010                <1> 	mov al, rtc_ce               ;
  1198 00000528 EB05                <1> 	jmp rtc_out
  1199                              <1> 
  1200                              <1> 
  1201                              <1> 	global _rtc_reset_off
  1202                              <1> rtc_reset_off:
  1203 0000052A BA9404              <1> 	mov dx, RTC
  1204 0000052D B000                <1> 	mov al, 0                    ;
  1205                              <1> rtc_out:
  1206 0000052F EE                  <1> 	out dx, al
  1207 00000530 B91000              <1> 	mov cx, 16
  1208 00000533 E9E0FD              <1> 	jmp microsecond              ; delay 16 us
  1209                              <1> 
  1210                              <1> rtc_outs:
  1211 00000536 EE                  <1> 	out dx, al
  1212 00000537 B90100              <1> 	mov cx, 1
  1213 0000053A E9D9FD              <1> 	jmp microsecond              ; delay 16 us
  1214                              <1> 
  1215                              <1> 	; global @rtc_write
  1216                              <1> @rtc_write:
  1217                              <1> rtc_write:
  1218 0000053D 53                  <1> 	push bx
  1219                              <1> 
  1220 0000053E BA9404              <1> 	mov dx, RTC
  1221 00000541 88C3                <1> 	mov bl, al                   ; save data in BL
  1222 00000543 B408                <1> 	mov ah, 8                    ; set loop count
  1223                              <1> .1:
  1224 00000545 D0EB                <1> 	shr bl, 1                    ; data bit to Carry
  1225 00000547 7311                <1> 	jnc .2
  1226 00000549 B090                <1> 	mov al,  rtc_ce | rtc_data   ; send '1'
  1227 0000054B E8E8FF              <1> 	call rtc_outs                ; put out the data
  1228 0000054E B0D0                <1> 	mov al, rtc_clk | rtc_ce | rtc_data     ; send '1'
  1229 00000550 E8DCFF              <1> 	call rtc_out                 ; put out the data
  1230 00000553 B090                <1>        	mov al, rtc_ce | rtc_data     ; send '1'
  1231 00000555 E8D7FF              <1> 	call rtc_out                 ; put out the data
  1232                              <1> 
  1233 00000558 EB0F                <1> 	jmp .3
  1234                              <1> .2:
  1235 0000055A B010                <1> 	mov al, rtc_ce               ; send '0'
  1236 0000055C E8D7FF              <1> 	call rtc_outs                ; put out the data
  1237 0000055F B050                <1> 	mov al, rtc_clk |rtc_ce      ; send '0'
  1238 00000561 E8CBFF              <1> 	call rtc_out                 ; put out the data
  1239 00000564 B010                <1>       	mov al, rtc_ce               ; send '0'
  1240 00000566 E8C6FF              <1> 	call rtc_out                 ; put out the data
  1241                              <1> 
  1242                              <1> .3:
  1243 00000569 FECC                <1> 	dec ah                       ; count a bit
  1244 0000056B 75D8                <1> 	jnz .1
  1245                              <1> 
  1246                              <1> 	; rtc_write ends with the clock high
  1247 0000056D 5B                  <1> 	pop bx
  1248 0000056E C3                  <1> 	ret
  1249                              <1> 
  1250                              <1> 
  1251                              <1> 
  1252                              <1> 
  1253                              <1> rtc_read:
  1254 0000056F 53                  <1> 	push bx
  1255                              <1> 
  1256 00000570 BA9404              <1> 	mov dx, RTC
  1257 00000573 B308                <1> 	mov bl, 8                    ; bit count
  1258                              <1> .1:
  1259 00000575 B030                <1> 	mov al, rtc_ce | rtc_wren
  1260 00000577 E8B5FF              <1> 	call rtc_out
  1261                              <1> 	; delay was included in the above output call
  1262 0000057A EC                  <1> 	in al, dx                    ; read a bit
  1263 0000057B D1C8                <1> 	ror ax, 1                    ; rotate data into AH
  1264 0000057D B070                <1> 	mov al, rtc_clk | rtc_ce | rtc_wren     ; set to clock next data bit
  1265 0000057F E8ADFF              <1> 	call rtc_out
  1266 00000582 FECB                <1> 	dec bl
  1267 00000584 75EF                <1> 	jnz .1
  1268                              <1> 
  1269 00000586 C1E808              <1> 	shr ax, 8                    ; return data in AL, AH=0
  1270                              <1> 
  1271 00000589 5B                  <1> 	pop bx
  1272 0000058A C3                  <1> 	ret
  1273                              <1> 
  1274                              <1> 
  1275                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1276                              <1> 	; rtc_get_loc RTC get location as addressed
  1277                              <1> 	; Enter with AL = address of the location to get
  1278                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1279                              <1> 	; Exit with data in AL
  1280                              <1> 	; All other registers are preserved
  1281                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1282                              <1> 	global @rtc_get_loc
  1283                              <1> 	global rtc_get_loc
  1284                              <1> @rtc_get_loc:
  1285                              <1> rtc_get_loc:
  1286 0000058B 52                  <1> 	push dx
  1287 0000058C 51                  <1> 	push cx                      ; 3 register saves
  1288 0000058D 53                  <1> 	push bx
  1289                              <1> 
  1290 0000058E 08E4                <1> 	or ah, ah                    ; test flag
  1291 00000590 7402                <1> 	jz .1
  1292 00000592 B440                <1> 	mov ah, 040h                 ; RAM flag
  1293 00000594 88E7                <1> .1:     mov bh, ah                   ; save flag in BH
  1294 00000596 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1295 00000598 00C0                <1> 	add al, al                   ; shift left
  1296 0000059A 08C7                <1> 	or bh, al                    ; form command
  1297 0000059C 80CF81              <1> 	or bh, 81h                   ; Clock Command / READ bit = 01h
  1298                              <1> 
  1299 0000059F BA9404              <1> 	mov dx, RTC
  1300 000005A2 E885FF              <1> 	call rtc_reset_off
  1301 000005A5 E87BFF              <1> 	call rtc_reset               ; signal that a command is coming
  1302 000005A8 88F8                <1> 	mov al, bh
  1303 000005AA E890FF              <1> 	call rtc_write               ; write out the command
  1304 000005AD E8BFFF              <1> 	call rtc_read                ; read the data location
  1305 000005B0 50                  <1> 	push ax                      ; save the result
  1306 000005B1 E86FFF              <1> 	call rtc_reset
  1307 000005B4 E873FF              <1> 	call rtc_reset_off           ; and finish up
  1308                              <1> 
  1309 000005B7 58                  <1> 	pop ax                       ; return value
  1310                              <1> 
  1311 000005B8 5B                  <1> 	pop bx
  1312 000005B9 59                  <1> 	pop cx                       ; plus 3 register restores
  1313 000005BA 5A                  <1> 	pop dx
  1314 000005BB C3                  <1> 	ret
  1315                              <1> 
  1316                              <1> 
  1317                              <1> 
  1318                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1319                              <1> 	; rtc_set_loc RTC set location as addressed
  1320                              <1> 	; Enter with AL = address of the location to set
  1321                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1322                              <1> 	; DL = data to write to location
  1323                              <1> 	; AX is undefined on return
  1324                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1325                              <1> 	global @rtc_set_loc
  1326                              <1> 	global rtc_set_loc
  1327                              <1> @rtc_set_loc:
  1328                              <1> rtc_set_loc:
  1329 000005BC 52                  <1> 	push dx
  1330 000005BD 51                  <1> 	push cx                      ; 3 register saves
  1331 000005BE 53                  <1> 	push bx
  1332                              <1> 
  1333 000005BF 52                  <1> 	push dx                      ; save data
  1334                              <1> 
  1335 000005C0 08E4                <1> 	or ah, ah                    ; test flag
  1336 000005C2 7402                <1> 	jz .1
  1337 000005C4 B440                <1> 	mov ah, 040h                 ; RAM flag
  1338 000005C6 88E7                <1> .1: mov bh, ah                ; save flag in BH
  1339 000005C8 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1340 000005CA 00C0                <1> 	add al, al                   ; shift left
  1341 000005CC 08C7                <1> 	or bh, al                    ; form command
  1342 000005CE 80CF80              <1> 	or bh, 80h                   ; Clock Command / WRITE bit = 00h
  1343                              <1> 
  1344 000005D1 BA9404              <1> 	mov dx, RTC
  1345 000005D4 E853FF              <1> 	call rtc_reset_off
  1346 000005D7 E849FF              <1> 	call rtc_reset               ; signal that a command is coming
  1347 000005DA 88F8                <1> 	mov al, bh                   ; command to AL
  1348 000005DC E85EFF              <1> 	call rtc_write               ; write out the command
  1349 000005DF 58                  <1> 	pop ax                       ; get the data value
  1350 000005E0 E85AFF              <1> 	call rtc_write               ; write the data
  1351 000005E3 E83DFF              <1> 	call rtc_reset               ; end of command
  1352 000005E6 E841FF              <1> 	call rtc_reset_off
  1353                              <1> 
  1354 000005E9 5B                  <1> 	pop bx
  1355 000005EA 59                  <1> 	pop cx                       ; plus 3 register restores
  1356 000005EB 5A                  <1> 	pop dx
  1357 000005EC C3                  <1> 	ret
  1161                                  
  1162                                  	%if SOFT_DEBUG + 1
  1163                                  	global lites
  1164                                  	; call with:
  1165                                  	; push code ; code in AL
  1166                                  	; call lites
  1167                                  	;
  1168 000005ED 55                      lites: push bp
  1169 000005EE 89E5                    	mov bp, sp                   ; establish stack frame
  1170 000005F0 5250                    	pushm ax, dx
  1171 000005F2 8A4604                  	mov al, [bp + 4]
  1172 000005F5 BA3006                  	mov dx, FRONT_PANEL_LED
  1173 000005F8 EE                      	out dx, al
  1174 000005F9 585A                    	popm ax, dx
  1175 000005FB 5D                      	pop bp
  1176 000005FC C20200                  	ret 2                        ; remove argument
  1177                                  	%endif
  1178                                  
  1179                                  	%if 0
  1180                                  	; _FPSIGNAL:
  1181                                  	; Enter with AL = condensed error code
  1182                                  	;
  1183                                  	global _FPSIGNAL
  1184                                  _FPSIGNAL:
  1185                                  	xor ah, ah
  1186                                  	push ax
  1187                                  	push DGROUP
  1188                                  	push msg_fpu_err
  1189                                  	call _cprintf
  1190                                  	add sp, 6
  1191                                  	ret
  1192                                  	%endif
  1193                                  
  1194                                  
  1195                                  
  1196                                  
  1197                                  ident3:
  1198                                  	%if SOFT_DEBUG
  1199                                  	db NL
  1200                                  	db "%7a"
  1201                                  	db " * * * * * SOFT BIOS * * * * * "
  1202                                  	db NL
  1203                                  	%endif
  1204                                  	%ifdef __DATE__
  1205                                  	%ifdef __TIME__
  1206 000005FF 0A                      	db NL
  1207 00000600 25313461                	db "%14a"
  1208 00000604 546869732042494F53-     	db "This BIOS copy was built at ", __TIME__, " ", TIMEZONE
  1208 0000060D 20636F707920776173-
  1208 00000616 206275696C74206174-
  1208 0000061F 2032323A32363A3438-
  1208 00000628 20435354           
  1209 0000062C 206F6E20323032342D-     	db " on ", __DATE__
  1209 00000635 31322D3037         
  1210                                  	%endif
  1211                                  	%endif
  1212 0000063A 2E205B25645D0A          	db ". [%d]", NL
  1213 00000641 00                      	db 0
  1214                                  
  1215                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1216                                  	; This is the banner which prints out first.
  1217                                  	; The letters are variable width; B is wide; - , and 1 are kerned.
  1218                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1219                                  ident1:
  1220 00000642 0A253961                     	db      NL,"%9a"
  1221 00000646 20205F5F5F5F5F2020-             db      "  _____                  _ ",	NL
  1221 0000064F 202020202020202020-
  1221 00000658 202020202020205F20-
  1221 00000661 0A                 
  1222 00000662 207C20205F5F205C20-             db      " |  __ \                | |",	NL
  1222 0000066B 202020202020202020-
  1222 00000674 2020202020207C207C-
  1222 0000067D 0A                 
  1223 0000067E 207C207C20207C207C-             db      " | |  | |_   _  ___   __| |_   _ _ __   ___ ",	NL
  1223 00000687 5F2020205F20205F5F-
  1223 00000690 5F2020205F5F7C207C-
  1223 00000699 5F2020205F205F205F-
  1223 000006A2 5F2020205F5F5F200A 
  1224 000006AB 207C207C20207C207C-             db      " | |  | | | | |/ _ \ / _` | | | | '_ \ / _ \ ",	NL
  1224 000006B4 207C207C207C2F205F-
  1224 000006BD 205C202F205F60207C-
  1224 000006C6 207C207C207C20275F-
  1224 000006CF 205C202F205F205C20-
  1224 000006D8 0A                 
  1225 000006D9 207C207C5F5F7C207C-             db      " | |__| | |_| | (_) | (_| | |_| | | | |  __/",	NL
  1225 000006E2 207C5F7C207C20285F-
  1225 000006EB 29207C20285F7C207C-
  1225 000006F4 207C5F7C207C207C20-
  1225 000006FD 7C207C20205F5F2F0A 
  1226 00000706 207C5F5F5F5F5F2F20-             db      " |_____/ \__,_|\___/ \__,_|\__, |_| |_|\___|",	NL
  1226 0000070F 5C5F5F2C5F7C5C5F5F-
  1226 00000718 5F2F205C5F5F2C5F7C-
  1226 00000721 5C5F5F2C207C5F7C20-
  1226 0000072A 7C5F7C5C5F5F5F7C0A 
  1227 00000733 202020203830633138-             db      "    80c188 pcb              __/ |  rev. ", VERSION, NL
  1227 0000073C 382070636220202020-
  1227 00000745 202020202020202020-
  1227 0000074E 205F5F2F207C202072-
  1227 00000757 65762E20332E352D44-
  1227 00000760 0A                 
  1228 00000761 202020202020202020-             db      "                           |___/   of   ", DATE, NL
  1228 0000076A 202020202020202020-
  1228 00000773 202020202020202020-
  1228 0000077C 7C5F5F5F2F2020206F-
  1228 00000785 6620202032372D4F63-
  1228 0000078E 742D323032340A     
  1229 00000795 202020202020202020-             db      "                                   ("
  1229 0000079E 202020202020202020-
  1229 000007A7 202020202020202020-
  1229 000007B0 202020202020202028 
  1230                                  	%if ANSI
  1231 000007B9 414E5349                	db "ANSI"
  1232                                  	%elif DUMB
  1233                                  	db "dumb"
  1234                                  	%elif TTY
  1235                                  	db "tty"
  1236                                  	%else
  1237                                  	db "???"
  1238                                  	%endif
  1239 000007BD 290A                    	db ")", NL
  1240                                  
  1241 000007BF 00                      	db 0
  1242                                  
  1243                                  
  1244                                  	align 16
  1245                                  
  1246                                  	bulk_of_code_end equ $
  1247                                  
  1248                                  
  1249                                  
  1250                                  	segment CONST
  1251                                  
  1252                                  	global _bios_data_area_ptr
  1253                                  _bios_data_area_ptr:
  1254 0000012E 00004000                	dw 0000h, bios_data_seg      ; pointer 40:0
  1255                                  
  1256                                  
  1257                                  msg_cpu_memory:
  1258 00000132 253135612564257320-     	db "%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1258 0000013B 2532614D687A204350-
  1258 00000144 5520636C6F636B2C20-
  1258 0000014D 253135612575253261-
  1258 00000156 4B206D656D6F727920-
  1258 0000015F 696E7374616C6C6564 
  1259 00000168 0A00                    	db NL, 0
  1260                                  msg_cpu_clock_05:
  1261 0000016A 2E3500                  	db ".5", 0
  1262                                  msg_cpu_clock_00:
  1263 0000016D 00                      	db 0
  1264                                  msg_setup:
  1265 0000016E 507265737320277327-     	db "Press 's' or set front panel switches to FF to run NVRAM setup...", NL, 0
  1265 00000177 206F72207365742066-
  1265 00000180 726F6E742070616E65-
  1265 00000189 6C2073776974636865-
  1265 00000192 7320746F2046462074-
  1265 0000019B 6F2072756E204E5652-
  1265 000001A4 414D2073657475702E-
  1265 000001AD 2E2E0A00           
  1266                                  msg_nvram_bad:
  1267 000001B1 4E5652414D20636865-     	db "NVRAM checksum is invalid, running setup", NL, 0
  1267 000001BA 636B73756D20697320-
  1267 000001C3 696E76616C69642C20-
  1267 000001CC 72756E6E696E672073-
  1267 000001D5 657475700A00       
  1268                                  msg_floppy:
  1269 000001DB 4E6F7720696E697469-     	db "Now initializing floppy", NL, 0
  1269 000001E4 616C697A696E672066-
  1269 000001ED 6C6F7070790A00     
  1270                                  	%if 0
  1271                                  msg_fpu_err:
  1272                                  	db NL, "EM187 has signalled error 0x%02x.", NL, 0
  1273                                  	%endif
  1274                                  msg_booting:
  1275 000001F4 547279696E6720746F-     db "Trying to boot from drive %c: ", 0
  1275 000001FD 20626F6F742066726F-
  1275 00000206 6D2064726976652025-
  1275 0000020F 633A2000           
  1276                                  msg_boot_err:
  1277 00000213 4469736B2072656164-     	db "Disk read failed AX=%04x", NL, 0
  1277 0000021C 206661696C65642041-
  1277 00000225 583D253034780A00   
  1278                                  msg_no_boot:
  1279 0000022D 426F6F74207369676E-     	db "Boot signature not found", NL, 0
  1279 00000236 6174757265206E6F74-
  1279 0000023F 20666F756E640A00   
  1280                                  msg_no_loader:
  1281 00000247 4D617374657220626F-     	db "Master boot loader not found", NL, 0
  1281 00000250 6F74206C6F61646572-
  1281 00000259 206E6F7420666F756E-
  1281 00000262 640A00             
  1282                                  msg_boot_ok:
  1283 00000265 4F4B0A00                	db "OK", NL, 0
  1284                                  msg_cpm_disk:
  1285 00000269 6E6F207369676E6174-     	db "no signature check ", 0
  1285 00000272 75726520636865636B-
  1285 0000027B 2000               
  1286                                  msg_alt_disk:
  1287 0000027D 4D494E495820626F6F-     	db "MINIX boot signature ", 0
  1287 00000286 74207369676E617475-
  1287 0000028F 72652000           
  1288                                  
  1289                                  
  1290                                  
  1291                                  	%if TBASIC
  1292                                  	%else
  1293                                  msg_no_basic:
  1294                                  db "No ROM Basic. Please implement one : - )", NL
  1295                                  	db "Press any key to try again...", NL, 0
  1296                                  	%endif
  1297                                  
  1298                                  
  1299                                  	%if SOFT_DEBUG
  1300                                  	global cout, bout, wout, boutsp, crlf
  1301                                  	; NewLine
  1302                                  crlf:
  1303                                  	mov al, 0Dh
  1304                                  	call cout
  1305                                  	mov al, 0Ah
  1306                                  	call cout
  1307                                  	ret
  1308                                  
  1309                                  
  1310                                  	; output byte from AL, then a space
  1311                                  boutsp:
  1312                                  	call bout
  1313                                  	mov al, 20h
  1314                                  	call cout
  1315                                  	ret
  1316                                  	; word output from AX
  1317                                  wout:
  1318                                  	xchg al, ah
  1319                                  	call bout
  1320                                  	xchg al, ah
  1321                                  	; byte output from AL
  1322                                  bout:
  1323                                  	rol al, 4
  1324                                  	call nout
  1325                                  	rol al, 4
  1326                                  	; nibble output from low nibble in AL
  1327                                  nout:
  1328                                  	push ax
  1329                                  	and al, 0Fh                  ; mask nibble
  1330                                  	daa                          ; convert to decimal
  1331                                  	add al, 0F0h                 ; overflow to Carry
  1332                                  	adc al, 040h                 ; convert to ASCII decimal or hex digit
  1333                                  	call cout
  1334                                  	pop ax
  1335                                  	ret
  1336                                  
  1337                                  	; character output from AL
  1338                                  cout:
  1339                                  	%if 0
  1340                                  	pushm ax, bx
  1341                                  	mov ah, 0Eh                  ; write character in AL
  1342                                  	mov bx, 0007h
  1343                                  	int 10h
  1344                                  	popm ax, bx
  1345                                  	%else
  1346                                  	THRE EQU 1<<5                ; Transmit holding register empty
  1347                                  	pushm ax, dx
  1348                                  .1: mov dx, uart_lsr
  1349                                  	in al, dx
  1350                                  	test al, THRE
  1351                                  	jz .1
  1352                                  	mov dx, uart_thr
  1353                                  	popm ax
  1354                                  	out dx, al
  1355                                  	popm dx
  1356                                  	%endif
  1357                                  	ret
  1358                                  	%endif
