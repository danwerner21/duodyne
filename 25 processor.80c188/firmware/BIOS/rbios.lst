     1                                  %ifndef SOFT_DEBUG
     2                                  ;;%define SOFT_DEBUG 1
     3                                  %endif
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ; RBIOS.ASM -- Relocatable BIOS for the RetroBrew SBC-188 v.0.4 to 3.1
     6                                  ; Updated for the Duodyne 80c188 SBC 10/2024
     7                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     8                                  ;
     9                                  ;   This version is for assembly by  NASM 0.98.39 or later
    10                                  ;
    11                                  ; Copyright (C) 2011-2017 John R. Coffman.  All rights reserved.
    12                                  ; Provided for hobbyist use on the RetroBrew SBC-188 board.
    13                                  ;
    14                                  ; This program is free software: you can redistribute it and/or modify
    15                                  ; it under the terms of the GNU General Public License as published by
    16                                  ; the Free Software Foundation, either version 3 of the License, or
    17                                  ; (at your option) any later version.
    18                                  ;
    19                                  ; This program is distributed in the hope that it will be useful,
    20                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    21                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    22                                  ; GNU General Public License for more details.
    23                                  ;
    24                                  ; You should have received a copy of the GNU General Public License
    25                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    26                                  ;
    27                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                                  
    29                                  	cpu	186
    30                                  
    31                                  
    32                                  
    33                                  
    34                                  %include	"config.asm"
    35                              <1> ;/*
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; ANSI.CFG
    38                              <1> ;   Copied to CONFIG.ASM for general release.
    39                              <1> ;
    40                              <1> ;       Modify the parameters below to reflect your system
    41                              <1> ;
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    46                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    48                              <1> ;
    49                              <1> ; Define the serial terminal that the Video BIOS must emulate
    50                              <1> ; Set one of the following to 1
    51                              <1> ; If you have no idea what to choose, set TTY to 1
    52                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    53                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    54                              <1> ANSI    equ     1       ; very smart, like a VT-100
    55                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    56                              <1> ; others may get added in the future
    57                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    58                              <1> ;
    59                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    60                              <1> ;UART_RATE	equ	0		; 1200
    61                              <1> ;UART_RATE	equ	1		; 2400
    62                              <1> ;UART_RATE	equ	2		; 4800
    63                              <1> UART_RATE	equ	3		; 9600
    64                              <1> ;UART_RATE	equ	4		; 19200
    65                              <1> ;UART_RATE	equ	5		; 38400
    66                              <1> ;UART_RATE	equ	6		; 57600
    67                              <1> ;UART_RATE	equ	7		; 115200
    68                              <1> 
    69                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    70                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    71                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    72                              <1> 						; but not ANSI
    73                              <1> ; Define the size of the ROM image on the system in Kilobytes
    74                              <1> ; It may be smaller than the actual EPROM in use.
    75                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    76                              <1> %ifndef ROM
    77                              <1> ROM             equ     32              ; 64 is the default
    78                              <1> %endif
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the ROM operates
    81                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    82                              <1> 
    83                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    84                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    85                              <1> RAM_DOS         equ     640
    86                              <1> 
    87                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    88                              <1> ; the default is 512 kilobytes
    89                              <1> RAM             equ     512             ; (512 is the default)
    90                              <1> 
    91                              <1> ; Define the number of Wait States at which the RAM operates
    92                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    93                              <1> 
    94                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    95                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    96                              <1> 
    97                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    98                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    99                              <1> 
   100                              <1> ; Define the time zone in which we build the Relocatable BIOS
   101                              <1> %ifndef TIMEZONE
   102                              <1> %define TIMEZONE "CST"
   103                              <1> %endif
   104                              <1> 
   105                              <1> ; Has the REDBUG debugger been loaded?
   106                              <1> %ifndef SOFT_DEBUG
   107                              <1> %define SOFT_DEBUG 0
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   111                              <1> %ifndef TBASIC
   112                              <1> TBASIC          equ     1		; default is 1
   113                              <1> %endif
   114                              <1> 
   115                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   116                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   117                              <1> %ifndef FPEM
   118                              <1> FPEM            equ     1               ; default is 1
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   122                              <1> ; or at locations 0280h..3FFh in low memory?
   123                              <1> %if SOFT_DEBUG
   124                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   125                              <1> %else
   126                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Define the size of the EPROM that is to be installed on the system
   130                              <1> ; It may be larger than the actual ROM image to be generated.
   131                              <1> %ifndef CHIP
   132                              <1> CHIP            equ     64
   133                              <1> %endif
   134                              <1> 
   135                              <1> ; Define the UART oscillator speed
   136                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   137                              <1> 
   138                              <1> 
   139                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   140                              <1> ; end of the User configuration
   141                              <1> ;       Do Not modify anything below this point
   142                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   143                              <1> 
   144                              <1> ; Define existence of any uart chip
   145                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   146                              <1> startuplength   equ     512                     ; may be up to 1024
   147                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   148                              <1> highrom         equ     (ROM*400h)&0FFFFh
   149                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   150                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   151                              <1> 
   152                              <1> 
   153                              <1> %define ARG(n) [bp+2+(n)*2]
   154                              <1> 
   155                              <1> %macro  check   1.nolist
   156                              <1>  %if (%1)
   157                              <1>    %error Check Failure: %1
   158                              <1>  %endif
   159                              <1> %endm
   160                              <1> %macro  range   3.nolist
   161                              <1>  %if (%1)<(%2)
   162                              <1>    %error Out of Range: %1
   163                              <1>  %elif (%1)>(%3)
   164                              <1>    %error Out of Range: %1
   165                              <1>  %endif
   166                              <1> %endm
   167                              <1> _terminal equ UART
   168                              <1>  check   RAM_DOS&15
   169                              <1>  check   RAM&(RAM-1)
   170                              <1>  check   ROM&(ROM-1)
   171                              <1>  range   RAM,32,512
   172                              <1>  range   ROM,32,256
   173                              <1>  range   RAM_WS,0,3
   174                              <1>  range   ROM_WS,0,3
   175                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   176                              <1>  range   LCL_IO_WS,0,3
   177                              <1>  range   BUS_IO_WS,0,3
   178                              <1>  range   UART_OSC,500000,16000000
   179                              <1>  range   UART_RATE,0,7
   180                              <1>  range	 UART,0,1
   181                              <1>  range	 _terminal,1,2
   182                              <1> 
   183                              <1> %ifndef SOFT_DEBUG
   184                              <1> %define SOFT_DEBUG 0
   185                              <1> %endif
   186                              <1> 
   187                              <1> %ifndef TRACE
   188                              <1> %define TRACE 0
   189                              <1> %endif
   190                              <1> 
   191                              <1> %ifdef MAKE_OBJECT_FILE
   192                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   193                              <1>         export _ROMsize
   194                              <1>         export _CHIPsize
   195                              <1> _ROMsize        dw      ROM
   196                              <1> _CHIPsize       dw      CHIP
   197                              <1> %endif
   198                              <1> ; end of the Hardware configuration file
   199                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   200                              <1> ;*/
    35                                  %include	"cpuregs.asm"
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ; CPUREGS.ASM
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    41                              <1> ;
    42                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    43                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    44                              <1> ;
    45                              <1> ; This program is free software: you can redistribute it and/or modify
    46                              <1> ; it under the terms of the GNU General Public License as published by
    47                              <1> ; the Free Software Foundation, either version 3 of the License, or
    48                              <1> ; (at your option) any later version.
    49                              <1> ;
    50                              <1> ; This program is distributed in the hope that it will be useful,
    51                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    52                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    53                              <1> ; GNU General Public License for more details.
    54                              <1> ;
    55                              <1> ; You should have received a copy of the GNU General Public License
    56                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    57                              <1> ;
    58                              <1> ; Updated for the Duodyne 80c188 SBC
    59                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    60                              <1> %include	"macros.inc"
    61                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                              <2> ; MACROS.INC  
    63                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <2> ;
    65                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    66                              <2> ;
    67                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    68                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    69                              <2> ;
    70                              <2> ; This program is free software: you can redistribute it and/or modify
    71                              <2> ; it under the terms of the GNU General Public License as published by
    72                              <2> ; the Free Software Foundation, either version 3 of the License, or
    73                              <2> ; (at your option) any later version.
    74                              <2> ;
    75                              <2> ; This program is distributed in the hope that it will be useful,
    76                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    77                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    78                              <2> ; GNU General Public License for more details.
    79                              <2> ;
    80                              <2> ; You should have received a copy of the GNU General Public License
    81                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    82                              <2> ;
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> 
    85                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    86                              <2> ;
    87                              <2> ;
    88                              <2> %ifndef __MACROS_DEFINED_
    89                              <2> %define __MACROS_DEFINED_ 1
    90                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    91                              <2> ;
    92                              <2> ; some useful macros:
    93                              <2> ;
    94                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    95                              <2> ;
    96                              <2> 	cpu	186
    97                              <2> 
    98                              <2> %imacro setloc  1.nolist
    99                              <2>  times   (%1-($-$$)) db 0FFh
   100                              <2> %endm
   101                              <2> 
   102                              <2> %imacro db_lo   1
   103                              <2>  db (%1)&255
   104                              <2> %endm
   105                              <2> 
   106                              <2> %imacro cnop    0.nolist
   107                              <2> %if SOFT_DEBUG
   108                              <2>         nop
   109                              <2> %endif
   110                              <2> %endm
   111                              <2> 
   112                              <2> %imacro popm 1-*.nolist
   113                              <2> %rep %0
   114                              <2> %ifidni %1,ALL
   115                              <2>  popa
   116                              <2> %elifidni %1,F
   117                              <2>  popf
   118                              <2> %else
   119                              <2>  pop %1
   120                              <2> %ifidni %1,DS
   121                              <2>  cnop
   122                              <2> %elifidni %1,ES
   123                              <2>  cnop
   124                              <2> %endif
   125                              <2> %endif
   126                              <2> %rotate 1
   127                              <2> %endrep
   128                              <2> %endm
   129                              <2> 
   130                              <2> %imacro pushm 1-*.nolist
   131                              <2> %rep %0
   132                              <2> %rotate -1
   133                              <2> %ifidni %1,ALL
   134                              <2>  pusha
   135                              <2> %elifidni %1,F
   136                              <2>  pushf
   137                              <2> %else
   138                              <2>  push %1
   139                              <2> %endif
   140                              <2> %endrep
   141                              <2> %endm
   142                              <2> 
   143                              <2> ;
   144                              <2> ; added from the 386EX project
   145                              <2> ;
   146                              <2> 
   147                              <2> ; call arguments
   148                              <2> %define ARG(n) [bp+2+(n)*2]
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the BYTE initialization table:  address, byte
   152                              <2> ;
   153                              <2> %imacro  binit 2
   154                              <2>         dw      %1
   155                              <2>         db      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> ;
   160                              <2> ; format of the WORD initialization table:  address, word
   161                              <2> ;
   162                              <2> %imacro  winit 2
   163                              <2>         dw      %1
   164                              <2>         dw      %2
   165                              <2> %endmacro
   166                              <2> ; end with DW -1
   167                              <2> 
   168                              <2> 
   169                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   170                              <2> %imacro get_bda	1.nolist
   171                              <2> 	push	0x0040
   172                              <2> 	pop	%1
   173                              <2> 	cnop
   174                              <2> %endm
   175                              <2> 
   176                              <2> 
   177                              <2> %endif
    61                              <1> 
    62                              <1> 	cpu     186
    63                              <1> ;
    64                              <1> ;
    65                              <1> ; IBM model byte -- must be less than a 286
    66                              <1> ;
    67                              <1> 
    68                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    69                              <1> SUBMODEL_BYTE		equ	00h	;  "
    70                              <1> 
    71                              <1> 
    72                              <1> ; 80188 peripheral control register block address
    73                              <1> CPU_CSCR	        equ	0FF00h
    74                              <1> 
    75                              <1> ; Compatible Mode registers
    76                              <1> 
    77                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    78                              <1> 
    79                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    80                              <1> 
    81                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    82                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    83                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    84                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    85                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    86                              <1> 
    87                              <1> ; Enhanced Mode registers
    88                              <1> 
    89                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    90                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    91                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    92                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    93                              <1> 
    94                              <1> 
    95                              <1> ; On-board internal peripheral equates
    96                              <1> ; Programmable Interrupt Controller
    97                              <1> PIC	        equ	CPU_CSCR+020H
    98                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    99                              <1> PIC_POLLR	equ	PIC+4
   100                              <1> PIC_POLLSR	equ	PIC+6
   101                              <1> PIC_IMASK	equ	PIC+8
   102                              <1> PIC_PMREG	equ	PIC+0AH
   103                              <1> PIC_SRVR	equ	PIC+0CH
   104                              <1> PIC_IRQR	equ	PIC+0EH
   105                              <1> PIC_IRQSR	equ	PIC+10H
   106                              <1> PIC_TCR	        equ	PIC+12H
   107                              <1> PIC_DMA0CR	equ	PIC+14H
   108                              <1> PIC_DMA1CR	equ	PIC+16H
   109                              <1> PIC_I0CON	equ	PIC+18H
   110                              <1> PIC_I1CON	equ	PIC+1AH
   111                              <1> PIC_I2CON	equ	PIC+1CH
   112                              <1> PIC_I3CON	equ	PIC+1EH
   113                              <1> 
   114                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   115                              <1> 
   116                              <1> ; Interrupt masks (Master Mode)
   117                              <1> ;
   118                              <1> mask_timer_all          equ     0001h
   119                              <1> mask_dma0               equ     0004h
   120                              <1> mask_dma1               equ     0008h
   121                              <1> mask_int0               equ     0010h
   122                              <1> mask_int1               equ     0020h
   123                              <1> mask_int2               equ     0040h
   124                              <1> mask_int3               equ     0080h
   125                              <1> 
   126                              <1> 
   127                              <1> 
   128                              <1> ; Timers
   129                              <1> TIM0	        equ	CPU_CSCR+050H
   130                              <1> TIM1	        equ	CPU_CSCR+058H
   131                              <1> TIM2	        equ	CPU_CSCR+060H
   132                              <1> 
   133                              <1> TCNT	        equ	0	; count register
   134                              <1> CMPA	        equ	2	; max count A
   135                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   136                              <1> TCON	        equ	6	; mode/control word
   137                              <1> 
   138                              <1> ; Timer control bits:
   139                              <1> tc_EN           equ     8000h   ; Enable bit
   140                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   141                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   142                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   143                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   144                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   145                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   146                              <1> tc_EXT          equ     0004h   ; External clock
   147                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   148                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   149                              <1> 
   150                              <1> 
   151                              <1> 
   152                              <1> 
   153                              <1> ; DMA
   154                              <1> DMA0	        equ	CPU_CSCR+0C0H
   155                              <1> DMA1	        equ	CPU_CSCR+0D0H
   156                              <1> DMASPL	        equ	0	; source pointer low
   157                              <1> DMASPU	        equ	2	; source pointer high
   158                              <1> DMADPL	        equ	4	; destination pointer low
   159                              <1> DMADPU	        equ	6	; destination pointer high
   160                              <1> DMATC	        equ	8	; terminal count
   161                              <1> DMACW	        equ	0AH	; control word
   162                              <1> 
   163                              <1> 
   164                              <1> 
   165                              <1> 
   166                              <1> 
   167                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   168                              <1> ;
   169                              <1> ;       SBC-188 external devices
   170                              <1> ;
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> 
   173                              <1> IO_BASE			equ	0400h
   174                              <1> 
   175                              <1> 
   176                              <1> 
   177                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   178                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   179                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   180                              <1> 
   181                              <1> uart_base               equ     IO_BASE+0280h
   182                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   183                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   184                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   185                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   186                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   187                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   188                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   189                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   190                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   191                              <1> uart_sr			equ	uart_base+7	;Scratch
   192                              <1> 
   193                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   194                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   195                              <1> 
   196                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   197                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   198                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   199                              <1> CTRL259		equ	IO_BASE+0238H
   200                              <1> ; LEDS are at addresses 0..3
   201                              <1> ; other control ports on 4..7
   202                              <1> LED0		equ	CTRL259+0
   203                              <1> LED1		equ	LED0+1
   204                              <1> LED2		equ	LED0+2
   205                              <1> LED3		equ	LED0+3
   206                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   207                              <1> ;unused		equ	CTRL259+5
   208                              <1> ;unused		equ	CTRL259+6
   209                              <1> ;unused		equ	CTRL259+7
   210                              <1> 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   215                              <1> 
   216                              <1> 
   217                              <1> 
   218                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   219                              <1> ; Floppy controller (Duodyne Disk IO)
   220                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                              <1> FDC	        equ	IO_BASE+0080H
   222                              <1> FDC_MSR         equ     FDC
   223                              <1> FDC_DATA        equ     FDC+1
   224                              <1> FDC_TC	        equ	FDC+2
   225                              <1> FDC_RES	        equ	FDC+3
   226                              <1> FDC_LDCR	equ	FDC+5
   227                              <1> FDC_LDOR	equ	FDC+6
   228                              <1> FDC_DACK        equ	FDC+6
   229                              <1> FDC_DACK_TC     equ     FDC+7
   230                              <1> 
   231                              <1> 
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> RTC	equ	IO_BASE+0094H
   236                              <1> 
   237                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   238                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> PPI	        equ	IO_BASE+0088H
   241                              <1> 
   242                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   243                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   244                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   245                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   246                              <1> 
   247                              <1> portA           equ     PPI+0   ;
   248                              <1> portB           equ     PPI+1   ;
   249                              <1> portC           equ     PPI+2   ;
   250                              <1> 
   251                              <1> ; end CPUREGS.ASM
    36                                  %include	"date.asm"
    37                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    38                              <1> ; date.asm
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    41                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    42                              <1> ;
    43                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    44                              <1> ;
    45                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    46                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    47                              <1> ;
    48                              <1> ; Definitions for version 3.5-2:
    49                              <1> ;
    50                              <1> ; Updated for the Duodyne 80c188 SBC
    51                              <1> 
    52                              <1> %define DATE_STRING0	"10/27/24"
    53                              <1> %define DATE_STRING1	"27-Oct-2024"
    54                              <1> 
    55                              <1> %define VERSION_MAJOR		3
    56                              <1> %define VERSION_MINOR		5
    57                              <1> %define VERSION_REVISION	2
    58                              <1> %define VERSION_SUFFIX		""
    59                              <1> %define VERSION_SEQUENCE	66
    60                              <1> 
    61                              <1> %define VERSION_STRING		"3.5-D",VERSION_SUFFIX
    62                              <1> 
    63                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                              <1> ; Revision information:
    65                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    66                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    67                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    68                              <1> ;	    &  Dual SDcard & Minix boot
    69                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    70                              <1> ;	3.0 -- VGA3 support
    71                              <1> ;	3.1 -- SBC-188 v.3 board support
    72                              <1> ;	3.2 -- IDE8 support on the v.3 board
    73                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    74                              <1> ;	3.4 -- floppy drives did not work
    75                              <1> ;	3.5 -- back to 3.3, sequence #51
    76                              <1> ;		change NVRAM battery backup setup to #53
    77                              <1> ;		re-install 3.4 boot fix for FreeDOS
    78                              <1> ;       3.5-D  Remove SBC-188 specific items and customize for Duodyne
    79                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                                  %include	"equates.asm"
    38                              <1> ;========================================================================
    39                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    40                              <1> ;========================================================================
    41                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    42                              <1> ;
    43                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    44                              <1> ;
    45                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    46                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    47                              <1> ;
    48                              <1> ; This program is free software: you can redistribute it and/or modify
    49                              <1> ; it under the terms of the GNU General Public License as published by
    50                              <1> ; the Free Software Foundation, either version 3 of the License, or
    51                              <1> ; (at your option) any later version.
    52                              <1> ;
    53                              <1> ; This program is distributed in the hope that it will be useful,
    54                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    55                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    56                              <1> ; GNU General Public License for more details.
    57                              <1> ;
    58                              <1> ; You should have received a copy of the GNU General Public License
    59                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    60                              <1> ;
    61                              <1> ;========================================================================
    62                              <1> 
    63                              <1>         global  FPEM_segment
    64                              <1> 
    65                              <1> 
    66                              <1> %include "segdef.asm"
    67                              <2> ;========================================================================
    68                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    69                              <2> ;========================================================================
    70                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    71                              <2> ;
    72                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    73                              <2> ;
    74                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    75                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    76                              <2> ;
    77                              <2> ; This program is free software: you can redistribute it and/or modify
    78                              <2> ; it under the terms of the GNU General Public License as published by
    79                              <2> ; the Free Software Foundation, either version 3 of the License, or
    80                              <2> ; (at your option) any later version.
    81                              <2> ;
    82                              <2> ; This program is distributed in the hope that it will be useful,
    83                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    84                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    85                              <2> ; GNU General Public License for more details.
    86                              <2> ;
    87                              <2> ; You should have received a copy of the GNU General Public License
    88                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    89                              <2> ;
    90                              <2> ;========================================================================
    91                              <2> 
    92                              <2> %ifndef __SEGDEF_
    93                              <2> %define __SEGDEF_
    94                              <2> 
    95                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    96                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    97                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    98                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    99                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
   100                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
   101                              <2> 
   102                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
   103                              <2> 
   104                              <2> %endif
   105                              <2> 
    67                              <1> %include "ascii.asm"
    68                              <2> ; ascii.asm
    69                              <2> ;
    70                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    71                              <2> 
    72                              <2> NUL     equ     00h
    73                              <2> BEL     equ     (CTRL & 'G')
    74                              <2> BS      equ     08h		; ^H
    75                              <2> HT      equ     09h		; ^I
    76                              <2> LF	equ	0Ah		; ^J
    77                              <2> NL      equ     LF
    78                              <2> VT	equ	0Bh		; ^K
    79                              <2> FWD	equ	0Ch		; ^L
    80                              <2> CR	equ	0Dh
    81                              <2> XON     equ     (CTRL & 'Q')
    82                              <2> XOFF    equ     (CTRL & 'S')
    83                              <2> DC1     equ     XON
    84                              <2> DC3     equ     XOFF
    85                              <2> ESC     equ	1Bh
    86                              <2> 
    87                              <2> 
    68                              <1> 
    69                              <1> 
    70                              <1> ; POST error codes. Presently one byte but can expand to word.
    71                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    72                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    73                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    74                              <1> ER_FDC	equ	08h		; Bad FDC
    75                              <1> ER_UNK1	equ	10h		; {unassigned}
    76                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    77                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    78                              <1> ER_UNK2	equ	80h		; {unassigned}
    79                              <1> 
    80                              <1> 
    81                              <1> 
    82                              <1> ;; ************************ BIOS Data Segment ******************************
    83                              <1> ;; BIOS data segment - not all will  be used
    84                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    85                              <1> %include "bda.inc"
    86                              <2> ;/*======================================================================
    87                              <2> ; bda.inc -- BIOS data area definitions
    88                              <2> ;========================================================================
    89                              <2> ;   for the N8VEM SBC-188
    90                              <2> ;
    91                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    92                              <2> ;
    93                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    94                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    95                              <2> ;
    96                              <2> ; This program is free software: you can redistribute it and/or modify
    97                              <2> ; it under the terms of the GNU General Public License as published by
    98                              <2> ; the Free Software Foundation, either version 3 of the License, or
    99                              <2> ; (at your option) any later version.
   100                              <2> ;
   101                              <2> ; This program is distributed in the hope that it will be useful,
   102                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   103                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   104                              <2> ; GNU General Public License for more details.
   105                              <2> ;
   106                              <2> ; You should have received a copy of the GNU General Public License
   107                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   108                              <2> ;
   109                              <2> ;========================================================================
   110                              <2> 
   111                              <2> 			;*/ extern				/*
   112                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   113 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   114 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   115 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   116                              <2> ;	dw	?		; 40:10 	; Equipment present word
   117                              <2> ;  						;  = (1 iff floppies) *     1.
   118                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   119                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   120                              <2> ;  						;  + (init crt mode ) *    16.
   121                              <2> ;  						;  + (# of floppies ) *    64.
   122                              <2> ;  						;  + (# serial ports) *   512.
   123                              <2> ;  						;  + (1 iff toy port) *  4096.
   124                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   125                              <2> ;  						;  + (# parallel LPT) * 16384.
   126 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   127 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   128                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   129 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   130 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   131                              <2> ;;---------------[Keyboard data area]------------;
   132 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   133                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   134 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   135 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   136 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   137 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   138                              <2> kbd_buffer_last	equ	$	;*/				/*
   139                              <2> ;;---------------[Diskette data area]------------;
   140 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   141 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   142 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   143 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   144                              <2> ;				Floppy return code stat byte
   145                              <2> ;				;  1 = bad ic 765 command req.
   146                              <2> ;				;  2 = address mark not found
   147                              <2> ;				;  3 = write to protected disk
   148                              <2> ;				;  4 = sector not found
   149                              <2> ;				;  8 = data late (DMA overrun)
   150                              <2> ;				;  9 = DMA failed 64K page end
   151                              <2> ;				; 16 = bad CRC on floppy read
   152                              <2> ;				; 32 = bad NEC 765 controller
   153                              <2> ;				; 64 = seek operation failed
   154                              <2> ;				;128 = disk drive timed out
   155 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   156                              <2> ;;---------------[Video display area]------------;
   157 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   158                              <2> ;			 	; Current CRT mode  (software)
   159                              <2> ;				;  0 = 40 x 25 text (no color)
   160                              <2> ;				;  1 = 40 x 25 text (16 color)
   161                              <2> ;				;  2 = 80 x 25 text (no color)
   162                              <2> ;				;  3 = 80 x 25 text (16 color)
   163                              <2> ;				;  4 = 320 x 200 grafix 4 color
   164                              <2> ;				;  5 = 320 x 200 grafix 0 color
   165                              <2> ;				;  6 = 640 x 200 grafix 0 color
   166                              <2> ;				;  7 = 80 x 25 text (mono card)
   167 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   168 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   169 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   170 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   171 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   172 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   173 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   174 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   175 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   176                              <2> ;;---------------[Used to setup ROM]-------------;
   177 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   178 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   179                              <2> ;;---------------[Timer data area]---------------;
   180 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   181 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   182                              <2> ;;---------------[System data area]--------------;
   183 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   184 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   185                              <2> ;;---------------[Hard disk scratchpad]----------;
   186 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   187                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   188 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   189 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   190                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   191 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   192 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   193                              <2> ;;---------------[EGA stuff]---------------------;
   194 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   195                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   196 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   197 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   198 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   199 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   200 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   201                              <2> ;;---------------[Additional KBD flags]----------------;
   202 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   203 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   204                              <2> ;;---------------[RTC/timer1 data]---------------------;
   205 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   206 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   207 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   208                              <2> ;;---------------[Cassette I/O stuff]------------------;
   209 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   210 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   211                              <2> ;									Post Acknowleged=00;
   212 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   213 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   214 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   215                              <2> ;
   216 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   217 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   218 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   219 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   220                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   221 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   222 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   223 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   224 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   225 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   226 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   227 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   228 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   229 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   230 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   231 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   232 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   233 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   234 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   235 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   236                              <2> ;
   237                              <2> ;
   238                              <2> 
   239 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   240                              <2> 
   241 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   242                              <2> 
   243 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   244 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   245                              <2> 
   246 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   247                              <2> 
   248 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   249                              <2> 
   250 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   251                              <2> 
   252 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   253                              <2> ;								   CPU clock is half of this
   254                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   255                              <2> ;
   256                              <2> ;  System configuration stuff below
   257                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   258                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   259                              <2> %if 0				;*/
   260                              <2> #define FIXED_DISK_MAX 4		/*
   261                              <2> %else
   262                              <2> %define FIXED_DISK_MAX 4
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define PPIDE_driver 1		/*
   266                              <2> %else
   267                              <2> %define PPIDE_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define DIDE_driver 0		/*
   271                              <2> %else
   272                              <2> %define DIDE_driver 0
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DISKIO_driver 1		/*
   276                              <2> %else
   277                              <2> %define DISKIO_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define MFPIC_driver 1		/*
   281                              <2> %else
   282                              <2> %define MFPIC_driver 1
   283                              <2> %endif
   284                              <2> %if 0				;*/
   285                              <2> #define DSD_driver 1		/*
   286                              <2> %else
   287                              <2> %define DSD_driver 1
   288                              <2> %endif
   289                              <2> %if 0				;*/
   290                              <2> #define V3IDE8_driver (SBC188==3)		/*
   291                              <2> %else
   292                              <2> %define V3IDE8_driver (SBC188==3)
   293                              <2> %endif
   294                              <2> 				;*/
    86                              <1> 
    87                              <1> ;  this must be the same in EQUATES.H */
    88                              <1> %if SOFT_DEBUG
    89                              <1> %define NBREAK  8
    90                              <1> %endif
    91                              <1> 
    92                              <1> 
    93                              <1> %if 0
    94                              <1>         segment _TEXT
    95                              <1> ;; *************************************************************************
    96                              <1> 
    97                              <1> 
    98                              <1> 
    99                              <1> 
   100                              <1> ;; ************************ DOS Data Segment *******************************
   101                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
   102                              <1> ;xerox	label	byte				;  0 if Print Screen idle
   103                              <1> ;						;  1 if PrtSc xeroxing screen
   104                              <1> ;						;255 if PrtSc error in xerox
   105                              <1> ;						;  ...non-grafix PrtSc in bios
   106                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   107                              <1> ;						;  ...IBMBIO.COM buffers the
   108                              <1> ;						;  ...directory of the boot
   109                              <1> ;						;  ...device here at IPL time
   110                              <1> ;						;  ...when locating the guts
   111                              <1> ;						;  ...of the operating system
   112                              <1> ;						;  ...filename "IBMDOS.COM"
   113                              <1> ;dosdir	ends
   114                              <1> ;; *************************************************************************
   115                              <1> ;; ************************ DOS IPL Segment ********************************
   116                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   117                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   118                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   119                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   120                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   121                              <1> ;dosseg	ends					;			      !
   122                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   123                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   124                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   125                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   126                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   127                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   128                              <1> ;iplseg	ends
   129                              <1> 
   130                              <1> %endif
    38                                  
    39                                  %define	VERSION	VERSION_STRING
    40                                  %define	DATE	DATE_STRING1
    41                                  
    42                                  ;;      global  begin_here
    43                                  	global	cold_boot
    44                                          global  initialization
    45                                  	extern	ident2
    46                                          extern  _cprintf
    47                                  %if TRACE
    48                                  	extern	int_trace
    49                                  %endif	; TRACE
    50                                  
    51                                  
    52                                  	segment         _TEXT
    53                                  
    54                                  cold_boot:
    55 00000000 FA                              cli                     ; Should be clear already
    56 00000001 89C3                    	mov	bx,ax		; save board revision in BX
    57                                  %if SOFT_DEBUG
    58                                          mov     dx,FRONT_PANEL_LED
    59                                          mov     al,0A5h         ; A5 to the LITES
    60                                          out     dx,al
    61                                  %endif
    62 00000003 B84000                          mov     ax,bios_data_seg
    63 00000006 8ED0                            mov     ss,ax
    64 00000008 BC0070                          mov     sp,7000h        ; Stack should be out of the way
    65                                  ; cannot use the stack yet, since memory is not tested
    66                                  %if 0
    67                                      ss	mov	bx,word [warm_boot]	; check for 1234h == Warm Boot
    68                                  %else
    69 0000000B 30FF                    	xor	bh,bh			; not warm boot
    70 0000000D 36813E72003412              ss  cmp	word [warm_boot],1234h
    71 00000014 7504                    	jne	.1
    72 00000016 FEC7                    	inc	bh			; it IS a warm boot
    73 00000018 EB08                    	jmp	cold_continue		; JRC - DEBUG test
    74                                  .1:
    75                                  %endif
    76                                  %if SOFT_DEBUG
    77                                  	push	5Ah
    78                                  	call	lites
    79                                  %endif
    80                                  memory_testing:
    81                                  ; Immediately test low memory
    82 0000001A 31C0                            xor     ax,ax           ; Segment 0
    83 0000001C BD[2200]                        mov     bp,.0           ; return address
    84 0000001F E9D303                          jmp     memtest0        ; don't use the stack
    85                                  .0:
    86                                  ; BX was preserved by 'memtest0'
    87                                  
    88                                  %if SOFT_DEBUG
    89                                          jnc     cold_continue
    90                                          mov     dx,FRONT_PANEL_LED
    91                                          mov     al,0F1h         ; F1 to the LITES
    92                                          out     dx,al
    93                                  .1:
    94                                          hlt
    95                                          jmp     .1              ; solid halt on error
    96                                  %endif
    97                                  
    98                                  cold_continue:
    99 00000022 FC                              cld                     ; Clear the direction flag
   100 00000023 31C0                            xor     ax,ax
   101 00000025 8EC0                            mov     es,ax
   102                                          cnop
   103 00000027 89C7                            mov     di,ax
   104 00000029 B90003                          mov     cx,600h/2       ; clear segments 00h, 040h and 050h
   105 0000002C F3AB                       rep  stosw                   ; clear out BIOS DATA AREA
   106                                  
   107                                  %if 0
   108                                     ss	mov	word [warm_boot],bx	; save only warm boot flag
   109                                  %else
   110 0000002E 36881E1600                 ss	mov	byte [sbc188_rev],bl	; save board revision
   111 00000033 36891E7200                 ss	mov	word [warm_boot],bx	; save warm boot garbage
   112 00000038 08FF                       	or	bh,bh			; test for warm boot
   113 0000003A 7407                    	jz	.3
   114 0000003C 36C70672003412             ss	mov	word [warm_boot],1234h	; restore warm boot code
   115                                  .3:
   116                                  %endif
   117 00000043 E84103                          call    get_ramsize
   118 00000046 C1E006                          shl     ax,6            ; convert to Segment address
   119                                  %if SOFT_DEBUG
   120                                  	mov	cx,_BSS		; paragraph of _BSS segment
   121                                  ; since the BSS is of length 0000, this is beyond all data
   122                                  
   123                                          mov     bx,cs           ; Code Segment
   124                                          sub     cx,bx           ; Code paragraphs
   125                                          push    cx
   126                                          mov     bx,ax           ; Save HMA in K
   127                                          sub     bx,cx           ; new Code segment
   128                                          mov     es,bx           ; Destination
   129                                          cnop
   130                                          mov     ax,bx           ; Paragraph address to AX
   131                                  
   132                                          push    cs
   133                                          popm     ds              ; Source
   134                                          xor     si,si
   135                                          xor     di,di
   136                                          pop     cx              ; Code length in Paragraphs
   137                                          shl     cx,3            ; Code length in words
   138                                     rep  movsw                   ; move all of it
   139                                          push    es              ; new Code segment
   140                                          push    word SOFT_continue   ; IP
   141                                          retf
   142                                  
   143                                          global  SOFT_continue
   144                                  SOFT_continue:                  ; Continue here in soft memory
   145                                  ;
   146                                  ;  Allocate the DEBUG static area
   147                                  ;
   148                                  	mov	cx,(NBREAK+1)*8 + 15
   149                                  	shr	cx,4		; CX=needed paragraphs
   150                                  	sub	ax,cx		; allocate space
   151                                    ss	mov	[debug_static_ptr+2],ax	 	; setup static area segment
   152                                    ss	mov	word [debug_static_ptr],0	; and offset
   153                                    	shl	cx,4		; word count
   154                                  	pushm	ax,ax		; save segment, twice
   155                                  	popm	es		; set segment to zap
   156                                  	xor	di,di		; start at offset 0
   157                                  	mov	ax,di		; AL=0
   158                                    rep	stosb	    		; Zap memory
   159                                  	popm	ax		; restore AX, EBDA paragraph segment
   160                                  %endif
   161                                  ;
   162                                  ; Save the memory pointers
   163                                  ;
   164 00000049 36A3F200                    ss  mov     [EBDA_paragraph],ax
   165 0000004D C1E806                          shr     ax,6
   166 00000050 36A31300                    ss  mov     [memory_size],ax
   167                                  
   168 00000054 68[ssss]                        push    DGROUP
   169 00000057 1F                              popm    ds              ; This is for the C-programs
   170                                  
   171 00000058 E8F901                          call    set_traps	; setup interrupt table
   172 0000005B E8F501                  	call	set_interrupt_priority ; set default interrupt priorities
   173                                  
   174 0000005E B80300                  	mov	ax,UART_RATE	; set the default rate
   175                                  	extern	@nvram_get_video
   176 00000061 E8(0000)                	call	@nvram_get_video
   177                                  				; get RAM_serial byte - UART speed
   178                                  				; returned in AL
   179                                  %if SOFT_DEBUG
   180                                  	PUSH	3
   181                                  	CALL	lites
   182                                  %endif
   183                                  	extern	video_init
   184 00000064 E8(0000)                	call	video_init
   185                                  
   186                                  %if SOFT_DEBUG
   187                                  	PUSH	4
   188                                  	CALL	lites
   189                                  %endif
   190                                  	extern	keyboard_init
   191 00000067 E8(0000)                	call	keyboard_init
   192                                  
   193                                  %if SOFT_DEBUG
   194                                  	PUSH	5
   195                                  	CALL	lites
   196                                  %endif
   197 0000006A FB                      	sti                     ; enable interrupts
   198                                  %if FPEM
   199 0000006B 9BDBE3                  	finit			; will allocate memory
   200                                  %endif
   201                                  %if SOFT_DEBUG
   202                                  	PUSH	1
   203                                  	CALL	lites
   204                                  %endif
   205                                  
   206 0000006E 6A42                    	push	VERSION_SEQUENCE
   207 00000070 0E                      	push	cs
   208 00000071 68[4D06]                	push	ident1
   209 00000074 E8(0000)                	call	_cprintf
   210 00000077 58                      	pop     ax
   211 00000078 68[0000]                	push	ident2
   212 0000007B E8(0000)                	call	_cprintf
   213 0000007E 58                      	pop     ax
   214 0000007F 68[F705]                	push	ident3
   215 00000082 E8(0000)                	call	_cprintf
   216 00000085 58                      	pop     ax
   217 00000086 58                      	pop     ax
   218 00000087 58                      	pop	ax
   219                                  
   220                                  %if SOFT_DEBUG
   221                                  %if SOFT_DEBUG>1
   222                                  	PUSH	2
   223                                  	CALL	lites
   224                                  %endif
   225                                          extern     redbug
   226                                  
   227                                          pushf           ; push the flags
   228                                          push    cs      ; simulate a far call
   229                                          call    redbug  ; call our weak debugger
   230                                     es   mov     cx,[bp+si+4]
   231                                  %if SOFT_DEBUG>1
   232                                  	PUSH	3
   233                                  	CALL	lites
   234                                  %endif
   235                                  
   236                                  %endif
   237                                  
   238                                  HAS_FLOPPY	equ	0000000000000001b
   239                                  HAS_FPU		equ	0000000000000010b
   240                                  HAS_MOUSE	equ	0000000000000100b
   241                                  VIDEO_EGA	equ	0000000000000000b
   242                                  VIDEO_COLOR_40	equ	0000000000010000b
   243                                  VIDEO_COLOR_80	equ	0000000000100000b
   244                                  VIDEO_MONO	equ	0000000000110000b
   245                                  FLOPPIES_1	equ	0000000000000000b
   246                                  FLOPPIES_2	equ	0000000001000000b
   247                                  FLOPPIES_3	equ	0000000010000000b
   248                                  FLOPPIES_4	equ	0000000011000000b
   249                                  SERIAL_0	equ	0000000000000000b
   250                                  SERIAL_1	equ	0000001000000000b
   251                                  SERIAL_2	equ	0000010000000000b
   252                                  SERIAL_3	equ	0000011000000000b
   253                                  SERIAL_4	equ	0000100000000000b
   254                                  SERIAL_5	equ	0000101000000000b
   255                                  SERIAL_6	equ	0000110000000000b
   256                                  SERIAL_7	equ	0000111000000000b
   257                                  PARALLEL_0	equ	0000000000000000b
   258                                  PARALLEL_1	equ	0100000000000000b
   259                                  PARALLEL_2	equ	1000000000000000b
   260                                  PARALLEL_3	equ	1100000000000000b
   261                                  
   262                                  
   263                                  ; setup BIOS data area
   264 00000088 6A40                    	push	bios_data_seg
   265 0000008A 1F                      	popm	ds
   266 0000008B C606AE0000              	mov	byte [lock_count],0	; zap the @enable/@disable lock count
   267                                  ; no serial interface -- it is used for the video driver
   268 00000090 B83100                  	mov	ax,PARALLEL_0|SERIAL_0|FLOPPIES_1|VIDEO_MONO|HAS_FLOPPY
   269                                  %if FPEM
   270 00000093 83C802                          or      ax,HAS_FPU              ; a bit of a lie
   271                                  %endif
   272 00000096 A31000                  	mov	word [equipment_flag],ax
   273                                  
   274                                  	extern	_cpu_speed
   275 00000099 E8(0000)                	call	_cpu_speed
   276 0000009C 055802                  	add	ax,600
   277 0000009F B9E204                  	mov	cx,1250
   278 000000A2 31D2                    	xor	dx,dx
   279 000000A4 F7F1                    	div	cx
   280 000000A6 A2FF00                  	mov	byte [cpu_xtal],al	; CPU oscillator frequency
   281                                  
   282 000000A9 FF361300                	push	word [memory_size]
   283                                  
   284 000000AD 68[ssss]                	push	DGROUP
   285 000000B0 1F                      	popm	ds			; This is for the C-programs
   286                                  
   287 000000B1 50                      	push	ax
   288                                  	extern	@timer_init
   289 000000B2 E8(0000)                	call	@timer_init
   290 000000B5 58                      	pop	ax
   291                                  
   292 000000B6 1E                      	push	ds
   293 000000B7 A90100                  	test	ax,1
   294 000000BA 7505                    	jnz	.cpu_clock_05
   295 000000BC 68[6D01]                	push	msg_cpu_clock_00
   296 000000BF EB03                    	jmp	.print_cpu_clock
   297                                  .cpu_clock_05:
   298 000000C1 68[6A01]                	push	msg_cpu_clock_05
   299                                  .print_cpu_clock:
   300 000000C4 D1E8                    	shr	ax,1
   301 000000C6 50                      	push	ax
   302 000000C7 1E                      	push	ds
   303 000000C8 68[3201]                	push	msg_cpu_memory
   304 000000CB E8(0000)                	call	_cprintf
   305 000000CE 83C40A                  	add	sp,12-2
   306                                  %if 1
   307 000000D1 58                              pop     ax                      ; memory size in K
   308 000000D2 E88C03                          call    POST_memory             ; Power On Self Test
   309                                  
   310 000000D5 36C70672003412             ss	mov	word [warm_boot],1234h	; set warm boot code
   311                                  
   312                                  %endif
   313 000000DC E80F00                  	call	nvram_init
   314                                  
   315 000000DF 1E                      	push	ds		; DS = DGROUP (CONST)
   316 000000E0 68[B901]                	push	msg_floppy
   317 000000E3 E8(0000)                	call	_cprintf
   318 000000E6 83C404                  	add	sp,4
   319                                  
   320                                  	extern	@floppy_init
   321 000000E9 E8(0000)                	call	@floppy_init
   322                                  
   323 000000EC EB62                    	jmp	boot_the_OS
   324                                  
   325                                  
   326                                  ;========================================================================
   327                                  ; nvram_init - check NVRAM checksum, prompt for NVRAM setup, apply NVRAM configuration
   328                                  ;========================================================================
   329                                  nvram_init:
   330                                  	extern	@nvram_check
   331 000000EE E8(0000)                	call	@nvram_check
   332 000000F1 09C0                    	or	ax,ax
   333 000000F3 740C                    	jz	.ask_setup
   334                                  
   335 000000F5 1E                      	push	ds
   336 000000F6 68[8F01]                	push	msg_nvram_bad
   337 000000F9 E8(0000)                	call	_cprintf
   338 000000FC 83C404                  	add	sp,4
   339 000000FF EB2D                    	jmp	.run_setup
   340                                  
   341                                  .ask_setup:
   342 00000101 1E                      	push	ds
   343 00000102 68[6E01]                	push	msg_setup
   344 00000105 E8(0000)                	call	_cprintf
   345 00000108 83C404                  	add	sp,4
   346                                  
   347 0000010B B400                    	mov	ah,0
   348 0000010D CD1A                    	int	1Ah
   349 0000010F 89D3                    	mov	bx,dx
   350 00000111 83C324                  	add	bx,18*2		; wait 2 seconds
   351                                  .wait_setup:
   352 00000114 B401                    	mov	ah,1
   353 00000116 CD16                    	int	16h
   354 00000118 740A                    	jz	.wait_setup_1
   355 0000011A B400                    	mov	ah,0
   356 0000011C CD16                    	int	16h
   357 0000011E 0C20                    	or	al,'s'^'S'
   358 00000120 3C73                    	cmp	al,'s'
   359 00000122 740A                    	je	.run_setup
   360                                  
   361                                  .wait_setup_1:
   362 00000124 B400                    	mov	ah,0
   363 00000126 CD1A                    	int	1Ah
   364 00000128 39DA                    	cmp	dx,bx
   365 0000012A 72E8                    	jb	.wait_setup
   366 0000012C EB03                    	jmp	.skip_setup
   367                                  
   368                                  .run_setup:
   369                                  	extern	@nvram_setup
   370 0000012E E8(0000)                	call	@nvram_setup
   371                                  
   372                                  .skip_setup:
   373                                  	extern	@nvram_apply
   374 00000131 E8(0000)                	call	@nvram_apply
   375                                  
   376 00000134 E8DD01                          call    ticktime                ; set the tick clock
   377                                  
   378 00000137 C3                      	ret
   379                                  
   380                                  ;========================================================================
   381                                  ; BIOS_call_18h - Start ROM Basic
   382                                  ; Note:
   383                                  ;	In this BIOS it prints a "no Basic" message and tries to boot the OS
   384                                  ;	or it will run tests if tests are enabled
   385                                  ;========================================================================
   386                                  BIOS_call_18h:
   387 00000138 FB                      	sti
   388                                  %ifdef TESTS
   389                                  	extern	tests
   390                                  	call	tests
   391                                  %else	; TESTS
   392                                  
   393                                  %if TBASIC
   394                                  ;;;        extern  cbasic
   395                                  ;;;        extern  end_cbasic
   396                                  ;;;	jmp	seg cbasic:cbasic
   397 00000139 EA000000F0              	jmp	0F000h:0000h
   398                                  %else
   399                                  	mov	ax,bios_data_seg
   400                                  	mov	ss,ax			; Reset SS
   401                                  	mov	sp,7000h		; and SP
   402                                  	push	DGROUP			; just in case DS is not pointing
   403                                  	popm	ds			; were it should
   404                                  
   405                                  	push	ds
   406                                  	push	msg_no_basic
   407                                  	call	_cprintf
   408                                  	add	sp,4
   409                                  	mov	ah,0			; get any keystroke; jrc 2012/12/02
   410                                  	int	16h
   411                                  	int	19h			; reboot the OS
   412                                  %endif  ; TBASIC
   413                                  
   414                                  %endif	; TESTS
   415                                  .1:
   416 0000013E F4                      	hlt				; we should never get here
   417 0000013F EBFD                    	jmp	.1
   418                                  
   419                                  ;========================================================================
   420                                  ; BIOS_call_19h  - re-Boot the OS
   421                                  ;========================================================================
   422                                  BIOS_call_19h:
   423 00000141 6A40                    	push	bios_data_seg
   424 00000143 1F                      	popm	ds
   425 00000144 C70672003412            	mov	word [warm_boot],1234h	; set warm boot flag
   426 0000014A FA                      	cli				; disable interrupts
   427 0000014B EA0000FFFF              	jmp	0FFFFh:0000h		; go to STARTUP.BIN code
   428                                  
   429                                  
   430                                  
   431                                  
   432                                  ;========================================================================
   433                                  ;========================================================================
   434                                  boot_the_OS:
   435 00000150 B84000                  	mov	ax,bios_data_seg
   436 00000153 8ED0                    	mov	ss,ax			; Reset SS
   437 00000155 BC0070                  	mov	sp,7000h		; and SP
   438 00000158 68[ssss]                	push	DGROUP			; just in case DS is not pointing
   439 0000015B 1F                      	popm	ds			; were it should
   440 0000015C FB                      	sti
   441                                  
   442                                  ; Disable Drive A for the time being . . .    DDW 11-3-24
   443                                  ;	push	'A'
   444                                  ;	push	ds
   445                                  ;	push	msg_booting
   446                                  ;	call	_cprintf
   447                                  ;	add	sp,6
   448                                  ;
   449                                  ;	mov	dl,0
   450                                  ;	call	boot_drive
   451                                  
   452 0000015D 6A43                    	push	'C'
   453 0000015F 1E                      	push	ds
   454 00000160 68[D201]                	push	msg_booting
   455 00000163 E8(0000)                	call	_cprintf
   456 00000166 83C406                  	add	sp,6
   457                                  %if SOFT_DEBUG>1
   458                                  	int 0
   459                                  %endif
   460 00000169 B280                    	mov	dl,80h
   461 0000016B E80500                  	call	boot_drive
   462                                  
   463 0000016E CD18                    	int	18h			; failed to boot, start ROM Basic
   464                                  
   465                                  .1:
   466 00000170 F4                      	hlt				; we should never get here
   467 00000171 EBFD                    	jmp	.1
   468                                  
   469                                  ;========================================================================
   470                                  ; boot_drive - try to boot from the drive
   471                                  ; Input:
   472                                  ;	DL = drive number (00h = first floppy, 80h = first HDD)
   473                                  ;========================================================================
   474                                  boot_drive:
   475 00000173 BE0300                  	mov	si,3			; make 3 tries before giving up
   476                                  
   477                                  %if SOFT_DEBUG>1
   478                                  	nop
   479                                  	int 0
   480                                  %endif
   481                                  .1:					; loop comes back here
   482 00000176 B400                    	mov	ah,0			; reset the Disk Controller
   483 00000178 CD13                    	int	13h
   484                                  
   485 0000017A 52                      	push	dx
   486 0000017B B408                    	mov	ah,8			; get drive parameters
   487 0000017D CD13                    	int	13h
   488 0000017F 88D0                    	mov	al,dl			; number of drives
   489 00000181 5A                      	pop	dx
   490 00000182 7213                    	jc	.fn8_error
   491                                  
   492                                  
   493                                  %if SOFT_DEBUG > 2
   494                                  	nop
   495                                  	int	0
   496                                  
   497                                          mov     ax,0401h                ; verify sector
   498                                  	mov	cx,1			; track 0, sector 1
   499                                  	mov	dh,0			; head 0
   500                                          int     13h
   501                                  
   502                                          nop
   503                                          int     0
   504                                  %endif
   505                                  
   506 00000184 B80102                  	mov	ax,0201h		; read one sector
   507 00000187 B90100                  	mov	cx,1			; track 0, sector 1
   508 0000018A B600                    	mov	dh,0			; head 0
   509 0000018C 31DB                    	xor	bx,bx
   510 0000018E 8EC3                    	mov	es,bx			; ES = 0
   511 00000190 BB007C                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   512 00000193 CD13                    	int	13h
   513 00000195 730F                    	jnc	.read_ok
   514                                  
   515                                  .fn8_error:
   516 00000197 4E                      	dec	si			; go back and reset the controller
   517 00000198 75DC                    	jnz	.1			; make several tries
   518                                  
   519 0000019A 50                      	push	ax
   520 0000019B 1E                      	push	ds
   521 0000019C 68[F101]                	push	msg_boot_err
   522 0000019F E8(0000)                	call	_cprintf
   523 000001A2 83C406                  	add	sp,4+2
   524 000001A5 C3                      	ret
   525                                  
   526                                  .read_ok:
   527 000001A6 52                      	push	dx
   528                                  
   529 000001A7 B80480                          mov     ax,8004h                ; NVRAM bits
   530 000001AA E8D603                          call    rtc_get_loc
   531 000001AD A802                            test    al,2            ; RAM_bits_AA55 flag
   532 000001AF 7538                            jnz     .cpm_bootsec
   533 000001B1 26813EFE7D55AA              es	cmp	word [7C00h+1FEh],0AA55h
   534 000001B8 7415                    	je	.good_signature
   535 000001BA 26813EBC7D55AA              es	cmp	word [7C00h+1BCh],0AA55h
   536 000001C1 7420                        	je	.minix_bootsec
   537 000001C3 1E                      	push	ds
   538 000001C4 68[0C02]                	push	msg_no_boot
   539 000001C7 E8(0000)                	call	_cprintf
   540 000001CA 83C404                  	add	sp,4		; remove DX also
   541 000001CD 5A                      	pop	dx		; **
   542 000001CE C3                      	ret
   543                                  .good_signature:
   544 000001CF 26833E007C00                es	cmp	word [7C00h+000h],0
   545 000001D5 751C                    	jne	.good_bootsec
   546 000001D7 1E                      	push	ds
   547 000001D8 68[2602]                	push	msg_no_loader
   548 000001DB E8(0000)                	call	_cprintf
   549 000001DE 83C404                  	add	sp,4		; remove DX also
   550 000001E1 5A                      	pop	dx		; **
   551 000001E2 C3                      	ret
   552                                  
   553                                  .minix_bootsec:
   554 000001E3 1E                      	push	ds		; alternate boot signature
   555 000001E4 68[5C02]                	push	msg_alt_disk
   556 000001E7 EB04                    	jmp	short .cpmbs2
   557                                  .cpm_bootsec:
   558 000001E9 1E                              push    ds
   559 000001EA 68[4802]                        push    msg_cpm_disk
   560 000001ED E8(0000)                .cpmbs2:  call    _cprintf
   561 000001F0 83C404                  	add	sp,4
   562                                  .good_bootsec:
   563 000001F3 1E                      	push	ds
   564 000001F4 68[4402]                	push	msg_boot_ok
   565 000001F7 E8(0000)                	call	_cprintf
   566 000001FA 83C404                  	add	sp,4
   567                                  
   568 000001FD 5A                      	pop	dx
   569                                  
   570                                  %if SOFT_DEBUG>1
   571                                  	global	major_debug
   572                                  major_debug:
   573                                  	cmp	dl,0
   574                                  	jne	.999
   575                                  
   576                                  	xor	bx,bx
   577                                  	push	bx
   578                                  	popm	es			; ES = 0
   579                                  	mov	bx,7C00h		; ES:BX = 0000:7C00
   580                                  	int	0
   581                                  
   582                                  	mov	ax,0201h
   583                                  	inc	cl
   584                                  	int	13h
   585                                  
   586                                  	mov	ax,0201h
   587                                  	mov	cl,10h
   588                                  	int	13h
   589                                  
   590                                  	mov	ax,0201h
   591                                  	mov	dh,1
   592                                  	int	13h
   593                                  
   594                                  	mov	ax,0201h
   595                                  	mov	ch,1		; cylinder 1
   596                                  	int	13h
   597                                  
   598                                  	mov	ax,0201h
   599                                  	mov	ch,23h
   600                                  	int	13h
   601                                  
   602                                  	mov	ax,0201h
   603                                  	mov	cx,1
   604                                  	mov	dh,0
   605                                  	int	13h
   606                                  
   607                                  .999:
   608                                  %endif
   609                                  %if SOFT_DEBUG
   610                                  	push	7
   611                                  	call	lites
   612                                  	int 0
   613                                  %endif
   614 000001FE EA007C0000              	jmp	0000:7C00h		; execute the boot sector
   615                                  
   616                                  
   617                                  
   618                                  %if 0		; now part of 2P1S from R. Cini (RAC)
   619                                  ;========================================================================
   620                                  ; BIOS_call_14h  - Serial port communication services
   621                                  ;========================================================================
   622                                  BIOS_call_14h:
   623                                  %if TRACE
   624                                  	call	int_trace
   625                                  %endif	; TRACE
   626                                  	xor	ax,ax
   627                                  	iret
   628                                  
   629                                  ;========================================================================
   630                                  ; BIOS_call_17h  - Print services
   631                                  ;========================================================================
   632                                  BIOS_call_17h:
   633                                  %if TRACE
   634                                  	call	int_trace
   635                                  %endif	; TRACE
   636                                  	mov	ah,0
   637                                  	iret
   638                                  
   639                                  %endif
   640                                  ;========================================================================
   641                                  
   642                                  interrupt_table:
   643                                  
   644                                  %if SOFT_DEBUG
   645                                  	db	0			; Int 0 - divide by zero
   646                                  	extern	zero_divide
   647                                  	dw	zero_divide
   648                                  
   649                                  	db	1			; Int 1 - single step
   650                                  	extern	single_step
   651                                  	dw	single_step
   652                                  
   653                                  	db	2			; Int 2 - NMI interrupt
   654                                  	extern	nmi_interrupt
   655                                  	dw	nmi_interrupt
   656                                  
   657                                  	db	3			; Int 3 - breakpoint
   658                                  	extern	breakpoint
   659                                  	dw	breakpoint
   660                                  
   661                                  	db	4			; Int 4 - interrupt on overflow (INTO instruction)
   662                                  	extern	INTO_trap
   663                                  	dw	INTO_trap
   664                                  
   665                                  	db	5			; Int 5 - bound check error
   666                                  	extern	bound_trap
   667                                  	dw	bound_trap
   668                                  
   669                                  	db	6			; Int 6 - invalid opcode
   670                                  	extern	undefined_op
   671                                  	dw	undefined_op
   672                                  %endif	; SOFT_DEBUG
   673                                  
   674                                  %if FPEM
   675                                  %if 0
   676                                  	db	7			; ESC opcode / Floating Point
   677                                  	extern	vector7
   678                                  	dw	vector7
   679                                  %endif
   680                                  %else
   681                                  %if SOFT_DEBUG
   682                                  	db	7			; Int 7 - math coprocessor not present
   683                                  	dw	undefined_op
   684                                  %endif	; SOFT_DEBUG
   685                                  %endif
   686                                  
   687 00000203 08                      	db	8			; Timer 0 interrupt
   688                                  	extern	timer0_interrupt
   689 00000204 [0000]                  	dw	timer0_interrupt
   690                                  
   691 00000206 0A                      	db	0Ah			; DMA 0 interrupt
   692                                  	extern	dma0_interrupt
   693 00000207 [0000]                  	dw	dma0_interrupt
   694                                  
   695 00000209 0B                      	db	0Bh			; DMA 1 interrupt
   696 0000020A [3F02]                  	dw	end_of_interrupt
   697                                  
   698 0000020C 0C                      	db	0Ch			; INT0 - UART
   699                                  ; eventually this will be PIC code here
   700                                  %if UART
   701                                  	extern	uart_int
   702 0000020D [0000]                  	dw	uart_int
   703                                  %else
   704                                  	dw	end_of_interrupt
   705                                  %endif
   706                                  
   707 0000020F 0D                      	db	0Dh			; INT1- FDC
   708                                  	extern	fdc_interrupt_level
   709 00000210 [0000]                  	dw	fdc_interrupt_level	; INT1
   710                                  
   711 00000212 0E                      	db	0Eh			; INT1-
   712 00000213 [3F02]                  	dw	end_of_interrupt
   713                                  
   714 00000215 0F                      	db	0Fh
   715 00000216 [3F02]                  	dw	end_of_interrupt
   716                                  
   717                                  
   718 00000218 10                      	db	10h			; BIOS - Video display services
   719                                  	extern	BIOS_call_10h
   720 00000219 [0000]                  	dw	BIOS_call_10h
   721                                  
   722 0000021B 11                      	db	11h			; BIOS - Return equipment list
   723 0000021C [CE03]                  	dw	BIOS_call_11h		; in memory.asm
   724                                  
   725 0000021E 12                      	db	12h			; BIOS - Return conventional memory size
   726 0000021F [D803]                  	dw	BIOS_call_12h		; (shared with Timer 1)
   727                                  ;;;	dw	timer1_interrupt	; non INT 12h passed to timer1
   728                                  
   729 00000221 13                      	db	13h			; BIOS - Disk services
   730                                  %if PPIDE_driver
   731                                  	extern	FIXED_BIOS_call_13h
   732 00000222 [0000]                  	dw	FIXED_BIOS_call_13h     ; (shared with Timer 2, prescaler, NOT USED)
   733                                  
   734 00000224 40                              db      40h                     ; Floppy Driver
   735                                  %endif
   736                                  	extern	BIOS_call_13h
   737 00000225 [0000]                          dw      BIOS_call_13h
   738                                  
   739 00000227 14                      	db	14h			; BIOS - Serial port communication
   740                                  	extern	BIOS_call_14h
   741 00000228 [0000]                  	dw	BIOS_call_14h
   742                                  
   743 0000022A 15                      	db	15h			; BIOS - Miscellaneous system services support routines
   744                                  	extern	BIOS_call_15h
   745 0000022B [0000]                  	dw	BIOS_call_15h
   746                                  
   747 0000022D 16                      	db	16h			; BIOS - Keyboard services
   748                                  	extern	BIOS_call_16h
   749 0000022E [0000]                  	dw	BIOS_call_16h
   750                                  
   751 00000230 17                      	db	17h
   752                                  	extern	BIOS_call_17h
   753 00000231 [0000]                  	dw	BIOS_call_17h		; BIOS - Print services
   754                                  
   755                                  %if TBASIC==0
   756                                  	db	18h			; BIOS - Start ROM Basic
   757                                  	dw	BIOS_call_18h
   758                                  %endif
   759                                  
   760 00000233 19                      	db	19h			; BIOS - Boot the OS
   761 00000234 [4101]                  	dw	BIOS_call_19h
   762                                  
   763 00000236 1A                      	db	1Ah			; BIOS - RTC (real time clock) services
   764                                  	extern	BIOS_call_1Ah
   765 00000237 [0000]                  	dw	BIOS_call_1Ah
   766                                  
   767 00000239 1C                      	db	1Ch
   768                                  	extern	BIOS_call_1Ch
   769 0000023A [0000]                  	dw	BIOS_call_1Ch
   770                                  
   771 0000023C 70                      	db	70h			; RTC timer tick on IRQ8
   772                                  	extern	rtc_interrupt
   773 0000023D [0000]                  	dw	rtc_interrupt		; 1024 Hz timer
   774                                  
   775                                  num_vectors	equ     (($-interrupt_table)/3)
   776                                  
   777                                  ;========================================================================
   778                                  ; end_of_interrupt - signal end of interrupt to the interrupt controller
   779                                  ;========================================================================
   780                                  end_of_interrupt:
   781 0000023F 5250                            pushm   ax,dx
   782 00000241 BA22FF                          mov     dx,PIC_EOI              ; EOI register
   783 00000244 B80080                          mov     ax,EOI_NSPEC            ; non-specific end of interrupt
   784 00000247 EF                              out     dx,ax                   ; signal it
   785 00000248 585A                            popm    ax,dx
   786 0000024A CF                      	iret
   787                                  
   788                                  skip_trap:
   789                                  %if TRACE
   790                                  	call	int_trace
   791                                  %endif	; TRACE
   792 0000024B CF                              iret            ; return from interrupt is a null trap
   793                                  
   794                                  
   795                                  ;========================================================================
   796                                  ;  Interrupt priority re-assignments
   797                                  ;========================================================================
   798                                  MASK		equ	08h	; mask interrupt
   799                                  LTM		equ	10h	; Level Trigger Mode
   800                                  interrupt_priority:
   801 0000024C 0E                      	db	6 | MASK	; Timers -- timer_init clears the mask
   802 0000024D 02                      	db	2		; DMA0
   803 0000024E 0A                      	db	2 | MASK	; DMA1
   804 0000024F 0C                      	db	4 | MASK	; INT0 -- external /INT (keyboard)
   805 00000250 04                      	db	4		; INT1 -- UART
   806 00000251 0F                      	db	7 | MASK	; INT2
   807 00000252 1B                      	db	3 | LTM+MASK	; INT3 -- floppy disk
   808                                  lth_int_priority   equ	$-interrupt_priority
   809                                  
   810                                  set_interrupt_priority:
   811                                  %if 0
   812                                  /* for now */
   813                                  	mov	dx,PIC_TCR
   814                                  	mov	si,interrupt_priority
   815                                  	xor	ax,ax		; zap AH
   816                                  	mov	cx,lth_int_priority
   817                                  sip_loop:
   818                                     cs	lodsb			; get priority level
   819                                     	out	dx,ax
   820                                  	add	dx,2		; PIC control regs are even
   821                                  	loop	sip_loop
   822                                  %endif
   823 00000253 C3                      	ret
   824                                  
   825                                  ;========================================================================
   826                                  ; set_traps - setup interrupt table
   827                                  ;========================================================================
   828                                  set_traps:
   829 00000254 1E                              push    ds
   830                                  
   831 00000255 8CCA                    	mov	dx,cs
   832 00000257 B90001                  	mov	cx,0100h	; number of interrupt vectors
   833 0000025A B300                    	mov	bl,0		; start with int 0
   834 0000025C B8[4B02]                	mov	ax,skip_trap
   835                                  .set_default_loop:
   836 0000025F E83E00                  	call	set_vector
   837 00000262 FEC3                    	inc	bl
   838 00000264 E2F9                    	loop	.set_default_loop
   839                                  
   840 00000266 8EDA                            mov     ds,dx           ; for LODS  CS==DX==DS
   841                                          cnop
   842 00000268 BE[0302]                        mov     si,interrupt_table	; load address to start
   843 0000026B B91400                  	mov	cx,num_vectors
   844                                  				; note DX = CS
   845                                  .set_vectors_loop:
   846 0000026E AC                      	lodsb
   847 0000026F 88C3                    	mov	bl,al
   848 00000271 AD                      	lodsw
   849 00000272 E82B00                  	call	set_vector
   850 00000275 E2F7                    	loop	.set_vectors_loop
   851                                  
   852                                  %if TBASIC
   853 00000277 B318                    	mov	bl,18h		; int 18h is Tiny Basic
   854 00000279 31C0                    	xor	ax,ax
   855 0000027B BA00F0                  	mov	dx,0F000h	; absolute segment load @ 00K
   856 0000027E E81F00                  	call	set_vector
   857                                  %endif
   858                                  %if FPEM
   859 00000281 B307                    	mov	bl,07h		; vector 7 is FPU emulator
   860 00000283 31C0                    	xor	ax,ax
   861 00000285 BA80F4                  	mov	dx,0F480h	; absolute segment load @ 18K
   862 00000288 E81500                  	call	set_vector
   863                                  %endif
   864                                  
   865 0000028B 1F                              popm     ds
   866 0000028C C3                              ret
   867                                  
   868                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   869                                  ;  get_vector
   870                                  ;       Get an interrupt vector
   871                                  ;
   872                                  ;       Enter with vector number in BL
   873                                  ;       Exit with vector in DX:AX
   874                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   875                                          global  get_vector
   876                                  get_vector:
   877 0000028D 1E53                            pushm   bx,ds		; register saves
   878                                  
   879 0000028F 31C0                            xor     ax,ax           ; zero BX
   880 00000291 8ED8                            mov     ds,ax           ; set DS=0
   881                                          cnop
   882 00000293 B700                    	mov	bh,0
   883 00000295 C1E302                          shl     bx,2            ; index * 4
   884                                  
   885 00000298 8B07                            mov     ax,[bx]         ; load the vector
   886 0000029A 8B5702                          mov     dx,[bx+2]       ;
   887                                  
   888 0000029D 5B1F                            popm    bx,ds		; register restores
   889 0000029F C3                              ret                     ; result in DX:AX
   890                                  
   891                                  
   892                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   893                                  ;  set_vector
   894                                  ;       Set an interrupt vector
   895                                  ;
   896                                  ;       Enter with vector number in BL
   897                                  ;               vector in DX:AX
   898                                  ;
   899                                  ;       All registers preserved
   900                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   901                                          global  set_vector
   902                                  set_vector:
   903 000002A0 1E5351                          pushm   cx,bx,ds	; register saves
   904                                  
   905 000002A3 31C9                    	xor	cx,cx
   906 000002A5 8ED9                            mov     ds,cx           ; set DS=0
   907                                          cnop
   908 000002A7 B700                    	mov	bh,0
   909 000002A9 C1E302                          shl     bx,2            ; index * 4
   910                                  
   911 000002AC 8907                            mov     [bx],ax         ; set offset
   912 000002AE 895702                          mov     [bx+2],dx       ; set segment
   913                                  
   914 000002B1 595B1F                          popm    cx,bx,ds	; register restores
   915 000002B4 C3                              ret                     ; return
   916                                  
   917                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   918                                  ;  cpu_table_init
   919                                  ;
   920                                  ;       call    cpu_table_init
   921                                  ;       dw      <table>         ; table in the Code segment
   922                                  ;       <return here>
   923                                  ;               AX, CX, DX are trashed
   924                                  ;
   925                                  ;
   926                                  ; table:
   927                                  ;       db_lo   <cpu_register>
   928                                  ;       dw      <contents>
   929                                  ;       ...
   930                                  ;       db      0       ; ends table
   931                                  ;
   932                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   933                                          global  cpu_table_init
   934                                  cpu_table_init:
   935                                  ; get the table address
   936 000002B5 89F1                            mov     cx,si           ; save SI
   937 000002B7 5E                              pop     si              ; get the return address
   938 000002B8 2EAD                        cs  lodsw                   ; get the table address
   939 000002BA 56                              push    si              ; save incremented return address
   940 000002BB 51                              push    cx              ; save former SI
   941                                  
   942 000002BC 89C6                            mov     si,ax           ; CS:SI is table pointer
   943 000002BE B6FF                            mov     dh,cpu_relocation>>8
   944                                  .1:
   945 000002C0 2EAC                        cs  lodsb                   ; get low device code
   946 000002C2 84C0                            test    al,al
   947 000002C4 7407                            jz      .9              ; done with table on zero low device code
   948 000002C6 88C2                            mov     dl,al
   949 000002C8 2EAD                        cs  lodsw                   ; get cpu register data
   950 000002CA EF                              out     dx,ax           ; output a full word
   951 000002CB EBF3                            jmp     .1
   952                                  .9:
   953 000002CD 5E                              pop     si              ; restore SI
   954 000002CE C3                              ret                     ;
   955                                  
   956                                  
   957                                  %if 1
   958                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   959                                  ;  C-callable:
   960                                  ;       dword __fastcall divLS(dword dividend, word divisor);
   961                                  ;
   962                                  ;       double word  divided by  word
   963                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   964                                          global  @divLS
   965                                  @divLS:
   966                                          ; DX:AX is dividend
   967                                          ; BX is divisor
   968 000002CF 09D2                            or      dx,dx
   969 000002D1 7505                            jnz     .3
   970 000002D3 F7F3                            div     bx
   971 000002D5 31D2                            xor     dx,dx
   972 000002D7 C3                              ret
   973                                  
   974 000002D8 89C1                    .3:     mov     cx,ax           ; save low dividend in CX
   975 000002DA 89D0                            mov     ax,dx
   976 000002DC 31D2                            xor     dx,dx           ; 0:DX div BX
   977 000002DE F7F3                            div     bx
   978 000002E0 91                              xchg    cx,ax           ; CX is high quotient
   979 000002E1 F7F3                            div     bx
   980 000002E3 89CA                            mov     dx,cx
   981 000002E5 C3                              ret
   982                                  
   983                                  %ifndef HAS_FASTCALL
   984                                          global  _divLS
   985                                  _divLS: push    bp
   986                                          mov     bp,sp
   987                                          mov     ax,ARG(1)
   988                                          mov     dx,ARG(2)
   989                                          mov     bx,ARG(3)
   990                                          call    @divLS
   991                                          leave
   992                                          ret
   993                                  
   994                                          global  _remLS
   995                                  _remLS: push    bp
   996                                          mov     bp,sp
   997                                          mov     ax,ARG(1)
   998                                          mov     dx,ARG(2)
   999                                          mov     bx,ARG(3)
  1000                                          call    @remLS
  1001                                          leave
  1002                                          ret
  1003                                  %endif
  1004                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1005                                  ;  C-callable:
  1006                                  ;       word __fastcall remLS(dword dividend, word divisor);
  1007                                  ;
  1008                                  ;       remainder of:
  1009                                  ;       double word  divided by  word
  1010                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1011                                          global  @remLS
  1012                                  @remLS:
  1013                                          ; DX:AX is dividend
  1014                                          ; BX is divisor
  1015 000002E6 09D2                            or      dx,dx
  1016 000002E8 740A                            jz      .5
  1017 000002EA 89C1                            mov     cx,ax           ; save low dividend in CX
  1018 000002EC 89D0                            mov     ax,dx
  1019 000002EE 31D2                            xor     dx,dx           ; 0:DX div BX
  1020 000002F0 F7F3                            div     bx              ; discard quotient in AX
  1021 000002F2 89C8                            mov     ax,cx           ; restore low dividend
  1022 000002F4 F7F3                    .5:     div     bx
  1023 000002F6 89D0                            mov     ax,dx           ; remainder to AX
  1024 000002F8 C3                              ret
  1025                                  
  1026                                  
  1027                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1028                                  ;  C-callable:
  1029                                  ;       dword __fastcall mulLS(dword factor1, word factor2);
  1030                                  ;
  1031                                  ;       double word  multiplied by  word
  1032                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1033                                  	global	@mulLS
  1034                                  @mulLS:
  1035                                  	; DX:AX is factor1
  1036                                  	; BX is factor2
  1037 000002F9 09D2                            or      dx,dx
  1038 000002FB 7503                            jnz     .1		; dx != 0
  1039 000002FD F7E3                            mul     bx
  1040 000002FF C3                              ret
  1041 00000300 89C1                    .1:     mov     cx,ax           ; save low part of factor1 in CX
  1042 00000302 89D0                            mov     ax,dx
  1043 00000304 F7E3                            mul     bx
  1044 00000306 91                              xchg    cx,ax           ; CX is a product of high part of factor1 and factor2
  1045 00000307 F7E3                            mul	bx
  1046 00000309 01CA                            add     dx,cx
  1047 0000030B C3                              ret
  1048                                  %endif
  1049                                  
  1050                                  
  1051                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1052                                  ;  microsecond
  1053                                  ;       Enter with CX = delay time in microseconds
  1054                                  ;       Exit with CX = 0
  1055                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1056                                          global  @microsecond
  1057                                          global  microsecond
  1058                                  @microsecond:		; C-callable with __fastcall
  1059 0000030C 89C1                    	mov	cx,ax
  1060                                  microsecond:
  1061 0000030E E303                            jcxz    .9
  1062 00000310 90                      .1:     nop		; 4 clocks
  1063 00000311 E2FD                            loop    .1	; 15 clocks	loop is 19 clocks (approx.)
  1064 00000313 C3                      .9:     ret
  1065                                  
  1066                                  
  1067                                  %if 0
  1068                                  ;========================================================================
  1069                                  ; wout - nobody calls it, but unasm defines it as an extenal symbol
  1070                                  ; XXX: Need to recompile unasm and kill it
  1071                                  ;========================================================================
  1072                                  	global	wout
  1073                                  wout:
  1074                                  	ret
  1075                                  %endif
  1076                                  
  1077                                  
  1078                                  %macro  binary  1
  1079                                          mov     ah,%1
  1080                                          shr     ax,4
  1081                                          shr     al,4
  1082                                          aad
  1083                                          mov     %1,al
  1084                                  %endm
  1085                                  
  1086                                  
  1087                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1088                                  ;  ticktime -- set the tick count from the CMOS clock
  1089                                  ;
  1090                                  ;       Preserves all registers
  1091                                  ;
  1092                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1093                                          global  ticktime
  1094                                  ticktime:
  1095 00000314 60                              pushm   ALL
  1096                                  
  1097 00000315 B402                            mov     ah,2            ; get Time
  1098 00000317 CD1A                            int     1Ah
  1099                                  
  1100                                          binary  dh
  1079 00000319 88F4                <1>  mov ah,%1
  1080 0000031B C1E804              <1>  shr ax,4
  1081 0000031E C0E804              <1>  shr al,4
  1082 00000321 D50A                <1>  aad
  1083 00000323 88C6                <1>  mov %1,al
  1101                                          binary  cl
  1079 00000325 88CC                <1>  mov ah,%1
  1080 00000327 C1E804              <1>  shr ax,4
  1081 0000032A C0E804              <1>  shr al,4
  1082 0000032D D50A                <1>  aad
  1083 0000032F 88C1                <1>  mov %1,al
  1102                                          binary  ch
  1079 00000331 88EC                <1>  mov ah,%1
  1080 00000333 C1E804              <1>  shr ax,4
  1081 00000336 C0E804              <1>  shr al,4
  1082 00000339 D50A                <1>  aad
  1083 0000033B 88C5                <1>  mov %1,al
  1103                                  ;       mov     al,ch
  1104 0000033D 88E5                            mov     ch,ah           ; CH = 0
  1105 0000033F B23C                            mov     dl,60           ; 60 min / hr,  60 sec / min
  1106 00000341 F6E2                            mul     dl
  1107 00000343 01C8                            add     ax,cx           ; AX = hr*60 + min
  1108 00000345 88F1                            mov     cl,dh           ; CX = sec
  1109 00000347 88EE                            mov     dh,ch           ; DH = 0
  1110 00000349 F7E2                            mul     dx              ;
  1111 0000034B 01C8                            add     ax,cx
  1112 0000034D 83D200                          adc     dx,0            ; DX:AX = time in seconds
  1113                                  
  1114 00000350 BBFA00                          mov     bx,250
  1115 00000353 89D1                            mov     cx,dx           ; CX:AX is time in seconds
  1116 00000355 F7E3                            mul     bx
  1117 00000357 91                              xchg    ax,cx           ; CX is low result
  1118 00000358 F6E3                            mul     bl
  1119 0000035A 01D0                            add     ax,dx           ; AX:CX is 250*maxseconds
  1120                                  
  1121 0000035C C1E302                          shl     bx,2            ; BX = 1000
  1122 0000035F 91                              xchg    ax,cx           ; CX:AX is 250*maxseconds
  1123 00000360 F7E3                            mul     bx              ; DX:AX is partial product
  1124 00000362 91                              xchg    ax,cx
  1125 00000363 87D3                            xchg    dx,bx           ; BX:CX is partial product
  1126 00000365 F7E2                            mul     dx
  1127 00000367 01D8                            add     ax,bx
  1128 00000369 83D200                          adc     dx,0            ; DX:AX:CX is product
  1129                                  
  1130 0000036C BBA335                          mov     bx,54924/4      ; = 13731       (divisor)
  1131 0000036F F7F3                            div     bx
  1132 00000371 91                              xchg    ax,cx           ; CX is high quotient
  1133 00000372 F7F3                            div     bx              ; CX:AX is quotient, DX is remainder
  1134                                  ; round the result
  1135 00000374 29D3                            sub     bx,dx           ; if DX > BX/2
  1136 00000376 39D3                            cmp     bx,dx           ;
  1137 00000378 7706                            ja      .3
  1138 0000037A 83C001                          add     ax,1
  1139 0000037D 83D100                          adc     cx,0
  1140                                  .3:
  1141 00000380 92                              xchg    ax,dx           ; CX:DX is tick count to set
  1142 00000381 B401                            mov     ah,1
  1143 00000383 CD1A                            int     1Ah             ; set tick count
  1144                                  
  1145 00000385 61                              popm    ALL
  1146 00000386 C3                              ret
  1147                                  
  1148                                  
  1149                                  
  1150                                  
  1151                                  ;========================================================================
  1152                                  
  1153                                  %include        "memory.asm"
  1154                              <1> ;========================================================================
  1155                              <1> ; MEMORY.ASM -- Memory management routines
  1156                              <1> ;========================================================================
  1157                              <1> ;
  1158                              <1> ;   This version is for assembly by  NASM
  1159                              <1> ;
  1160                              <1> ; Copyright (C) 2011   John R. Coffman
  1161                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board
  1162                              <1> ;
  1163                              <1> ; This program is free software: you can redistribute it and/or modify
  1164                              <1> ; it under the terms of the GNU General Public License as published by
  1165                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1166                              <1> ; (at your option) any later version.
  1167                              <1> ;
  1168                              <1> ; This program is distributed in the hope that it will be useful,
  1169                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1170                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1171                              <1> ; GNU General Public License for more details.
  1172                              <1> ;
  1173                              <1> ; You should have received a copy of the GNU General Public License
  1174                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1175                              <1> ;
  1176                              <1> ;========================================================================
  1177                              <1> 
  1178                              <1>         segment         _TEXT
  1179                              <1> 
  1180                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1181                              <1> ;  get_ramsize
  1182                              <1> ;
  1183                              <1> ;       Return the number of 1k blocks of RAM in AX
  1184                              <1> ;
  1185                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1186                              <1> get_ramsize:
  1187 00000387 1E                  <1>         push    ds
  1188 00000388 53                  <1>         push    bx
  1189 00000389 51                  <1>         push    cx
  1190 0000038A 31C0                <1>         xor     ax,ax           ; count of 1k intervals
  1191 0000038C 89C3                <1>         mov     bx,ax           ; segment address
  1192                              <1> .1:
  1193 0000038E 8EDB                <1>         mov     ds,bx           ; set pointer
  1194                              <1>         cnop
  1195 00000390 8B0E0000            <1>         mov     cx,word [0]     ; save contents
  1196 00000394 C70600006CA5        <1>         mov     word [0],0a56ch ; addressing is [DS:0]
  1197 0000039A 89DB                <1>         mov     bx,bx
  1198 0000039C 89C0                <1>         mov     ax,ax           ; waste time
  1199 0000039E 813E00006CA5        <1>         cmp     word [0],0a56ch ; see if it is the same
  1200 000003A4 7524                <1>         jne     .9
  1201 000003A6 890E0000            <1>         mov     word [0],cx     ; restore
  1202 000003AA 8B0EFC03            <1>         mov     cx,word [1020]
  1203 000003AE C706FC03325A        <1>         mov     word [1020],05a32h  ; address [DS:1020]
  1204 000003B4 89C0                <1>         mov     ax,ax
  1205 000003B6 89DB                <1>         mov     bx,bx
  1206 000003B8 813EFC03325A        <1>         cmp     word [1020],05a32h
  1207 000003BE 750A                <1>         jne     .9
  1208 000003C0 890EFC03            <1>         mov     word [1020],cx  ; restore
  1209                              <1> 
  1210                              <1> ; Memory test succeeded at the address
  1211                              <1> 
  1212 000003C4 40                  <1>         inc     ax              ; count 1k
  1213 000003C5 83C340              <1>         add     bx,1024/16      ; increment segment register by paragraphs
  1214 000003C8 EBC4                <1>         jmp     .1
  1215                              <1> 
  1216                              <1> .9:
  1217 000003CA 59                  <1>         pop     cx
  1218 000003CB 5B                  <1>         pop     bx
  1219 000003CC 1F                  <1>         pop     ds
  1220 000003CD C3                  <1>         ret
  1221                              <1> 
  1222                              <1> 
  1223                              <1> 
  1224                              <1> 
  1225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1226                              <1> ;  BIOS_call_11h
  1227                              <1> ;
  1228                              <1> ;       Get Equipment Configuration
  1229                              <1> ;
  1230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1231                              <1> BIOS_call_11h:
  1232 000003CE FB                  <1>         sti
  1233 000003CF 1E                  <1>         push    ds
  1234 000003D0 6A40                <1>         push    bios_data_seg
  1235 000003D2 1F                  <1>         pop     ds
  1236 000003D3 A11000              <1>         mov     ax,[equipment_flag]     ; pick it out of the BDA
  1237 000003D6 1F                  <1>         pop     ds
  1238 000003D7 CF                  <1>         iret
  1239                              <1> 
  1240                              <1> 
  1241                              <1> 
  1242                              <1> 
  1243                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1244                              <1> ;  BIOS_call_12h
  1245                              <1> ;
  1246                              <1> ;       Get Conventional Memory Size
  1247                              <1> ;
  1248                              <1> ;  N.B.:  This BIOS call shares the interrupt vector with Timer 1.
  1249                              <1> ;       Thus we need to see if an "int 12h" called us, otherwise
  1250                              <1> ;       we assume this was a Timer 1 interrupt.
  1251                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1252                              <1> ; stack
  1253                              <1> offset_SI	equ	0
  1254                              <1> offset_DS	equ	offset_SI+2
  1255                              <1> offset_IP       equ     offset_DS+2
  1256                              <1> offset_CS       equ     offset_IP+2
  1257                              <1> offset_FLAGS    equ     offset_CS+2
  1258                              <1> 
  1259                              <1> BIOS_call_12h:
  1260 000003D8 1E                  <1>         push    ds
  1261 000003D9 56                  <1>         push    si
  1262 000003DA 89E6                <1>         mov     si,sp           ; establish stack addressing
  1263 000003DC 36C57404            <1>    ss   lds     si,[offset_IP+si]
  1264                              <1>         cnop
  1265 000003E0 817CFECD12          <1>         cmp     word [si-2],12CDh       ; int 12h
  1266 000003E5 5E                  <1>         pop     si
  1267 000003E6 7404                <1>         je      .4
  1268 000003E8 1F                  <1>         popm	ds
  1269                              <1> ; since the segment is already correct...
  1270                              <1> 	extern	timer1_interrupt
  1271 000003E9 E9(0000)            <1> 	jmp	timer1_interrupt
  1272                              <1> 
  1273 000003EC 6A40                <1> .4:     push    bios_data_seg
  1274 000003EE 1F                  <1>         pop     ds
  1275 000003EF A11300              <1>         mov     ax,[memory_size]
  1276 000003F2 1F                  <1>         pop     ds
  1277 000003F3 CF                  <1>         iret
  1278                              <1> 
  1279                              <1> 
  1280                              <1> 
  1281                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1282                              <1> ;  Memory Test
  1283                              <1> ;       Enter with segment to test in AX
  1284                              <1> ;
  1285                              <1> ;       Return: C=1 if error, (DI==loc)
  1286                              <1> ;               C=0 if no error
  1287                              <1> ;
  1288                              <1> ;       AX, CX, DX, BP, DI, ES are all destroyed
  1289                              <1> ;       DS, BX & SI are preserved
  1290                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1291                              <1> memtest:
  1292 000003F4 5D                  <1>         pop     bp              ; save return address in BP
  1293                              <1> memtest0:                       ; entry to test page 0
  1294 000003F5 FC                  <1>         cld                     ; clear the direction flag
  1295 000003F6 8EC0                <1>         mov     es,ax           ; set segment
  1296 000003F8 31FF                <1>         xor     di,di
  1297 000003FA B85AA5              <1>         mov     ax,0A55Ah       ; alternating bits in alternating bytes
  1298 000003FD B90080              <1>         mov     cx,8000h        ; test 64K (2 x 32K)
  1299 00000400 F3AB                <1>         rep stosw               ;
  1300 00000402 B580                <1>         mov     ch,80h          ; 32K count of words
  1301 00000404 F3AF                <1>         repe scasw
  1302 00000406 754F                <1>         jne     .3
  1303                              <1> 
  1304 00000408 86C4                <1>         xchg    al,ah           ; second pattern
  1305 0000040A B580                <1>         mov     ch,80h          ; 32K count of words
  1306 0000040C F3AB                <1>         rep stosw
  1307 0000040E B580                <1>         mov     ch,80h          ; 32K count of words
  1308 00000410 F3AF                <1>         repe scasw
  1309 00000412 7543                <1>         jne     .3
  1310                              <1> %if 1
  1311                              <1> seed1   equ     47F8h           ; NOT a random value
  1312                              <1>                                 ; Seed values are chosen to have a relatively
  1313                              <1>                                 ; prime cycle length, and to never produce a zero
  1314                              <1>                                 ; Most random values will produce a zero!!!!
  1315                              <1> 
  1316 00000414 B8F847              <1>         mov     ax,seed1        ; seed value (critical)
  1317                              <1>                                 ; cycle is 111 locations, relative prime to 2**15
  1318 00000417 B580                <1>         mov     ch,80h          ; 32K words
  1319                              <1> .t1:
  1320 00000419 268905              <1>     es  mov     [di],ax         ; store the value
  1321 0000041C F7E0                <1>         mul     ax
  1322 0000041E 47                  <1>         inc     di
  1323 0000041F 88E0                <1>         mov     al,ah           ; generate the next bit pattern
  1324 00000421 47                  <1>         inc     di
  1325 00000422 88D4                <1>         mov     ah,dl
  1326                              <1> %if 0
  1327                              <1> .t102:  or      ax,ax           ; trap a bad seed value
  1328                              <1>         jz      .t102
  1329                              <1> %endif
  1330 00000424 E2F3                <1>         loop    .t1             ; fill memory with the pattern
  1331                              <1> 
  1332 00000426 B8F847              <1>         mov     ax,seed1
  1333 00000429 B580                <1>         mov     ch,80h          ; 32K words
  1334                              <1> .t11:
  1335 0000042B 263B05              <1>     es  cmp     ax,[di]
  1336 0000042E 8D7D02              <1>         lea     di,[di+2]       ; don't touch the Zero flag
  1337 00000431 7524                <1>         jne     .3
  1338 00000433 F7E0                <1>         mul     ax
  1339 00000435 88E0                <1>         mov     al,ah
  1340 00000437 88D4                <1>         mov     ah,dl
  1341 00000439 E2F0                <1>         loop    .t11
  1342                              <1> 
  1343                              <1> %endif
  1344 0000043B B8FFFF              <1>         mov     ax,0FFFFh       ; solid pattern of 1's
  1345 0000043E B580                <1>         mov     ch,80h          ; 32K count of words
  1346 00000440 F3AB                <1>         rep stosw
  1347 00000442 B580                <1>         mov     ch,80h          ; 32K count of words
  1348 00000444 F3AF                <1>         repe scasw
  1349 00000446 750F                <1>         jne     .3
  1350                              <1> 
  1351 00000448 31C0                <1>         xor     ax,ax           ; solid pattern of 0's
  1352 0000044A B580                <1>         mov     ch,80h          ; 32K count of words
  1353 0000044C F3AB                <1>         rep stosw
  1354 0000044E B580                <1>         mov     ch,80h          ; 32K count of words
  1355 00000450 F3AF                <1>         repe scasw
  1356 00000452 7503                <1>         jne     .3
  1357                              <1> 
  1358 00000454 F8                  <1>         clc                     ; no error
  1359 00000455 FFE5                <1>         jmp     bp
  1360                              <1> 
  1361                              <1> .3: ; ERROR in scan string
  1362 00000457 4F                  <1>         dec     di
  1363 00000458 263A25              <1>    es   cmp     ah,[di]
  1364 0000045B 7401                <1>         je      .4
  1365 0000045D 4F                  <1>         dec     di
  1366                              <1> .4:
  1367 0000045E F9                  <1>         stc
  1368 0000045F FFE5                <1>         jmp     bp
  1369                              <1> 
  1370                              <1> 
  1371                              <1> 
  1372                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1373                              <1> ; POST_memory -- Power On Self Test of Memory
  1374                              <1> ;
  1375                              <1> ;
  1376                              <1> ;  Enter with:
  1377                              <1> ;       AX = memory limit in kilobytes
  1378                              <1> ;	DS = DGROUP
  1379                              <1> ;	SS = bios_data_seg
  1380                              <1> ;
  1381                              <1> ;  Watch out, "memtest" clobbers segment registers
  1382                              <1> ;
  1383                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1384                              <1> POST_memory:
  1385 00000461 0660                <1>         pushm   ALL,es	; ,ds
  1386 00000463 36813E72003412      <1>     ss	cmp	word [warm_boot],1234h
  1387 0000046A 36C70672007856      <1>     ss 	mov	word [warm_boot],5678h	; non-magic value!!!
  1388 00000471 7507                <1>     	jne	.001
  1389 00000473 1E                  <1> 	push	ds
  1390 00000474 68[5000]            <1> 	push	msg_mem_bypass
  1391 00000477 E99800              <1> 	jmp	.print
  1392                              <1> .001:
  1393 0000047A C1E006              <1>         shl     ax,6                    ; memory size in paragraphs
  1394 0000047D 89C3                <1>         mov     bx,ax                   ; save in BX
  1395                              <1> .1:
  1396 0000047F BA0010              <1>         mov     dx,1000h                ; seg. 0000:xxxx has been tested
  1397 00000482 29D3                <1>         sub     bx,dx
  1398 00000484 7432                <1>         jz      .8                      ; done if down to zero
  1399 00000486 39D3                <1>         cmp     bx,dx
  1400 00000488 7302                <1>         jae     .2
  1401 0000048A 89D3                <1>         mov     bx,dx
  1402                              <1> .2:
  1403 0000048C 53                  <1>         push    bx
  1404                              <1> 
  1405 0000048D 53                  <1>         push    bx
  1406 0000048E 1E                  <1>         push    ds		;DGROUP
  1407 0000048F 68[0000]            <1>         push    msg_mem_test
  1408 00000492 E8(0000)            <1>         call    _cprintf
  1409 00000495 83C406              <1>         add     sp,6
  1410                              <1> 
  1411 00000498 5B                  <1>         pop     bx
  1412 00000499 89D8                <1>         mov     ax,bx                   ; AX is segment tested
  1413 0000049B E856FF              <1>         call    memtest
  1414                              <1> 
  1415                              <1> %if 0
  1416                              <1> ;  induce an error to see printout
  1417                              <1>         mov     di,3465h
  1418                              <1>         stc
  1419                              <1> %endif
  1420 0000049E 73DF                <1>         jnc     .1
  1421                              <1> ; make an error report
  1422                              <1> 
  1423 000004A0 89FA                <1>         mov     dx,di           ; copy byte address
  1424 000004A2 C1EF04              <1>         shr     di,4            ; convert to paragraphs
  1425 000004A5 01DF                <1>         add     di,bx           ; DI is total paragraphs
  1426 000004A7 83E20F              <1>         and     dx,0Fh          ; single-byte byte address
  1427 000004AA 52                  <1>         push    dx
  1428 000004AB 57                  <1>         push    di
  1429 000004AC 1E                  <1>         push    ds		; DGROUP
  1430 000004AD 68[7400]            <1>         push    msg_mem_error
  1431 000004B0 E8(0000)            <1>         call    _cprintf
  1432 000004B3 83C408              <1>         add     sp,8
  1433                              <1> 
  1434 000004B6 EBC7                <1>         jmp     .1
  1435                              <1> 
  1436                              <1> .8:
  1437                              <1> %if SOFT_DEBUG==0
  1438                              <1> ; tested down to 1000:0000
  1439                              <1> ; now do the test at loc. 0  (watch out for the stack)
  1440 000004B8 53                  <1>         push    bx                      ; BX is zero
  1441 000004B9 1E                  <1>         push    ds		; DGROUP
  1442 000004BA 68[0000]            <1>         push    msg_mem_test
  1443 000004BD E8(0000)            <1>         call    _cprintf
  1444 000004C0 83C406              <1>         add     sp,6
  1445                              <1> 
  1446 000004C3 1E9C                <1>         pushm   f,ds
  1447 000004C5 FA                  <1>         cli                             ; disable interrupts
  1448                              <1> 
  1449 000004C6 6A00                <1>         push    0
  1450 000004C8 1F                  <1>         pop     ds                      ; source is 0000:xxxx
  1451 000004C9 680010              <1>         push    1000h
  1452 000004CC 07                  <1>         pop     es                      ; dest. is 1000:xxxx (save area)
  1453 000004CD 31F6                <1>         xor     si,si
  1454 000004CF 31FF                <1>         xor     di,di
  1455 000004D1 B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1456 000004D4 F3A5                <1>         rep movsw
  1457                              <1> 
  1458 000004D6 31C0                <1>         xor     ax,ax
  1459 000004D8 BD[DE04]            <1>         mov     bp,.85
  1460 000004DB E917FF              <1>         jmp     memtest0
  1461                              <1> .85:
  1462                              <1> %if 0
  1463                              <1>         stc
  1464                              <1>         mov     di,8765h                ; force error reporting
  1465                              <1> %endif
  1466 000004DE 19D2                <1>         sbb     dx,dx                   ; grab the returned carry
  1467 000004E0 89FB                <1>         mov     bx,di                   ; save error location
  1468                              <1> 
  1469 000004E2 680010              <1>         push    1000h                   ; source is 1000:xxxx
  1470 000004E5 1F                  <1>         pop     ds
  1471 000004E6 6A00                <1>         push    0
  1472 000004E8 07                  <1>         pop     es                      ; restore 0000:xxxx
  1473 000004E9 31F6                <1>         xor     si,si
  1474 000004EB 31FF                <1>         xor     di,di
  1475 000004ED B90080              <1>         mov     cx,8000h                ; 32k words == 64K bytes
  1476 000004F0 F3A5                <1>         rep movsw
  1477                              <1> 
  1478 000004F2 1E                  <1>         push    ds
  1479 000004F3 07                  <1>         pop     es
  1480 000004F4 31C0                <1>         xor     ax,ax
  1481 000004F6 B580                <1>         mov     ch,80h                  ; re-zero 1000:0000 ...
  1482 000004F8 F3AB                <1>         rep stosw
  1483                              <1> 
  1484 000004FA 9D1F                <1>         popm    f,ds
  1485                              <1> %endif
  1486 000004FC D1EA                <1>         shr     dx,1                    ; set the carry
  1487 000004FE 730E                <1>         jnc     .89
  1488                              <1> 
  1489                              <1> ; make the page 0 error report
  1490 00000500 53                  <1>         push    bx
  1491 00000501 1E                  <1>         push    ds			; DGROUP
  1492 00000502 68[9200]            <1>         push    msg_mem_error0
  1493 00000505 E8(0000)            <1>         call    _cprintf
  1494 00000508 83C406              <1>         add     sp,6
  1495                              <1> 
  1496 0000050B F4                  <1> .88:    hlt
  1497 0000050C EBFD                <1>         jmp     .88
  1498                              <1> 
  1499                              <1> .89:
  1500 0000050E 1E                  <1>         push    ds			; DGROUP
  1501 0000050F 68[2000]            <1>         push    msg_mem_done
  1502                              <1> .print:
  1503 00000512 E8(0000)            <1>         call    _cprintf
  1504 00000515 83C404              <1>         add     sp,4
  1505                              <1> .9:
  1506 00000518 6107                <1>         popm    ALL,es ; ,ds
  1507 0000051A C3                  <1>         ret
  1508                              <1> 
  1509                              <1> 
  1510                              <1>         segment CONST
  1511                              <1> msg_mem_test:
  1512 00000000 0D2538615465737469- <1>         db      CR,"%8aTesting memory at %7a%04x:0",NUL
  1512 00000009 6E67206D656D6F7279- <1>
  1512 00000012 206174202537612530- <1>
  1512 0000001B 34783A3000          <1>
  1513                              <1> msg_mem_done:
  1514 00000020 0D253261502E4F2E53- <1>         db      CR,"%2aP.O.S.T. of memory %10aSUCCESSFUL        "
  1514 00000029 2E542E206F66206D65- <1>
  1514 00000032 6D6F72792025313061- <1>
  1514 0000003B 535543434553534655- <1>
  1514 00000044 4C2020202020202020  <1>
  1515                              <1> msg_mem_double:
  1516 0000004D 0A0A00              <1>         db      NL,NL,NUL
  1517                              <1> msg_mem_bypass:
  1518 00000050 0D253861502E4F2E53- <1> 	db	CR,"%8aP.O.S.T. of memory BYPASSED  ",NL,NL,NUL
  1518 00000059 2E542E206F66206D65- <1>
  1518 00000062 6D6F72792042595041- <1>
  1518 0000006B 5353454420200A0A00  <1>
  1519                              <1> msg_mem_error:
  1520 00000074 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at %04x%x",NL,NUL
  1520 0000007D 6F7279206572726F72- <1>
  1520 00000086 206174202530347825- <1>
  1520 0000008F 780A00              <1>
  1521                              <1> msg_mem_error0:
  1522 00000092 070A253134614D656D- <1>         db      BEL,NL,"%14aMemory error at 0%04x",NL,NL
  1522 0000009B 6F7279206572726F72- <1>
  1522 000000A4 206174203025303478- <1>
  1522 000000AD 0A0A                <1>
  1523 000000AF 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL
  1523 000000B8 2A2A2A2A2A2A2A2A2A- <1>
  1523 000000C1 2A2A2A2A2A2A2A2A0A  <1>
  1524 000000CA 2A2020202020434154- <1>         db      "*     CATASTROPHE!!!     *",NL
  1524 000000D3 415354524F50484521- <1>
  1524 000000DC 212120202020202A0A  <1>
  1525 000000E5 2A2A2A2A2A2A2A2A2A- <1>         db      "**************************",NL,NL
  1525 000000EE 2A2A2A2A2A2A2A2A2A- <1>
  1525 000000F7 2A2A2A2A2A2A2A2A0A- <1>
  1525 00000100 0A                  <1>
  1526 00000101 48616C74696E672064- <1>         db      "Halting due to error in segment 0000:xxxx",BEL,NL
  1526 0000010A 756520746F20657272- <1>
  1526 00000113 6F7220696E20736567- <1>
  1526 0000011C 6D656E742030303030- <1>
  1526 00000125 3A78787878070A      <1>
  1527 0000012C 00                  <1>         db      NUL
  1528 0000012D 00                  <1> 	db	0
  1154                                  %include        "ds1302.asm"
  1155                              <1> 	;========================================================================
  1156                              <1> 	; DS1302.ASM - - support on the SBC - 188 for the DS1302 chip
  1157                              <1> 	;========================================================================
  1158                              <1> 	;
  1159                              <1> 	; This version is for assembly by NASM 2.08
  1160                              <1> 	;
  1161                              <1> 	; Copyright (C) 2010 John R. Coffman
  1162                              <1> 	; Provided for hobbyist use on the N8VEM SBC - 188 board
  1163                              <1> 	;
  1164                              <1> 	; This program is free software: you can redistribute it and / or modify
  1165                              <1> 	; it under the terms of the GNU General Public License as published by
  1166                              <1> 	; the Free Software Foundation, either version 3 of the License, or
  1167                              <1> 	; (at your option) any later version.
  1168                              <1> 	;
  1169                              <1> 	; This program is distributed in the hope that it will be useful,
  1170                              <1> 	; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1171                              <1> 	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
  1172                              <1> 	; GNU General Public License for more details.
  1173                              <1> 	;
  1174                              <1> 	; You should have received a copy of the GNU General Public License
  1175                              <1> 	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
  1176                              <1> 	;
  1177                              <1> 	; Updated for the Duodyne 80c188 SBC
  1178                              <1> 	;========================================================================
  1179                              <1> 
  1180                              <1> 	segment _TEXT
  1181                              <1> 
  1182                              <1> 	rtc_data equ 80H             ; Data mask bit
  1183                              <1> 	rtc_wren equ 20H             ; Write enable bit
  1184                              <1> 	rtc_clk equ 40H              ; Clock signal
  1185                              <1> 	rtc_ce equ 10H               ; ce bit
  1186                              <1> 
  1187                              <1> 
  1188                              <1> 	; global _rtc_reset
  1189                              <1> rtc_reset:
  1190 0000051B BA9404              <1> 	mov dx, RTC                  ; set the device code
  1191 0000051E B010                <1> 	mov al, rtc_ce               ;
  1192 00000520 EB05                <1> 	jmp rtc_out
  1193                              <1> 
  1194                              <1> 
  1195                              <1> 	global _rtc_reset_off
  1196                              <1> rtc_reset_off:
  1197 00000522 BA9404              <1> 	mov dx, RTC
  1198 00000525 B000                <1> 	mov al, 0                    ;
  1199                              <1> rtc_out:
  1200 00000527 EE                  <1> 	out dx, al
  1201 00000528 B91000              <1> 	mov cx, 16
  1202 0000052B E9E0FD              <1> 	jmp microsecond              ; delay 16 us
  1203                              <1> 
  1204                              <1> rtc_outs:
  1205 0000052E EE                  <1> 	out dx, al
  1206 0000052F B90100              <1> 	mov cx, 1
  1207 00000532 E9D9FD              <1> 	jmp microsecond              ; delay 16 us
  1208                              <1> 
  1209                              <1> 	; global @rtc_write
  1210                              <1> @rtc_write:
  1211                              <1> rtc_write:
  1212 00000535 53                  <1> 	push bx
  1213                              <1> 
  1214 00000536 BA9404              <1> 	mov dx, RTC
  1215 00000539 88C3                <1> 	mov bl, al                   ; save data in BL
  1216 0000053B B408                <1> 	mov ah, 8                    ; set loop count
  1217                              <1> .1:
  1218 0000053D D0EB                <1> 	shr bl, 1                    ; data bit to Carry
  1219 0000053F 7311                <1> 	jnc .2
  1220 00000541 B090                <1> 	mov al,  rtc_ce | rtc_data   ; send '1'
  1221 00000543 E8E8FF              <1> 	call rtc_outs                ; put out the data
  1222 00000546 B0D0                <1> 	mov al, rtc_clk | rtc_ce | rtc_data     ; send '1'
  1223 00000548 E8DCFF              <1> 	call rtc_out                 ; put out the data
  1224 0000054B B090                <1>        	mov al, rtc_ce | rtc_data     ; send '1'
  1225 0000054D E8D7FF              <1> 	call rtc_out                 ; put out the data
  1226                              <1> 
  1227 00000550 EB0F                <1> 	jmp .3
  1228                              <1> .2:
  1229 00000552 B010                <1> 	mov al, rtc_ce               ; send '0'
  1230 00000554 E8D7FF              <1> 	call rtc_outs                ; put out the data
  1231 00000557 B050                <1> 	mov al, rtc_clk |rtc_ce      ; send '0'
  1232 00000559 E8CBFF              <1> 	call rtc_out                 ; put out the data
  1233 0000055C B010                <1>       	mov al, rtc_ce               ; send '0'
  1234 0000055E E8C6FF              <1> 	call rtc_out                 ; put out the data
  1235                              <1> 
  1236                              <1> .3:
  1237 00000561 FECC                <1> 	dec ah                       ; count a bit
  1238 00000563 75D8                <1> 	jnz .1
  1239                              <1> 
  1240                              <1> 	; rtc_write ends with the clock high
  1241 00000565 5B                  <1> 	pop bx
  1242 00000566 C3                  <1> 	ret
  1243                              <1> 
  1244                              <1> 
  1245                              <1> 
  1246                              <1> 
  1247                              <1> rtc_read:
  1248 00000567 53                  <1> 	push bx
  1249                              <1> 
  1250 00000568 BA9404              <1> 	mov dx, RTC
  1251 0000056B B308                <1> 	mov bl, 8                    ; bit count
  1252                              <1> .1:
  1253 0000056D B030                <1> 	mov al, rtc_ce | rtc_wren
  1254 0000056F E8B5FF              <1> 	call rtc_out
  1255                              <1> 	; delay was included in the above output call
  1256 00000572 EC                  <1> 	in al, dx                    ; read a bit
  1257 00000573 D1C8                <1> 	ror ax, 1                    ; rotate data into AH
  1258 00000575 B070                <1> 	mov al, rtc_clk | rtc_ce | rtc_wren     ; set to clock next data bit
  1259 00000577 E8ADFF              <1> 	call rtc_out
  1260 0000057A FECB                <1> 	dec bl
  1261 0000057C 75EF                <1> 	jnz .1
  1262                              <1> 
  1263 0000057E C1E808              <1> 	shr ax, 8                    ; return data in AL, AH=0
  1264                              <1> 
  1265 00000581 5B                  <1> 	pop bx
  1266 00000582 C3                  <1> 	ret
  1267                              <1> 
  1268                              <1> 
  1269                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1270                              <1> 	; rtc_get_loc RTC get location as addressed
  1271                              <1> 	; Enter with AL = address of the location to get
  1272                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1273                              <1> 	; Exit with data in AL
  1274                              <1> 	; All other registers are preserved
  1275                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1276                              <1> 	global @rtc_get_loc
  1277                              <1> 	global rtc_get_loc
  1278                              <1> @rtc_get_loc:
  1279                              <1> rtc_get_loc:
  1280 00000583 52                  <1> 	push dx
  1281 00000584 51                  <1> 	push cx                      ; 3 register saves
  1282 00000585 53                  <1> 	push bx
  1283                              <1> 
  1284 00000586 08E4                <1> 	or ah, ah                    ; test flag
  1285 00000588 7402                <1> 	jz .1
  1286 0000058A B440                <1> 	mov ah, 040h                 ; RAM flag
  1287 0000058C 88E7                <1> .1:     mov bh, ah                   ; save flag in BH
  1288 0000058E 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1289 00000590 00C0                <1> 	add al, al                   ; shift left
  1290 00000592 08C7                <1> 	or bh, al                    ; form command
  1291 00000594 80CF81              <1> 	or bh, 81h                   ; Clock Command / READ bit = 01h
  1292                              <1> 
  1293 00000597 BA9404              <1> 	mov dx, RTC
  1294 0000059A E885FF              <1> 	call rtc_reset_off
  1295 0000059D E87BFF              <1> 	call rtc_reset               ; signal that a command is coming
  1296 000005A0 88F8                <1> 	mov al, bh
  1297 000005A2 E890FF              <1> 	call rtc_write               ; write out the command
  1298 000005A5 E8BFFF              <1> 	call rtc_read                ; read the data location
  1299 000005A8 50                  <1> 	push ax                      ; save the result
  1300 000005A9 E86FFF              <1> 	call rtc_reset
  1301 000005AC E873FF              <1> 	call rtc_reset_off           ; and finish up
  1302                              <1> 
  1303 000005AF 58                  <1> 	pop ax                       ; return value
  1304                              <1> 
  1305 000005B0 5B                  <1> 	pop bx
  1306 000005B1 59                  <1> 	pop cx                       ; plus 3 register restores
  1307 000005B2 5A                  <1> 	pop dx
  1308 000005B3 C3                  <1> 	ret
  1309                              <1> 
  1310                              <1> 
  1311                              <1> 
  1312                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1313                              <1> 	; rtc_set_loc RTC set location as addressed
  1314                              <1> 	; Enter with AL = address of the location to set
  1315                              <1> 	; AH = Flag RAM / clock (RAM=!0, clock=0)
  1316                              <1> 	; DL = data to write to location
  1317                              <1> 	; AX is undefined on return
  1318                              <1> 	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1319                              <1> 	global @rtc_set_loc
  1320                              <1> 	global rtc_set_loc
  1321                              <1> @rtc_set_loc:
  1322                              <1> rtc_set_loc:
  1323 000005B4 52                  <1> 	push dx
  1324 000005B5 51                  <1> 	push cx                      ; 3 register saves
  1325 000005B6 53                  <1> 	push bx
  1326                              <1> 
  1327 000005B7 52                  <1> 	push dx                      ; save data
  1328                              <1> 
  1329 000005B8 08E4                <1> 	or ah, ah                    ; test flag
  1330 000005BA 7402                <1> 	jz .1
  1331 000005BC B440                <1> 	mov ah, 040h                 ; RAM flag
  1332 000005BE 88E7                <1> .1: mov bh, ah                ; save flag in BH
  1333 000005C0 241F                <1> 	and al, 31                   ; mask address to 5 bits
  1334 000005C2 00C0                <1> 	add al, al                   ; shift left
  1335 000005C4 08C7                <1> 	or bh, al                    ; form command
  1336 000005C6 80CF80              <1> 	or bh, 80h                   ; Clock Command / WRITE bit = 00h
  1337                              <1> 
  1338 000005C9 BA9404              <1> 	mov dx, RTC
  1339 000005CC E853FF              <1> 	call rtc_reset_off
  1340 000005CF E849FF              <1> 	call rtc_reset               ; signal that a command is coming
  1341 000005D2 88F8                <1> 	mov al, bh                   ; command to AL
  1342 000005D4 E85EFF              <1> 	call rtc_write               ; write out the command
  1343 000005D7 58                  <1> 	pop ax                       ; get the data value
  1344 000005D8 E85AFF              <1> 	call rtc_write               ; write the data
  1345 000005DB E83DFF              <1> 	call rtc_reset               ; end of command
  1346 000005DE E841FF              <1> 	call rtc_reset_off
  1347                              <1> 
  1348 000005E1 5B                  <1> 	pop bx
  1349 000005E2 59                  <1> 	pop cx                       ; plus 3 register restores
  1350 000005E3 5A                  <1> 	pop dx
  1351 000005E4 C3                  <1> 	ret
  1155                                  
  1156                                  %if SOFT_DEBUG+1
  1157                                          global  lites
  1158                                  ; call with:
  1159                                  ;       push    code    ; code in AL
  1160                                  ;       call    lites
  1161                                  ;
  1162 000005E5 55                      lites:  push    bp
  1163 000005E6 89E5                            mov     bp,sp           ; establish stack frame
  1164 000005E8 5250                            pushm   ax,dx
  1165 000005EA 8A4604                          mov     al,[bp+4]
  1166 000005ED BA3006                          mov     dx,FRONT_PANEL_LED
  1167 000005F0 EE                              out     dx,al
  1168 000005F1 585A                            popm    ax,dx
  1169 000005F3 5D                              pop     bp
  1170 000005F4 C20200                          ret     2               ; remove argument
  1171                                  %endif
  1172                                  
  1173                                  %if 0
  1174                                  ; _FPSIGNAL:
  1175                                  ;   Enter with AL = condensed error code
  1176                                  ;
  1177                                  	global	_FPSIGNAL
  1178                                  _FPSIGNAL:
  1179                                  	xor	ah,ah
  1180                                  	push	ax
  1181                                  	push	DGROUP
  1182                                  	push	msg_fpu_err
  1183                                  	call	_cprintf
  1184                                  	add	sp,6
  1185                                  	ret
  1186                                  %endif
  1187                                  
  1188                                  
  1189                                  
  1190                                  
  1191                                  ident3:
  1192                                  %if SOFT_DEBUG
  1193                                          db      NL
  1194                                  	db	"%7a"
  1195                                          db      "             ***** SOFT BIOS *****"
  1196                                          db      NL
  1197                                  %endif
  1198                                  %ifdef __DATE__
  1199                                  %ifdef __TIME__
  1200 000005F7 0A                              db      NL
  1201 000005F8 25313461                	db	"%14a"
  1202 000005FC 546869732042494F53-             db      "This BIOS copy was built at ",__TIME__," ",TIMEZONE
  1202 00000605 20636F707920776173-
  1202 0000060E 206275696C74206174-
  1202 00000617 2031393A30303A3030-
  1202 00000620 20435354           
  1203 00000624 206F6E20323032342D-             db      " on ", __DATE__
  1203 0000062D 31312D3234         
  1204                                  %endif
  1205                                  %endif
  1206 00000632 2E2020202020202020-             db      ".                    [%d]",NL
  1206 0000063B 202020202020202020-
  1206 00000644 2020205B25645D0A   
  1207 0000064C 00                              db      0
  1208                                  
  1209                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1210                                  ;  This is the banner which prints out first.
  1211                                  ;  The letters are variable width; B is wide; -, and 1 are kerned.
  1212                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1213                                  ident1:
  1214 0000064D 0A253961                        db      NL,"%9a"
  1215 00000651 20205F5F5F5F5F2020-             DB      "  _____                  _ ",	NL
  1215 0000065A 202020202020202020-
  1215 00000663 202020202020205F20-
  1215 0000066C 0A                 
  1216 0000066D 207C20205F5F205C20-             DB      " |  __ \                | |",	NL
  1216 00000676 202020202020202020-
  1216 0000067F 2020202020207C207C-
  1216 00000688 0A                 
  1217 00000689 207C207C20207C207C-             DB      " | |  | |_   _  ___   __| |_   _ _ __   ___ ",	NL
  1217 00000692 5F2020205F20205F5F-
  1217 0000069B 5F2020205F5F7C207C-
  1217 000006A4 5F2020205F205F205F-
  1217 000006AD 5F2020205F5F5F200A 
  1218 000006B6 207C207C20207C207C-             DB      " | |  | | | | |/ _ \ / _` | | | | '_ \ / _ \ ",	NL
  1218 000006BF 207C207C207C2F205F-
  1218 000006C8 205C202F205F60207C-
  1218 000006D1 207C207C207C20275F-
  1218 000006DA 205C202F205F205C20-
  1218 000006E3 0A                 
  1219 000006E4 207C207C5F5F7C207C-             DB      " | |__| | |_| | (_) | (_| | |_| | | | |  __/",	NL
  1219 000006ED 207C5F7C207C20285F-
  1219 000006F6 29207C20285F7C207C-
  1219 000006FF 207C5F7C207C207C20-
  1219 00000708 7C207C20205F5F2F0A 
  1220 00000711 207C5F5F5F5F5F2F20-             DB      " |_____/ \__,_|\___/ \__,_|\__, |_| |_|\___|",	NL
  1220 0000071A 5C5F5F2C5F7C5C5F5F-
  1220 00000723 5F2F205C5F5F2C5F7C-
  1220 0000072C 5C5F5F2C207C5F7C20-
  1220 00000735 7C5F7C5C5F5F5F7C0A 
  1221 0000073E 202020203830633138-             DB      "    80c188 pcb              __/ |  rev. ", VERSION, NL
  1221 00000747 382070636220202020-
  1221 00000750 202020202020202020-
  1221 00000759 205F5F2F207C202072-
  1221 00000762 65762E20332E352D44-
  1221 0000076B 0A                 
  1222 0000076C 202020202020202020-             DB      "                           |___/   of   ", DATE, NL
  1222 00000775 202020202020202020-
  1222 0000077E 202020202020202020-
  1222 00000787 7C5F5F5F2F2020206F-
  1222 00000790 6620202032372D4F63-
  1222 00000799 742D323032340A     
  1223 000007A0 202020202020202020-             db      "                                   ("
  1223 000007A9 202020202020202020-
  1223 000007B2 202020202020202020-
  1223 000007BB 202020202020202028 
  1224                                  %if ANSI
  1225 000007C4 414E5349                        db      "ANSI"
  1226                                  %elif DUMB
  1227                                          db      "dumb"
  1228                                  %elif TTY
  1229                                          db      "tty"
  1230                                  %else
  1231                                          db      "???"
  1232                                  %endif
  1233 000007C8 290A                            db      ")",NL
  1234                                  
  1235 000007CA 00                      	db      0
  1236                                  
  1237                                  
  1238 000007CB 90<rep 5h>              	align	16
  1239                                  
  1240                                  bulk_of_code_end        equ     $
  1241                                  
  1242                                  
  1243                                  
  1244                                          segment CONST
  1245                                  
  1246                                          global  _bios_data_area_ptr
  1247                                  _bios_data_area_ptr:
  1248 0000012E 00004000                        dw      0000h,bios_data_seg     ; pointer 40:0
  1249                                  
  1250                                  
  1251                                  msg_cpu_memory:
  1252 00000132 253135612564257320-     	db	"%15a%d%s %2aMhz CPU clock, %15a%u%2aK memory installed"
  1252 0000013B 2532614D687A204350-
  1252 00000144 5520636C6F636B2C20-
  1252 0000014D 253135612575253261-
  1252 00000156 4B206D656D6F727920-
  1252 0000015F 696E7374616C6C6564 
  1253 00000168 0A00                    	db	NL, 0
  1254                                  msg_cpu_clock_05:
  1255 0000016A 2E3500                  	db	".5", 0
  1256                                  msg_cpu_clock_00:
  1257 0000016D 00                      	db	0
  1258                                  msg_setup:
  1259 0000016E 507265737320277327-     	db	"Press 's' to run NVRAM setup...", NL, 0
  1259 00000177 20746F2072756E204E-
  1259 00000180 5652414D2073657475-
  1259 00000189 702E2E2E0A00       
  1260                                  msg_nvram_bad:
  1261 0000018F 4E5652414D20636865-     	db	"NVRAM checksum is invalid, running setup", NL, 0
  1261 00000198 636B73756D20697320-
  1261 000001A1 696E76616C69642C20-
  1261 000001AA 72756E6E696E672073-
  1261 000001B3 657475700A00       
  1262                                  msg_floppy:
  1263 000001B9 4E6F7720696E697469-     	db	"Now initializing floppy", NL, 0
  1263 000001C2 616C697A696E672066-
  1263 000001CB 6C6F7070790A00     
  1264                                  %if 0
  1265                                  msg_fpu_err:
  1266                                  	db	NL, "EM187 has signalled error 0x%02x.", NL, 0
  1267                                  %endif
  1268                                  msg_booting:
  1269 000001D2 547279696E6720746F-     	db	"Trying to boot from drive %c: ", 0
  1269 000001DB 20626F6F742066726F-
  1269 000001E4 6D2064726976652025-
  1269 000001ED 633A2000           
  1270                                  msg_boot_err:
  1271 000001F1 4469736B2072656164-     	db	"Disk read failed  AX=%04x", NL, 0
  1271 000001FA 206661696C65642020-
  1271 00000203 41583D253034780A00 
  1272                                  msg_no_boot:
  1273 0000020C 426F6F74207369676E-     	db	"Boot signature not found", NL, 0
  1273 00000215 6174757265206E6F74-
  1273 0000021E 20666F756E640A00   
  1274                                  msg_no_loader:
  1275 00000226 4D617374657220626F-     	db	"Master boot loader not found", NL, 0
  1275 0000022F 6F74206C6F61646572-
  1275 00000238 206E6F7420666F756E-
  1275 00000241 640A00             
  1276                                  msg_boot_ok:
  1277 00000244 4F4B0A00                	db	"OK", NL, 0
  1278                                  msg_cpm_disk:
  1279 00000248 6E6F207369676E6174-             db      "no signature check ", 0
  1279 00000251 75726520636865636B-
  1279 0000025A 2000               
  1280                                  msg_alt_disk:
  1281 0000025C 4D494E495820626F6F-     	db	"MINIX boot signature ",0
  1281 00000265 74207369676E617475-
  1281 0000026E 72652000           
  1282                                  
  1283                                  
  1284                                  
  1285                                  %if TBASIC
  1286                                  %else
  1287                                  msg_no_basic:
  1288                                  	db	"No ROM Basic. Please implement one :-)", NL
  1289                                  	db	"Press any key to try again...", NL, 0
  1290                                  %endif
  1291                                  
  1292                                  
  1293                                  %if SOFT_DEBUG
  1294                                  	global	cout,bout,wout,boutsp,crlf
  1295                                  ; NewLine
  1296                                  crlf:
  1297                                  	mov	al,0Dh
  1298                                  	call	cout
  1299                                  	mov	al,0Ah
  1300                                  	call	cout
  1301                                  	ret
  1302                                  
  1303                                  
  1304                                  ; output byte from AL, then a space
  1305                                  boutsp:
  1306                                  	call	bout
  1307                                  	mov	al,20h
  1308                                  	call	cout
  1309                                  	ret
  1310                                  ; word output from AX
  1311                                  wout:
  1312                                  	xchg	al,ah
  1313                                  	call	bout
  1314                                  	xchg	al,ah
  1315                                  ; byte output from AL
  1316                                  bout:
  1317                                  	rol	al,4
  1318                                  	call	nout
  1319                                  	rol	al,4
  1320                                  ; nibble output from low nibble in AL
  1321                                  nout:
  1322                                  	push	ax
  1323                                  	and	al,0Fh		; mask nibble
  1324                                  	daa			; convert to decimal
  1325                                  	add	al,0F0h		; overflow to Carry
  1326                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1327                                  	call	cout
  1328                                  	pop	ax
  1329                                  	ret
  1330                                  
  1331                                  ; character output from AL
  1332                                  cout:
  1333                                  %if 0
  1334                                  	pushm	ax,bx
  1335                                  	mov	ah,0Eh		; write character in AL
  1336                                  	mov	bx,0007h
  1337                                  	int	10h
  1338                                  	popm	ax,bx
  1339                                  %else
  1340                                  THRE	EQU	1<<5		; Transmit holding register empty
  1341                                  	pushm	ax,dx
  1342                                  .1:	mov	dx,uart_lsr
  1343                                  	in	al,dx
  1344                                  	test	al,THRE
  1345                                  	jz	.1
  1346                                  	mov	dx,uart_thr
  1347                                  	popm	ax
  1348                                  	out	dx,al
  1349                                  	popm	dx
  1350                                  %endif
  1351                                  	ret
  1352                                  %endif
