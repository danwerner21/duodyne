     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; MISC15.ASM -- Miscellaneous BIOS calls (mostly int 15h)
     3                                  ;  with mods for version -45 assembly
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ; Updated for the Duodyne 80c188 SBC
    25                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                                  %include        "config.asm"
    27                              <1> ;/*
    28                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                              <1> ; ANSI.CFG
    30                              <1> ;   Copied to CONFIG.ASM for general release.
    31                              <1> ;
    32                              <1> ;       Modify the parameters below to reflect your system
    33                              <1> ;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    38                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ;
    41                              <1> ; Define the serial terminal that the Video BIOS must emulate
    42                              <1> ; Set one of the following to 1
    43                              <1> ; If you have no idea what to choose, set TTY to 1
    44                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    45                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    46                              <1> ANSI    equ     1       ; very smart, like a VT-100
    47                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    48                              <1> ; others may get added in the future
    49                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    50                              <1> ;
    51                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    52                              <1> ;UART_RATE	equ	0		; 1200
    53                              <1> ;UART_RATE	equ	1		; 2400
    54                              <1> ;UART_RATE	equ	2		; 4800
    55                              <1> UART_RATE	equ	3		; 9600
    56                              <1> ;UART_RATE	equ	4		; 19200
    57                              <1> ;UART_RATE	equ	5		; 38400
    58                              <1> ;UART_RATE	equ	6		; 57600
    59                              <1> ;UART_RATE	equ	7		; 115200
    60                              <1> 
    61                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    62                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    63                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    64                              <1> 						; but not ANSI
    65                              <1> ; Define the size of the ROM image on the system in Kilobytes
    66                              <1> ; It may be smaller than the actual EPROM in use.
    67                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    68                              <1> %ifndef ROM
    69                              <1> ROM             equ     32              ; 64 is the default
    70                              <1> %endif
    71                              <1> 
    72                              <1> ; Define the number of Wait States at which the ROM operates
    73                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    74                              <1> 
    75                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    76                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    77                              <1> RAM_DOS         equ     640
    78                              <1> 
    79                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    80                              <1> ; the default is 512 kilobytes
    81                              <1> RAM             equ     512             ; (512 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States at which the RAM operates
    84                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    87                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    88                              <1> 
    89                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    90                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    91                              <1> 
    92                              <1> ; Define the time zone in which we build the Relocatable BIOS
    93                              <1> %ifndef TIMEZONE
    94                              <1> %define TIMEZONE "CST"
    95                              <1> %endif
    96                              <1> 
    97                              <1> ; Has the REDBUG debugger been loaded?
    98                              <1> %ifndef SOFT_DEBUG
    99                              <1> %define SOFT_DEBUG 0
   100                              <1> %endif
   101                              <1> 
   102                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   103                              <1> %ifndef TBASIC
   104                              <1> TBASIC          equ     1		; default is 1
   105                              <1> %endif
   106                              <1> 
   107                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   108                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   109                              <1> %ifndef FPEM
   110                              <1> FPEM            equ     1               ; default is 1
   111                              <1> %endif
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Define the UART oscillator speed
   128                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   129                              <1> 
   130                              <1> 
   131                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   132                              <1> ; end of the User configuration
   133                              <1> ;       Do Not modify anything below this point
   134                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   135                              <1> 
   136                              <1> ; Define existence of any uart chip
   137                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   138                              <1> startuplength   equ     512                     ; may be up to 1024
   139                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   140                              <1> highrom         equ     (ROM*400h)&0FFFFh
   141                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   142                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   143                              <1> 
   144                              <1> 
   145                              <1> %define ARG(n) [bp+2+(n)*2]
   146                              <1> 
   147                              <1> %macro  check   1.nolist
   148                              <1>  %if (%1)
   149                              <1>    %error Check Failure: %1
   150                              <1>  %endif
   151                              <1> %endm
   152                              <1> %macro  range   3.nolist
   153                              <1>  %if (%1)<(%2)
   154                              <1>    %error Out of Range: %1
   155                              <1>  %elif (%1)>(%3)
   156                              <1>    %error Out of Range: %1
   157                              <1>  %endif
   158                              <1> %endm
   159                              <1> _terminal equ UART
   160                              <1>  check   RAM_DOS&15
   161                              <1>  check   RAM&(RAM-1)
   162                              <1>  check   ROM&(ROM-1)
   163                              <1>  range   RAM,32,512
   164                              <1>  range   ROM,32,256
   165                              <1>  range   RAM_WS,0,3
   166                              <1>  range   ROM_WS,0,3
   167                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   168                              <1>  range   LCL_IO_WS,0,3
   169                              <1>  range   BUS_IO_WS,0,3
   170                              <1>  range   UART_OSC,500000,16000000
   171                              <1>  range   UART_RATE,0,7
   172                              <1>  range	 UART,0,1
   173                              <1>  range	 _terminal,1,2
   174                              <1> 
   175                              <1> %ifndef SOFT_DEBUG
   176                              <1> %define SOFT_DEBUG 0
   177                              <1> %endif
   178                              <1> 
   179                              <1> %ifndef TRACE
   180                              <1> %define TRACE 0
   181                              <1> %endif
   182                              <1> 
   183                              <1> %ifdef MAKE_OBJECT_FILE
   184                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   185                              <1>         export _ROMsize
   186                              <1>         export _CHIPsize
   187                              <1> _ROMsize        dw      ROM
   188                              <1> _CHIPsize       dw      CHIP
   189                              <1> %endif
   190                              <1> ; end of the Hardware configuration file
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> ;*/
    27                                  %include        "cpuregs.asm"
    28                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                              <1> ; CPUREGS.ASM
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ;
    32                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    33                              <1> ;
    34                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    35                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    36                              <1> ;
    37                              <1> ; This program is free software: you can redistribute it and/or modify
    38                              <1> ; it under the terms of the GNU General Public License as published by
    39                              <1> ; the Free Software Foundation, either version 3 of the License, or
    40                              <1> ; (at your option) any later version.
    41                              <1> ;
    42                              <1> ; This program is distributed in the hope that it will be useful,
    43                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    44                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    45                              <1> ; GNU General Public License for more details.
    46                              <1> ;
    47                              <1> ; You should have received a copy of the GNU General Public License
    48                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    49                              <1> ;
    50                              <1> ; Updated for the Duodyne 80c188 SBC
    51                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <1> %include	"macros.inc"
    53                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                              <2> ; MACROS.INC  
    55                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                              <2> ;
    57                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    58                              <2> ;
    59                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    60                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    61                              <2> ;
    62                              <2> ; This program is free software: you can redistribute it and/or modify
    63                              <2> ; it under the terms of the GNU General Public License as published by
    64                              <2> ; the Free Software Foundation, either version 3 of the License, or
    65                              <2> ; (at your option) any later version.
    66                              <2> ;
    67                              <2> ; This program is distributed in the hope that it will be useful,
    68                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    69                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    70                              <2> ; GNU General Public License for more details.
    71                              <2> ;
    72                              <2> ; You should have received a copy of the GNU General Public License
    73                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    74                              <2> ;
    75                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76                              <2> 
    77                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    78                              <2> ;
    79                              <2> ;
    80                              <2> %ifndef __MACROS_DEFINED_
    81                              <2> %define __MACROS_DEFINED_ 1
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> ;
    84                              <2> ; some useful macros:
    85                              <2> ;
    86                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    87                              <2> ;
    88                              <2> 	cpu	186
    89                              <2> 
    90                              <2> %imacro setloc  1.nolist
    91                              <2>  times   (%1-($-$$)) db 0FFh
    92                              <2> %endm
    93                              <2> 
    94                              <2> %imacro db_lo   1
    95                              <2>  db (%1)&255
    96                              <2> %endm
    97                              <2> 
    98                              <2> %imacro cnop    0.nolist
    99                              <2> %if SOFT_DEBUG
   100                              <2>         nop
   101                              <2> %endif
   102                              <2> %endm
   103                              <2> 
   104                              <2> %imacro popm 1-*.nolist
   105                              <2> %rep %0
   106                              <2> %ifidni %1,ALL
   107                              <2>  popa
   108                              <2> %elifidni %1,F
   109                              <2>  popf
   110                              <2> %else
   111                              <2>  pop %1
   112                              <2> %ifidni %1,DS
   113                              <2>  cnop
   114                              <2> %elifidni %1,ES
   115                              <2>  cnop
   116                              <2> %endif
   117                              <2> %endif
   118                              <2> %rotate 1
   119                              <2> %endrep
   120                              <2> %endm
   121                              <2> 
   122                              <2> %imacro pushm 1-*.nolist
   123                              <2> %rep %0
   124                              <2> %rotate -1
   125                              <2> %ifidni %1,ALL
   126                              <2>  pusha
   127                              <2> %elifidni %1,F
   128                              <2>  pushf
   129                              <2> %else
   130                              <2>  push %1
   131                              <2> %endif
   132                              <2> %endrep
   133                              <2> %endm
   134                              <2> 
   135                              <2> ;
   136                              <2> ; added from the 386EX project
   137                              <2> ;
   138                              <2> 
   139                              <2> ; call arguments
   140                              <2> %define ARG(n) [bp+2+(n)*2]
   141                              <2> 
   142                              <2> ;
   143                              <2> ; format of the BYTE initialization table:  address, byte
   144                              <2> ;
   145                              <2> %imacro  binit 2
   146                              <2>         dw      %1
   147                              <2>         db      %2
   148                              <2> %endmacro
   149                              <2> ; end with DW -1
   150                              <2> 
   151                              <2> ;
   152                              <2> ; format of the WORD initialization table:  address, word
   153                              <2> ;
   154                              <2> %imacro  winit 2
   155                              <2>         dw      %1
   156                              <2>         dw      %2
   157                              <2> %endmacro
   158                              <2> ; end with DW -1
   159                              <2> 
   160                              <2> 
   161                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   162                              <2> %imacro get_bda	1.nolist
   163                              <2> 	push	0x0040
   164                              <2> 	pop	%1
   165                              <2> 	cnop
   166                              <2> %endm
   167                              <2> 
   168                              <2> 
   169                              <2> %endif
    53                              <1> 
    54                              <1> 	cpu     186
    55                              <1> ;
    56                              <1> ;
    57                              <1> ; IBM model byte -- must be less than a 286
    58                              <1> ;
    59                              <1> 
    60                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    61                              <1> SUBMODEL_BYTE		equ	00h	;  "
    62                              <1> 
    63                              <1> 
    64                              <1> ; 80188 peripheral control register block address
    65                              <1> CPU_CSCR	        equ	0FF00h
    66                              <1> 
    67                              <1> ; Compatible Mode registers
    68                              <1> 
    69                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    70                              <1> 
    71                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    72                              <1> 
    73                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    74                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    75                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    76                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    77                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    78                              <1> 
    79                              <1> ; Enhanced Mode registers
    80                              <1> 
    81                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    82                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    83                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    84                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    85                              <1> 
    86                              <1> 
    87                              <1> ; On-board internal peripheral equates
    88                              <1> ; Programmable Interrupt Controller
    89                              <1> PIC	        equ	CPU_CSCR+020H
    90                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    91                              <1> PIC_POLLR	equ	PIC+4
    92                              <1> PIC_POLLSR	equ	PIC+6
    93                              <1> PIC_IMASK	equ	PIC+8
    94                              <1> PIC_PMREG	equ	PIC+0AH
    95                              <1> PIC_SRVR	equ	PIC+0CH
    96                              <1> PIC_IRQR	equ	PIC+0EH
    97                              <1> PIC_IRQSR	equ	PIC+10H
    98                              <1> PIC_TCR	        equ	PIC+12H
    99                              <1> PIC_DMA0CR	equ	PIC+14H
   100                              <1> PIC_DMA1CR	equ	PIC+16H
   101                              <1> PIC_I0CON	equ	PIC+18H
   102                              <1> PIC_I1CON	equ	PIC+1AH
   103                              <1> PIC_I2CON	equ	PIC+1CH
   104                              <1> PIC_I3CON	equ	PIC+1EH
   105                              <1> 
   106                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   107                              <1> 
   108                              <1> ; Interrupt masks (Master Mode)
   109                              <1> ;
   110                              <1> mask_timer_all          equ     0001h
   111                              <1> mask_dma0               equ     0004h
   112                              <1> mask_dma1               equ     0008h
   113                              <1> mask_int0               equ     0010h
   114                              <1> mask_int1               equ     0020h
   115                              <1> mask_int2               equ     0040h
   116                              <1> mask_int3               equ     0080h
   117                              <1> 
   118                              <1> 
   119                              <1> 
   120                              <1> ; Timers
   121                              <1> TIM0	        equ	CPU_CSCR+050H
   122                              <1> TIM1	        equ	CPU_CSCR+058H
   123                              <1> TIM2	        equ	CPU_CSCR+060H
   124                              <1> 
   125                              <1> TCNT	        equ	0	; count register
   126                              <1> CMPA	        equ	2	; max count A
   127                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   128                              <1> TCON	        equ	6	; mode/control word
   129                              <1> 
   130                              <1> ; Timer control bits:
   131                              <1> tc_EN           equ     8000h   ; Enable bit
   132                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   133                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   134                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   135                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   136                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   137                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   138                              <1> tc_EXT          equ     0004h   ; External clock
   139                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   140                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> ; DMA
   146                              <1> DMA0	        equ	CPU_CSCR+0C0H
   147                              <1> DMA1	        equ	CPU_CSCR+0D0H
   148                              <1> DMASPL	        equ	0	; source pointer low
   149                              <1> DMASPU	        equ	2	; source pointer high
   150                              <1> DMADPL	        equ	4	; destination pointer low
   151                              <1> DMADPU	        equ	6	; destination pointer high
   152                              <1> DMATC	        equ	8	; terminal count
   153                              <1> DMACW	        equ	0AH	; control word
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   160                              <1> ;
   161                              <1> ;       SBC-188 external devices
   162                              <1> ;
   163                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   164                              <1> 
   165                              <1> IO_BASE			equ	0400h
   166                              <1> 
   167                              <1> 
   168                              <1> 
   169                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   170                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> 
   173                              <1> uart_base               equ     IO_BASE+0280h
   174                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   175                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   176                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   177                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   178                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   179                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   180                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   181                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   182                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   183                              <1> uart_sr			equ	uart_base+7	;Scratch
   184                              <1> 
   185                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   186                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   187                              <1> 
   188                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   189                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   190                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   191                              <1> CTRL259		equ	IO_BASE+0238H
   192                              <1> ; LEDS are at addresses 0..3
   193                              <1> ; other control ports on 4..7
   194                              <1> LED0		equ	CTRL259+0
   195                              <1> LED1		equ	LED0+1
   196                              <1> LED2		equ	LED0+2
   197                              <1> LED3		equ	LED0+3
   198                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   199                              <1> ;unused		equ	CTRL259+5
   200                              <1> ;unused		equ	CTRL259+6
   201                              <1> ;unused		equ	CTRL259+7
   202                              <1> 
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   207                              <1> 
   208                              <1> 
   209                              <1> 
   210                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   211                              <1> ; Floppy controller (Duodyne Disk IO)
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> FDC	        equ	IO_BASE+0080H
   214                              <1> FDC_MSR         equ     FDC
   215                              <1> FDC_DATA        equ     FDC+1
   216                              <1> FDC_TC	        equ	FDC+2
   217                              <1> FDC_RES	        equ	FDC+3
   218                              <1> FDC_LDCR	equ	FDC+5
   219                              <1> FDC_LDOR	equ	FDC+6
   220                              <1> FDC_DACK        equ	FDC+6
   221                              <1> FDC_DACK_TC     equ     FDC+7
   222                              <1> 
   223                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                              <1> ; Duodyne Multi IO
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> CH376	        equ	IO_BASE+004EH
   227                              <1> ParPrinter      equ	IO_BASE+0048H
   228                              <1> DuoSerial       equ	IO_BASE+0070H
   229                              <1> MultiIo8242     equ	IO_BASE+004CH
   230                              <1> PrinterTimeout  equ 	020h
   231                              <1> 
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> RTC	equ	IO_BASE+0094H
   236                              <1> 
   237                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   238                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   239                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   240                              <1> PPI	        equ	IO_BASE+0088H
   241                              <1> 
   242                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   243                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   244                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   245                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   246                              <1> 
   247                              <1> portA           equ     PPI+0   ;
   248                              <1> portB           equ     PPI+1   ;
   249                              <1> portC           equ     PPI+2   ;
   250                              <1> 
   251                              <1> ; end CPUREGS.ASM
    28                                  %include	"date.asm"
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; date.asm
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    33                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    34                              <1> ;
    35                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    36                              <1> ;
    37                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    38                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    39                              <1> ;
    40                              <1> ; Definitions for version 3.5-2:
    41                              <1> ;
    42                              <1> ; Updated for the Duodyne 80c188 SBC
    43                              <1> 
    44                              <1> %define DATE_STRING0	"12/08/24"
    45                              <1> %define DATE_STRING1	"08-DEC-2024"
    46                              <1> 
    47                              <1> %define VERSION_MAJOR		3
    48                              <1> %define VERSION_MINOR		5
    49                              <1> %define VERSION_REVISION	2
    50                              <1> %define VERSION_SUFFIX		""
    51                              <1> %define VERSION_SEQUENCE	70
    52                              <1> 
    53                              <1> %define VERSION_STRING		"3.5-D",VERSION_SUFFIX
    54                              <1> 
    55                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                              <1> ; Revision information:
    57                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    58                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    59                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    60                              <1> ;	    &  Dual SDcard & Minix boot
    61                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    62                              <1> ;	3.0 -- VGA3 support
    63                              <1> ;	3.1 -- SBC-188 v.3 board support
    64                              <1> ;	3.2 -- IDE8 support on the v.3 board
    65                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    66                              <1> ;	3.4 -- floppy drives did not work
    67                              <1> ;	3.5 -- back to 3.3, sequence #51
    68                              <1> ;		change NVRAM battery backup setup to #53
    69                              <1> ;		re-install 3.4 boot fix for FreeDOS
    70                              <1> ;       3.5-D  Remove SBC-188 specific items and customize for Duodyne
    71                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                                  %include        "equates.asm"
    30                              <1> ;========================================================================
    31                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    32                              <1> ;========================================================================
    33                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;
    53                              <1> ;========================================================================
    54                              <1> 
    55                              <1>         global  FPEM_segment
    56                              <1> 
    57                              <1> 
    58                              <1> %include "segdef.asm"
    59                              <2> ;========================================================================
    60                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    61                              <2> ;========================================================================
    62                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    63                              <2> ;
    64                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    65                              <2> ;
    66                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    67                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    68                              <2> ;
    69                              <2> ; This program is free software: you can redistribute it and/or modify
    70                              <2> ; it under the terms of the GNU General Public License as published by
    71                              <2> ; the Free Software Foundation, either version 3 of the License, or
    72                              <2> ; (at your option) any later version.
    73                              <2> ;
    74                              <2> ; This program is distributed in the hope that it will be useful,
    75                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    76                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    77                              <2> ; GNU General Public License for more details.
    78                              <2> ;
    79                              <2> ; You should have received a copy of the GNU General Public License
    80                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    81                              <2> ;
    82                              <2> ;========================================================================
    83                              <2> 
    84                              <2> %ifndef __SEGDEF_
    85                              <2> %define __SEGDEF_
    86                              <2> 
    87                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    88                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    89                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    90                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    91                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    92                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    93                              <2> 
    94                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    95                              <2> 
    96                              <2> %endif
    97                              <2> 
    59                              <1> %include "ascii.asm"
    60                              <2> ; ascii.asm
    61                              <2> ;
    62                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    63                              <2> 
    64                              <2> NUL     equ     00h
    65                              <2> BEL     equ     (CTRL & 'G')
    66                              <2> BS      equ     08h		; ^H
    67                              <2> HT      equ     09h		; ^I
    68                              <2> LF	equ	0Ah		; ^J
    69                              <2> NL      equ     LF
    70                              <2> VT	equ	0Bh		; ^K
    71                              <2> FWD	equ	0Ch		; ^L
    72                              <2> CR	equ	0Dh
    73                              <2> XON     equ     (CTRL & 'Q')
    74                              <2> XOFF    equ     (CTRL & 'S')
    75                              <2> DC1     equ     XON
    76                              <2> DC3     equ     XOFF
    77                              <2> ESC     equ	1Bh
    78                              <2> 
    79                              <2> 
    60                              <1> 
    61                              <1> 
    62                              <1> ; POST error codes. Presently one byte but can expand to word.
    63                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    64                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    65                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    66                              <1> ER_FDC	equ	08h		; Bad FDC
    67                              <1> ER_UNK1	equ	10h		; {unassigned}
    68                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    69                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    70                              <1> ER_UNK2	equ	80h		; {unassigned}
    71                              <1> 
    72                              <1> 
    73                              <1> 
    74                              <1> ;; ************************ BIOS Data Segment ******************************
    75                              <1> ;; BIOS data segment - not all will  be used
    76                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    77                              <1> %include "bda.inc"
    78                              <2> ;/*======================================================================
    79                              <2> ; bda.inc -- BIOS data area definitions
    80                              <2> ;========================================================================
    81                              <2> ;   for the N8VEM SBC-188
    82                              <2> ;
    83                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    84                              <2> ;
    85                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    86                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    87                              <2> ;
    88                              <2> ; This program is free software: you can redistribute it and/or modify
    89                              <2> ; it under the terms of the GNU General Public License as published by
    90                              <2> ; the Free Software Foundation, either version 3 of the License, or
    91                              <2> ; (at your option) any later version.
    92                              <2> ;
    93                              <2> ; This program is distributed in the hope that it will be useful,
    94                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    95                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    96                              <2> ; GNU General Public License for more details.
    97                              <2> ;
    98                              <2> ; You should have received a copy of the GNU General Public License
    99                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   100                              <2> ;
   101                              <2> ;========================================================================
   102                              <2> 
   103                              <2> 			;*/ extern				/*
   104                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   105 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   106 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   107 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   108                              <2> ;	dw	?		; 40:10 	; Equipment present word
   109                              <2> ;  						;  = (1 iff floppies) *     1.
   110                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   111                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   112                              <2> ;  						;  + (init crt mode ) *    16.
   113                              <2> ;  						;  + (# of floppies ) *    64.
   114                              <2> ;  						;  + (# serial ports) *   512.
   115                              <2> ;  						;  + (1 iff toy port) *  4096.
   116                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   117                              <2> ;  						;  + (# parallel LPT) * 16384.
   118 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   119 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   120                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   121 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   122 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   123                              <2> ;;---------------[Keyboard data area]------------;
   124 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   125                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;
   126 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   127 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   128 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   129 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   130                              <2> kbd_buffer_last	equ	$	;*/				/*
   131                              <2> ;;---------------[Diskette data area]------------;
   132 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   133 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   134 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   135 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   136                              <2> ;				Floppy return code stat byte
   137                              <2> ;				;  1 = bad ic 765 command req.
   138                              <2> ;				;  2 = address mark not found
   139                              <2> ;				;  3 = write to protected disk
   140                              <2> ;				;  4 = sector not found
   141                              <2> ;				;  8 = data late (DMA overrun)
   142                              <2> ;				;  9 = DMA failed 64K page end
   143                              <2> ;				; 16 = bad CRC on floppy read
   144                              <2> ;				; 32 = bad NEC 765 controller
   145                              <2> ;				; 64 = seek operation failed
   146                              <2> ;				;128 = disk drive timed out
   147 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   148                              <2> ;;---------------[Video display area]------------;
   149 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   150                              <2> ;			 	; Current CRT mode  (software)
   151                              <2> ;				;  0 = 40 x 25 text (no color)
   152                              <2> ;				;  1 = 40 x 25 text (16 color)
   153                              <2> ;				;  2 = 80 x 25 text (no color)
   154                              <2> ;				;  3 = 80 x 25 text (16 color)
   155                              <2> ;				;  4 = 320 x 200 grafix 4 color
   156                              <2> ;				;  5 = 320 x 200 grafix 0 color
   157                              <2> ;				;  6 = 640 x 200 grafix 0 color
   158                              <2> ;				;  7 = 80 x 25 text (mono card)
   159 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   160 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   161 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   162 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   163 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   164 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   165 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   166 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   167 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   168                              <2> ;;---------------[Used to setup ROM]-------------;
   169 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   170 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   171                              <2> ;;---------------[Timer data area]---------------;
   172 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   173 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   174                              <2> ;;---------------[System data area]--------------;
   175 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   176 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   177                              <2> ;;---------------[Hard disk scratchpad]----------;
   178 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   179                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   180 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   181 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   182                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   183 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   184 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   185                              <2> ;;---------------[EGA stuff]---------------------;
   186 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   187                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   188 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   189 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   190 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   191 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   192 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   193                              <2> ;;---------------[Additional KBD flags]----------------;
   194 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   195 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   196                              <2> ;;---------------[RTC/timer1 data]---------------------;
   197 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   198 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   199 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h,
   200                              <2> ;;---------------[Cassette I/O stuff]------------------;
   201 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   202 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   203                              <2> ;									Post Acknowleged=00;
   204 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   205 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   206 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   207                              <2> ;
   208 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   209 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   210 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   211 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   212                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   213 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   214 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   215 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   216 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   217 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   218 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   219 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   220 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   221 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   222 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   223 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   224 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   225 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   226 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   227 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   228                              <2> ;
   229                              <2> ;
   230                              <2> 
   231 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   232                              <2> 
   233 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   234                              <2> 
   235 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   236 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   237                              <2> 
   238 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib
   239                              <2> 
   240 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   241                              <2> 
   242 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   243                              <2> 
   244 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz
   245                              <2> ;								   CPU clock is half of this
   246                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <2> ;
   248                              <2> ;  System configuration stuff below
   249                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   250                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   251                              <2> %if 0				;*/
   252                              <2> #define FIXED_DISK_MAX 4		/*
   253                              <2> %else
   254                              <2> %define FIXED_DISK_MAX 4
   255                              <2> %endif
   256                              <2> %if 0				;*/
   257                              <2> #define PPIDE_driver 1		/*
   258                              <2> %else
   259                              <2> %define PPIDE_driver 1
   260                              <2> %endif
   261                              <2> %if 0				;*/
   262                              <2> #define USB_driver 1		/*
   263                              <2> %else
   264                              <2> %define USB_driver 1
   265                              <2> %endif
   266                              <2> 				;*/
    78                              <1> 
    79                              <1> ;  this must be the same in EQUATES.H */
    80                              <1> %if SOFT_DEBUG
    81                              <1> %define NBREAK  8
    82                              <1> %endif
    83                              <1> 
    84                              <1> 
    85                              <1> %if 0
    86                              <1>         segment _TEXT
    87                              <1> ;; *************************************************************************
    88                              <1> 
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ;; ************************ DOS Data Segment *******************************
    93                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    94                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    95                              <1> ;						;  1 if PrtSc xeroxing screen
    96                              <1> ;						;255 if PrtSc error in xerox
    97                              <1> ;						;  ...non-grafix PrtSc in bios
    98                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    99                              <1> ;						;  ...IBMBIO.COM buffers the
   100                              <1> ;						;  ...directory of the boot
   101                              <1> ;						;  ...device here at IPL time
   102                              <1> ;						;  ...when locating the guts
   103                              <1> ;						;  ...of the operating system
   104                              <1> ;						;  ...filename "IBMDOS.COM"
   105                              <1> ;dosdir	ends
   106                              <1> ;; *************************************************************************
   107                              <1> ;; ************************ DOS IPL Segment ********************************
   108                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   109                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   110                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   111                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   112                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   113                              <1> ;dosseg	ends					;			      !
   114                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   115                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   116                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   117                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   118                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   119                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   120                              <1> ;iplseg	ends
   121                              <1> 
   122                              <1> %endif
    30                                  
    31                                  
    32                                  
    33                                  timer0          equ     TIM0
    34                                  timer1          equ     TIM1
    35                                  
    36                                  
    37                                  	SEGMENT	_TEXT
    38                                  
    39                                          global  BIOS_call_15h
    40                                  
    41                                  ; The stack offsets
    42                                  offset_BP       equ     0
    43                                  offset_AX       equ     offset_BP+2
    44                                  ;offset_AL	equ	offset_AX+0
    45                                  offset_AH       equ     offset_AX+1
    46                                  offset_BX       equ     offset_AX+2
    47                                  offset_DX	equ	offset_BX+2	; added for cassette I/O
    48                                  offset_DS       equ     offset_DX+2
    49                                  offset_IP       equ     offset_DS+2
    50                                  offset_CS       equ     offset_IP+2
    51                                  offset_FLAGS    equ     offset_CS+2
    52                                  
    53                                  
    54                                  BIOS_call_15h:
    55 00000000 80FC4F                  	cmp     ah,04Fh         ; null keyboard intercept handler
    56 00000003 7501                            jne	.1
    57 00000005 CF                              iret			; carry was set by the call
    58                                  .1:
    59 00000006 1E52535055                      pushm   bp,ax,bx,dx,ds
    60 0000000B 89E5                            mov     bp,sp           ; establish stack frame addressing
    61                                  
    62                                  %if 0
    63                                  	cmp     ah,04Fh         ; null keyboard intercept handler
    64                                          je      bye_bye		; was 'set_carry'
    65                                  
    66                                  	cmp	ah,0		; cassette motor on command
    67                                  	je	fn00
    68                                  	cmp	ah,1		; cassette motor off
    69                                  	je	fn01
    70                                  	cmp	ah,2		; cassette read block
    71                                  	je	fn02
    72                                  	cmp	ah,3		; cassette write block
    73                                  	je	fn03
    74                                  	cmp	ah,4		; cassette GPIO2 on command
    75                                  	je	fn04
    76                                  	cmp	ah,5		; cassette GPIO2 off command
    77                                  	je	fn05
    78                                  %else
    79 0000000D 88E3                            mov     bl,ah
    80 0000000F 30FF                            xor     bh,bh
    81 00000011 80FB06                          cmp     bl,fn00max/2
    82 00000014 7307                            jae     try_fn80
    83                                  
    84 00000016 01DB                            add     bx,bx
    85 00000018 2EFFA7[5500]                cs  jmp     near [int15fn00+bx]     ; dispatch
    86                                  %endif
    87                                  
    88                                  try_fn80:
    89 0000001D 80FCC0                  	cmp     ah,0C0h
    90 00000020 747E                            je      fnC0
    91 00000022 80FCC1                          cmp     ah,0C1h
    92 00000025 7503E98100                      je      fnC1
    93                                  
    94 0000002A 88E3                            mov     bl,ah
    95 0000002C 30FF                            xor     bh,bh
    96                                  
    97 0000002E 80EB80                          sub     bl,80h          ; miscellaneous Int15 functions
    98 00000031 80FB11                          cmp     bl,fn80max/2
    99 00000034 7307                            jae     unknown
   100                                  
   101 00000036 01DB                            add     bx,bx
   102 00000038 2EFFA7[6100]                cs  jmp     near [int15fn80+bx]     ; dispatch
   103                                  
   104                                  
   105                                  unknown:
   106 0000003D C64603FF                	mov	byte [offset_AH+bp],0FFh	; flag error
   107                                  set_carry:
   108 00000041 804E0E01                        or      byte [bp+offset_FLAGS],1        ; set the carry bit
   109 00000045 EB08                            jmp     bye_bye
   110                                  
   111                                  okay:
   112 00000047 C6460300                	mov	byte [offset_AH+bp],00h		; flag dummy okay
   113                                  clear_carry:
   114 0000004B 80660EFE                        and     byte [bp+offset_FLAGS],~1       ; clear the carry flag
   115                                  bye_bye:
   116 0000004F 5D585B5A1F                      popm    bp,ax,bx,dx,ds
   117 00000054 CF                              iret
   118                                  
   119                                  
   120                                  int15fn00:
   121 00000055 [9E00]                  	dw	fn00		; cassette motor on command
   122 00000057 [9E00]                  	dw	fn01		; cassette motor off
   123 00000059 [9E00]                  	dw	fn02		; cassette read block
   124 0000005B [9E00]                  	dw	fn03		; cassette write block
   125 0000005D [9E00]                  	dw	fn04		; cassette GPIO2 on command
   126 0000005F [9E00]                  	dw	fn05		; cassette GPIO2 off command
   127                                  fn00max         equ     $-int15fn00
   128                                  
   129                                  int15fn80:
   130 00000061 [4700]                          dw      fn80            ; device open
   131 00000063 [4700]                          dw      fn81            ; device close
   132 00000065 [4700]                          dw      fn82            ; process termination
   133 00000067 [F100]                          dw      fn83            ; event wait
   134 00000069 [3D00]                          dw      fn84            ; read joystick
   135 0000006B [4700]                          dw      fn85            ; SysReq key
   136 0000006D [3A01]                          dw      fn86            ; delay
   137 0000006F [3D00]                          dw      fn87            ; move extended memory block
   138 00000071 [8300]                          dw      fn88            ; get extended memory size
   139 00000073 [3D00]                          dw      fn89            ; enter protected mode
   140                                  %if TBASIC
   141 00000075 [8A00]                          dw      fn8a            ; getline code
   142                                  %else
   143                                  	dw	unknown		; no TBASIC, so no call
   144                                  %endif
   145 00000077 [3D00]                  	dw	fn8b
   146 00000079 [3D00]                  	dw	fn8c
   147 0000007B [3D00]                  	dw	fn8e
   148 0000007D [3D00]                  	dw	fn8f
   149 0000007F [4700]                  	dw	fn90		; Device Wait
   150 00000081 [4700]                  	dw	fn91		; Device Post
   151                                  fn80max         equ     $-int15fn80
   152                                  
   153                                  
   154                                  ; Dummy routines for the following:
   155                                  fn80    equ     okay		; Device Open
   156                                  fn81    equ     okay		; Device Close
   157                                  fn82    equ     okay		; Process Termination
   158                                  
   159                                  fn84    equ     unknown		; Read Joystick
   160                                  fn85    equ     okay		; SysReq Key make/break
   161                                  
   162                                  fn87    equ     unknown		; Move Extended Memory Block
   163                                  fn89    equ     unknown		; Enter Protected Mode
   164                                  
   165                                  fn8b	equ	unknown
   166                                  fn8c	equ	unknown
   167                                  fn8d	equ	unknown
   168                                  fn8e	equ	unknown
   169                                  fn8f	equ	unknown
   170                                  
   171                                  fn90	equ	okay		; Device Wait
   172                                  fn91	equ	okay		; Device Post
   173                                  
   174                                  ;
   175                                  ; Get Extended Memory size
   176                                  ;
   177                                  ;       There is No high memory on an 80186/8
   178                                  ;       Always return 0
   179                                  ;
   180                                  fn88:
   181 00000083 C746020000                      mov     word [bp+offset_AX],0
   182 00000088 EBC1                            jmp     clear_carry
   183                                  
   184                                  
   185                                  
   186                                  %if TBASIC
   187                                  ; Get Line (direct access to SIO.C 'getline' routine)
   188                                  ;
   189                                  ;  Enter with:
   190                                  ;       CX      length of buffer
   191                                  ;       DS:DX   pointer to the buffer
   192                                  ;
   193                                  ;  Return with:
   194                                  ;       Buffer of length-1 characters (maximum), NUL terminated
   195                                  ;
   196                                  fn8a:
   197 0000008A FB                              sti                             ; enable interrupts
   198 0000008B 5251                            pushm   cx,dx
   199                                  
   200 0000008D 89D0                            mov     ax,dx                   ; DX:AX is pointer argument
   201 0000008F 8CDA                            mov     dx,ds                   ; **
   202 00000091 89CB                            mov     bx,cx                   ; BX is second argument
   203                                  
   204 00000093 68[ssss]                        push    DGROUP                  ; for the C-code
   205 00000096 1F                              popm    ds
   206                                          extern  getline_                ; this is a __fastcall entry
   207 00000097 E8(0000)                        call    getline_
   208                                  
   209 0000009A 595A                            popm    cx,dx
   210 0000009C EBAD                            jmp     clear_carry
   211                                  %endif
   212                                  
   213                                  
   214                                  
   215                                  %if 0
   216                                  %include "cassette.asm"
   217                                  ;--------------------------------------------------------
   218                                  ; Cassette support routines
   219                                  ;	(AH) = 0 TURN CASSETTE MOTOR ON
   220                                  ;	(AH) = 1 TURN CASSETTE MOTOR OFF
   221                                  ;	(AH) = 2 READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   222                                  ;		(ES,BX) = POINTER TO DATA BUFFER
   223                                  ;		(CX) = COUNT OF BYTES TO READ
   224                                  ;		ON EXIT:
   225                                  ;  		(ES,BX) = POINTER TO LAST BYTE READ + 1
   226                                  ;  		(DX) = COUNT OF BYTES ACTUALLY READ
   227                                  ;  		(CY) = 0 IF NO ERROR OCCURRED
   228                                  ;  		     = 1 IF ERROR OCCURRED
   229                                  ;  		(AH) = ERROR RETURN IF (CY)= 1
   230                                  ;  			= 01 IF CRC ERROR WAS DETECTED
   231                                  ;  			= 02 IF DATA TRANSITIONS ARE LOST
   232                                  ;  			= 04 IF NO DATA WAS FOUND
   233                                  ;  	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
   234                                  ;  		(ES,BX) = POINTER TO DATA BUFFER
   235                                  ;  		(CX) = COUNT OF BYTES TO WRITE
   236                                  ;  		ON EXIT:
   237                                  ;		(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1
   238                                  ;		(CX) = 0
   239                                  ;	(AH) = 4 TURN GPIO2 ON
   240                                  ;	(AH) = 5 TURN GPIO2 OFF
   241                                  ;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1
   242                                  ;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).
   243                                  ;--------------------------------------------------------
   244                                  ; PURPOSE:
   245                                  ;  TO TURN ON CASSETTE MOTOR
   246                                  ;  16550 I/O pins are active low so we need to add
   247                                  ;  an inverter (7400) before the 75452 to make this work.
   248                                  ;  Cassette motor connected to OUT1* on 16550, which is
   249                                  ;  bit2 of MCR.
   250                                  ;--------------------------------------------------------
   251                                  fn00:
   252                                  	mov	dx,cuart_mcr			; get device code
   253                                  	in	al,dx				;read cassette uart mcr
   254                                  	or	al,04H				; SET BIT TO TURN ON
   255                                  W3:	out	dx,al				;WRITE IT OUT
   256                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   257                                  	jmp	clear_carry
   258                                  
   259                                  
   260                                  ;----------------------------------
   261                                  ; PURPOSE:
   262                                  ;  TO TURN CASSETTE MOTOR OFF
   263                                  ;-----------------------------------
   264                                  fn01:
   265                                  	mov	dx,cuart_mcr			; get device code
   266                                  	in	al,dx				;read cassette uart mcr
   267                                  	and	al,~04h				; clear bit to turn off motor
   268                                  	jmp	W3				;write it, clear error, return
   269                                  
   270                                  
   271                                  ;--------------------------------------------
   272                                  ; PURPOSE:
   273                                  ;  TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   274                                  ;
   275                                  ; ON ENTRY:
   276                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   277                                  ;  BX POINTS TO START OF MEMORY BUFFER
   278                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   279                                  ; ON EXIT:
   280                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   281                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   282                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   283                                  ;
   284                                  ;  CARRY FLAG IS CLEAR IF NO ERROR DETECTED
   285                                  ;  CARRY FLAG IS SET IF CRC ERROR DETECTED
   286                                  ;--------------------------------------------
   287                                  fn02:
   288                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   289                                  	jmp	set_carry
   290                                  
   291                                  
   292                                  ;--------------------------------------------
   293                                  ;  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   294                                  ;
   295                                  ; ON ENTRY:
   296                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   297                                  ;  BX POINTS TO START OF MEMORY BUFFER
   298                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   299                                  ; ON EXIT:
   300                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   301                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   302                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   303                                  ;--------------------------------------------
   304                                  fn03:
   305                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   306                                  	jmp	set_carry
   307                                  
   308                                  
   309                                  ;--------------------------------------------------------
   310                                  ; PURPOSE:
   311                                  ;  TO TURN CASSETTE GPIO2 ON
   312                                  ;  16550 I/O pins are active low so we need to add
   313                                  ;  an inverter (7400) before the 75452 to make this work.
   314                                  ;  GPIO2 is OUT2* on 16550, which is bit3 of MCR.
   315                                  ;--------------------------------------------------------
   316                                  fn04:
   317                                  	mov	dx,cuart_mcr			; get device code
   318                                  	in	al,dx   			;read cassette uart mcr
   319                                  	or	al,08h				; set bit to turn on
   320                                  W4:	out	dx,al				;write it out
   321                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   322                                  	jmp	clear_carry
   323                                  
   324                                  
   325                                  ;----------------------------------
   326                                  ; PURPOSE:
   327                                  ;  TO TURN CASSETTE GPIO2 OFF
   328                                  ;-----------------------------------
   329                                  fn05:
   330                                  	mov	dx,cuart_mcr			; get device code
   331                                  	in	al,dx				;read cassette uart mcr
   332                                  	and	al,~08h				; clear bit to turn off motor
   333                                  	jmp	W4				;write it, clear error, return
   334                                  
   335                                  %else
   336                                  fn00:
   337                                  fn01:
   338                                  fn02:
   339                                  fn03:
   340                                  fn04:
   341                                  fn05:
   342 0000009E EBA1                    jmp	set_carry
   343                                  %endif
   344                                  
   345                                  
   346                                          SEGMENT CONST
   347                                  env_table:
   348 00000000 0800                            dw      len_env_table
   349 00000002 FE                      	db	MODEL_BYTE	; PC/XT
   350 00000003 00                      	db	SUBMODEL_BYTE	; rev 1		CPUREGS.ASM
   351 00000004 03                      	db	VERSION_MAJOR	; BIOS revision level  DATE.ASM
   352 00000005 24                              db      00100100b
   353                                  				; DMA ch 3 used = 0             7
   354                                                                  ; slave 8259 present = 0        6
   355                                                                  ; RTC available = 1             5
   356                                                                  ; KBD intercept available (int 15h, fn4F) = 0
   357                                                                  ; Wait for Event avail. = 0     3
   358                                                                  ; Extended BIOS data area alloc. = 1   (FPEM will use)
   359                                                                  ; Micro Channel = 0             1
   360                                                                  ; reserved bit = 0              0
   361 00000006 00                              db      0       ; unknown usage
   362 00000007 00                              db      0       ; unknown usage
   363                                  len_env_table   equ     $-env_table
   364 00000008 0000                            db      0,0     ; just in case
   365                                  
   366                                  
   367                                  	SEGMENT	_TEXT
   368                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   369                                  ; Get System Environment
   370                                  ;   Input:
   371                                  ;	AH = 0C0h	function code
   372                                  ;   Returns:
   373                                  ;	ES:BX		pointer to the environment table above
   374                                  ;	Carry clear	success
   375                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   376                                  fnC0:
   377 000000A0 C74604[0000]                    mov     word [bp+offset_BX],env_table
   378 000000A5 68[ssss]                        push    DGROUP
   379 000000A8 07                              popm    es                              ; return ES:BX
   380                                  ;;;	mov     byte [bp+offset_AH],0           ; signal no error
   381 000000A9 EBA0                            jmp     clear_carry
   382                                  
   383                                  
   384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   385                                  ; Get Extended BIOS Data Area Address
   386                                  ;   Input:
   387                                  ;	AH = 0C1h	function code
   388                                  ;   Returns:
   389                                  ;	ES		set to the EBDA segment address
   390                                  ;	Carry clear	success
   391                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   392                                  fnC1:
   393 000000AB 6A40                            push    bios_data_seg
   394 000000AD 1F                              popm    ds
   395 000000AE 8E06F200                        mov     es,[EBDA_paragraph]
   396 000000B2 EB97                            jmp     clear_carry
   397                                  
   398                                  
   399                                  ; Disable timer1 interrupts
   400                                  ;
   401                                  ;	uses AX & DX
   402                                  ;	exits with AX=0
   403                                  ;
   404                                  timer_disable:
   405 000000B4 BA5EFF                  	mov	dx,timer1+TCON
   406 000000B7 ED                      	in	ax,dx		; get control register
   407 000000B8 25FF7F                  	and	ax,(~tc_EN)&0FFFFh  ; disable timer
   408 000000BB 0D0040                  	or	ax,tc_nINH		; change enable flag
   409 000000BE EF                      	out	dx,ax		; disable the timer
   410                                  
   411 000000BF 31C0                    	xor	ax,ax
   412 000000C1 BA58FF                  	mov	dx,timer1+TCNT		; zero the count
   413 000000C4 EF                      	out	dx,ax
   414 000000C5 C3                       	ret
   415                                  
   416                                  ; Enable timer1 interrupts
   417                                  ;
   418                                  ;	uses AX & DX
   419                                  ;
   420                                  timer_enable:
   421 000000C6 BA5EFF                  	mov	dx,timer1+TCON
   422 000000C9 ED                      	in	ax,dx		; get control register
   423 000000CA 0D00E0                  	or	ax,tc_EN+tc_nINH+tc_INT		; enable timer & interrupts
   424 000000CD EF                      	out	dx,ax		; enable the timer
   425 000000CE C3                       	ret
   426                                  
   427                                  	global set_count
   428                                  set_count:
   429 000000CF 31DB                    	xor	bx,bx
   430                                  ; wait in microseconds in BX:CX:DX
   431                                  
   432                                  ;  to divide by 976 microseconds, the resolution of the timer
   433                                  ;  we divide by 1000000/1024 == 15625/16
   434                                  ;  OR we multiply by 16, then divide by 15625
   435                                  
   436 000000D1 51                      	pushm	cx
   437 000000D2 89C8                    	mov	ax,cx		; BX:AX:DX is microsecond count
   438 000000D4 B90400                  	mov	cx,4
   439 000000D7 D1E2                    .4:	shl	dx,1		; * 16 is left shift by 4
   440 000000D9 D1D0                    	rcl	ax,1
   441 000000DB D1D3                    	rcl	bx,1
   442 000000DD E2F8                    	loop	.4
   443 000000DF B9093D                  	mov	cx,15625	; divisor
   444 000000E2 87DA                    	xchg	bx,dx		; DX:AX:BX is count
   445 000000E4 F7F1                    	div	cx
   446 000000E6 A39E00                  	mov	word [rtc_count+2],ax	; AX is high quotient
   447 000000E9 93                      	xchg	ax,bx		; and DX is remainder
   448 000000EA F7F1                    	div	cx		; DX:AX is low dividend
   449 000000EC 59                      	popm	cx
   450                                  
   451                                  %if 0
   452                                  ; since count goes to -1, there will always be at least 1 tick
   453                                  	or	bx,ax		; test for zero tick count
   454                                  	jnz	.5
   455                                  	inc	ax		; wait at least 1 tick
   456                                  .5:
   457                                  %endif
   458 000000ED A39C00                  	mov	word [rtc_count],ax	; AX is final low quotient
   459 000000F0 C3                      	ret
   460                                  
   461                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   462                                  ; fn83 -- Event Wait
   463                                  ;   Input:
   464                                  ;	AH = 83h
   465                                  ;
   466                                  ;   Subfucntion:
   467                                  ;	AL = 01h	Cancel event wait
   468                                  ;   Output:
   469                                  ;	nothing
   470                                  ;
   471                                  ;   Subfunction:
   472                                  ;	AL = 00h	Request Event Wait
   473                                  ;	CX:DX = delay in microseconds
   474                                  ;	ES:BX = address of semaphore byte
   475                                  ;		the semaphore bit 7 is set at the end of the inverval
   476                                  ;   Output:
   477                                  ;	Carry flag clear if timer started
   478                                  ;	Carry flag set if function unsuccessful (event wait already active)
   479                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   480                                  fn83:		; BP,AX,BX,DX,DS already saved
   481 000000F1 6A40                    	push	bios_data_seg
   482 000000F3 1F                      	popm	ds
   483 000000F4 08C0                    	or	al,al		; test for zero
   484 000000F6 741C                    	jz	.set_wait
   485                                  
   486 000000F8 FEC8                    	dec	al		; test for one
   487 000000FA 7403E942FF              	jnz	set_carry	; error on illegal subfunction
   488                                  ; cancel wait
   489 000000FF E8B2FF                  	call	timer_disable
   490                                  ;	xor	ax,ax		; side effect of 'timer_disable'
   491 00000102 A2A000                  	mov	byte [rtc_wait_active],al
   492 00000105 A39E00                  	mov	word [rtc_count+2],ax
   493 00000108 A39C00                  	mov	word [rtc_count],ax
   494 0000010B A39A00                  	mov	word [user_semaphore+2],ax
   495 0000010E A39800                  	mov	word [user_semaphore],ax
   496 00000111 E937FF                  	jmp	clear_carry
   497                                  
   498                                  .set_wait:
   499 00000114 F606A00001              	test	byte [rtc_wait_active],01h	; any wait in progress
   500 00000119 7403E923FF              	jnz	set_carry
   501                                  
   502 0000011E 8B5E04                  	mov	bx,[offset_BX+bp]	; restore BX
   503 00000121 8C069A00                	mov	word [user_semaphore+2],es
   504 00000125 891E9800                	mov	word [user_semaphore],bx
   505                                  
   506 00000129 E8A3FF                  	call	set_count
   507                                  
   508 0000012C E897FF                  	call	timer_enable
   509 0000012F C606A00001              	mov	byte [rtc_wait_active],01h	; flag wait active
   510 00000134 B80083                  	mov	ax,8300h
   511 00000137 E911FF                  	jmp	clear_carry
   512                                  
   513                                  
   514                                  
   515                                  
   516                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   517                                  ; fn86 -- Delay
   518                                  ;   Input:
   519                                  ;	AH = 86h
   520                                  ;	CX:DX = delay in microseconds
   521                                  ;
   522                                  ;   Output:
   523                                  ;	Carry flag clear if delay occurred
   524                                  ;	Carry flag set if timer busy; no delay occurred
   525                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   526                                  fn86:		; BP,AX,BX,DX,DS already saved
   527 0000013A 6A40                    	push	bios_data_seg
   528 0000013C 1F                      	popm	ds
   529 0000013D F606A00001              	test	byte [rtc_wait_active],01h	; is a wait active?
   530 00000142 7403E9FAFE              	jnz	set_carry		; perform no wait, we're busy
   531                                  
   532 00000147 E885FF                  	call	set_count
   533 0000014A C606A00001              	mov	byte [rtc_wait_active],01h		; mark timer active
   534                                  
   535 0000014F 31DB                    	xor	bx,bx
   536 00000151 891E9800                	mov	word [user_semaphore],bx
   537 00000155 891E9A00                	mov	word [user_semaphore+2],bx
   538                                  
   539 00000159 E86AFF                  	call	timer_enable
   540 0000015C FB                      	sti					; don't forget to enable interrupts
   541 0000015D EB01                    	jmp	.3
   542                                  
   543                                  
   544 0000015F F4                      .wait:	hlt
   545 00000160 F606A00080              .3:	test	byte [rtc_wait_active],80h		; wait for posting
   546 00000165 74F8                    	jz	.wait
   547                                  
   548 00000167 C606A00000              	mov	byte [rtc_wait_active],0		; mark not in use
   549 0000016C E9DCFE                  	jmp	clear_carry
   550                                  
   551                                  
   552                                  	global	rtc_interrupt
   553                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   554                                  ;  rtc_interrupt
   555                                  ;
   556                                  ;       This is the 1024 Hz timer tick from INT 70h
   557                                  ;
   558                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   559                                  rtc_interrupt:
   560 0000016F 1E565250                	pushm	ax,dx,si,ds
   561                                  
   562 00000173 6A40                    	push	bios_data_seg
   563 00000175 1F                      	popm	ds
   564                                  
   565 00000176 F606A00001              	test	byte [rtc_wait_active],01h	; test active bit
   566 0000017B 7421                    	jz	.dismiss
   567                                  
   568 0000017D 832E9C0001              	sub	word [rtc_count],1
   569 00000182 831E9E0000              	sbb	word [rtc_count+2],0
   570 00000187 7315                    	jnc	.dismiss		; counted down by 1
   571                                  
   572                                  ; counted down to -1, post the event
   573 00000189 C606A00080              	mov	byte [rtc_wait_active],80h	; mark posted, inactive
   574 0000018E C5369800                	lds	si,[user_semaphore]
   575 00000192 8CD8                    	mov	ax,ds			; check for null pointer
   576 00000194 09F0                    	or	ax,si			; **
   577 00000196 7403                    	jz	.2
   578 00000198 800C80                  	or	byte [si],80h			; post event
   579 0000019B E816FF                  .2:	call	timer_disable
   580                                  
   581                                  .dismiss:
   582                                  ; signal EOI (End of Interrupt)
   583 0000019E BA22FF                          mov     dx,PIC_EOI              ; EOI register
   584 000001A1 B80080                          mov     ax,EOI_NSPEC            ; non-specific
   585 000001A4 EF                              out     dx,ax                   ; signal it
   586                                  
   587 000001A5 585A5E1F                	popm	ax,dx,si,ds
   588 000001A9 CF                              iret
