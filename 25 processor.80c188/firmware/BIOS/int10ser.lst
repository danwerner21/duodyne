     1                                  ;========================================================================
     2                                  ; int10ser.asm -- Video display services implementation using serial port
     3                                  ;========================================================================
     4                                  ;
     5                                  ;    Compiles with NASM 2.07, might work with other versions
     6                                  ;
     7                                  ; Copyright (C) 2010 Sergey Kiselev.
     8                                  ;     additions and modifications for ColorVDU:
     9                                  ; Copyright (C) 2012 John R. Coffman.
    10                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    11                                  ;
    12                                  ; This program is free software: you can redistribute it and/or modify
    13                                  ; it under the terms of the GNU General Public License as published by
    14                                  ; the Free Software Foundation, either version 3 of the License, or
    15                                  ; (at your option) any later version.
    16                                  ;
    17                                  ; This program is distributed in the hope that it will be useful,
    18                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    19                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    20                                  ; GNU General Public License for more details.
    21                                  ;
    22                                  ; You should have received a copy of the GNU General Public License
    23                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    24                                  ;
    25                                  ; Updated for the Duodyne 80c188 SBC
    26                                  ;========================================================================
    27                                  
    28                                  %include	"config.asm"
    29                              <1> ;/*
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ; ANSI.CFG
    32                              <1> ;   Copied to CONFIG.ASM for general release.
    33                              <1> ;
    34                              <1> ;       Modify the parameters below to reflect your system
    35                              <1> ;
    36                              <1> ;
    37                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    38                              <1> ;
    39                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    40                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    41                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                              <1> ;
    43                              <1> ; Define the serial terminal that the Video BIOS must emulate
    44                              <1> ; Set one of the following to 1
    45                              <1> ; If you have no idea what to choose, set TTY to 1
    46                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    47                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    48                              <1> ANSI    equ     1       ; very smart, like a VT-100
    49                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    50                              <1> ; others may get added in the future
    51                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    52                              <1> ;
    53                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    54                              <1> ;UART_RATE	equ	0		; 1200
    55                              <1> ;UART_RATE	equ	1		; 2400
    56                              <1> ;UART_RATE	equ	2		; 4800
    57                              <1> UART_RATE	equ	3		; 9600
    58                              <1> ;UART_RATE	equ	4		; 19200
    59                              <1> ;UART_RATE	equ	5		; 38400
    60                              <1> ;UART_RATE	equ	6		; 57600
    61                              <1> ;UART_RATE	equ	7		; 115200
    62                              <1> 
    63                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    64                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    65                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    66                              <1> 						; but not ANSI
    67                              <1> ; Define the size of the ROM image on the system in Kilobytes
    68                              <1> ; It may be smaller than the actual EPROM in use.
    69                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    70                              <1> %ifndef ROM
    71                              <1> ROM             equ     32              ; 64 is the default
    72                              <1> %endif
    73                              <1> 
    74                              <1> ; Define the number of Wait States at which the ROM operates
    75                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    76                              <1> 
    77                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    78                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    79                              <1> RAM_DOS         equ     640
    80                              <1> 
    81                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    82                              <1> ; the default is 512 kilobytes
    83                              <1> RAM             equ     512             ; (512 is the default)
    84                              <1> 
    85                              <1> ; Define the number of Wait States at which the RAM operates
    86                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    87                              <1> 
    88                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    89                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    90                              <1> 
    91                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    92                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    93                              <1> 
    94                              <1> ; Define the time zone in which we build the Relocatable BIOS
    95                              <1> %ifndef TIMEZONE
    96                              <1> %define TIMEZONE "CST"
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Has the REDBUG debugger been loaded?
   100                              <1> %ifndef SOFT_DEBUG
   101                              <1> %define SOFT_DEBUG 0
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   105                              <1> %ifndef TBASIC
   106                              <1> TBASIC          equ     1		; default is 1
   107                              <1> %endif
   108                              <1> 
   109                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   110                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   111                              <1> %ifndef FPEM
   112                              <1> FPEM            equ     1               ; default is 1
   113                              <1> %endif
   114                              <1> 
   115                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   116                              <1> ; or at locations 0280h..3FFh in low memory?
   117                              <1> %if SOFT_DEBUG
   118                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   119                              <1> %else
   120                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   121                              <1> %endif
   122                              <1> 
   123                              <1> ; Define the size of the EPROM that is to be installed on the system
   124                              <1> ; It may be larger than the actual ROM image to be generated.
   125                              <1> %ifndef CHIP
   126                              <1> CHIP            equ     64
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Define the UART oscillator speed
   130                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   131                              <1> 
   132                              <1> 
   133                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   134                              <1> ; end of the User configuration
   135                              <1> ;       Do Not modify anything below this point
   136                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   137                              <1> 
   138                              <1> ; Define existence of any uart chip
   139                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   140                              <1> startuplength   equ     512                     ; may be up to 1024
   141                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   142                              <1> highrom         equ     (ROM*400h)&0FFFFh
   143                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   144                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   145                              <1> 
   146                              <1> 
   147                              <1> %define ARG(n) [bp+2+(n)*2]
   148                              <1> 
   149                              <1> %macro  check   1.nolist
   150                              <1>  %if (%1)
   151                              <1>    %error Check Failure: %1
   152                              <1>  %endif
   153                              <1> %endm
   154                              <1> %macro  range   3.nolist
   155                              <1>  %if (%1)<(%2)
   156                              <1>    %error Out of Range: %1
   157                              <1>  %elif (%1)>(%3)
   158                              <1>    %error Out of Range: %1
   159                              <1>  %endif
   160                              <1> %endm
   161                              <1> _terminal equ UART
   162                              <1>  check   RAM_DOS&15
   163                              <1>  check   RAM&(RAM-1)
   164                              <1>  check   ROM&(ROM-1)
   165                              <1>  range   RAM,32,512
   166                              <1>  range   ROM,32,256
   167                              <1>  range   RAM_WS,0,3
   168                              <1>  range   ROM_WS,0,3
   169                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   170                              <1>  range   LCL_IO_WS,0,3
   171                              <1>  range   BUS_IO_WS,0,3
   172                              <1>  range   UART_OSC,500000,16000000
   173                              <1>  range   UART_RATE,0,7
   174                              <1>  range	 UART,0,1
   175                              <1>  range	 _terminal,1,2
   176                              <1> 
   177                              <1> %ifndef SOFT_DEBUG
   178                              <1> %define SOFT_DEBUG 0
   179                              <1> %endif
   180                              <1> 
   181                              <1> %ifndef TRACE
   182                              <1> %define TRACE 0
   183                              <1> %endif
   184                              <1> 
   185                              <1> %ifdef MAKE_OBJECT_FILE
   186                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   187                              <1>         export _ROMsize
   188                              <1>         export _CHIPsize
   189                              <1> _ROMsize        dw      ROM
   190                              <1> _CHIPsize       dw      CHIP
   191                              <1> %endif
   192                              <1> ; end of the Hardware configuration file
   193                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   194                              <1> ;*/
    29                                  
    30                                  %include	"cpuregs.asm"
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ; CPUREGS.ASM
    33                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;
    53                              <1> ; Updated for the Duodyne 80c188 SBC
    54                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <1> %include	"macros.inc"
    56                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57                              <2> ; MACROS.INC  
    58                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    59                              <2> ;
    60                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    61                              <2> ;
    62                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    63                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    64                              <2> ;
    65                              <2> ; This program is free software: you can redistribute it and/or modify
    66                              <2> ; it under the terms of the GNU General Public License as published by
    67                              <2> ; the Free Software Foundation, either version 3 of the License, or
    68                              <2> ; (at your option) any later version.
    69                              <2> ;
    70                              <2> ; This program is distributed in the hope that it will be useful,
    71                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    72                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    73                              <2> ; GNU General Public License for more details.
    74                              <2> ;
    75                              <2> ; You should have received a copy of the GNU General Public License
    76                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    77                              <2> ;
    78                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    79                              <2> 
    80                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    81                              <2> ;
    82                              <2> ;
    83                              <2> %ifndef __MACROS_DEFINED_
    84                              <2> %define __MACROS_DEFINED_ 1
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> ; some useful macros:
    88                              <2> ;
    89                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    90                              <2> ;
    91                              <2> 	cpu	186
    92                              <2> 
    93                              <2> %imacro setloc  1.nolist
    94                              <2>  times   (%1-($-$$)) db 0FFh
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro db_lo   1
    98                              <2>  db (%1)&255
    99                              <2> %endm
   100                              <2> 
   101                              <2> %imacro cnop    0.nolist
   102                              <2> %if SOFT_DEBUG
   103                              <2>         nop
   104                              <2> %endif
   105                              <2> %endm
   106                              <2> 
   107                              <2> %imacro popm 1-*.nolist
   108                              <2> %rep %0
   109                              <2> %ifidni %1,ALL
   110                              <2>  popa
   111                              <2> %elifidni %1,F
   112                              <2>  popf
   113                              <2> %else
   114                              <2>  pop %1
   115                              <2> %ifidni %1,DS
   116                              <2>  cnop
   117                              <2> %elifidni %1,ES
   118                              <2>  cnop
   119                              <2> %endif
   120                              <2> %endif
   121                              <2> %rotate 1
   122                              <2> %endrep
   123                              <2> %endm
   124                              <2> 
   125                              <2> %imacro pushm 1-*.nolist
   126                              <2> %rep %0
   127                              <2> %rotate -1
   128                              <2> %ifidni %1,ALL
   129                              <2>  pusha
   130                              <2> %elifidni %1,F
   131                              <2>  pushf
   132                              <2> %else
   133                              <2>  push %1
   134                              <2> %endif
   135                              <2> %endrep
   136                              <2> %endm
   137                              <2> 
   138                              <2> ;
   139                              <2> ; added from the 386EX project
   140                              <2> ;
   141                              <2> 
   142                              <2> ; call arguments
   143                              <2> %define ARG(n) [bp+2+(n)*2]
   144                              <2> 
   145                              <2> ;
   146                              <2> ; format of the BYTE initialization table:  address, byte
   147                              <2> ;
   148                              <2> %imacro  binit 2
   149                              <2>         dw      %1
   150                              <2>         db      %2
   151                              <2> %endmacro
   152                              <2> ; end with DW -1
   153                              <2> 
   154                              <2> ;
   155                              <2> ; format of the WORD initialization table:  address, word
   156                              <2> ;
   157                              <2> %imacro  winit 2
   158                              <2>         dw      %1
   159                              <2>         dw      %2
   160                              <2> %endmacro
   161                              <2> ; end with DW -1
   162                              <2> 
   163                              <2> 
   164                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   165                              <2> %imacro get_bda	1.nolist
   166                              <2> 	push	0x0040
   167                              <2> 	pop	%1
   168                              <2> 	cnop
   169                              <2> %endm
   170                              <2> 
   171                              <2> 
   172                              <2> %endif
    56                              <1> 
    57                              <1> 	cpu     186
    58                              <1> ;
    59                              <1> ;
    60                              <1> ; IBM model byte -- must be less than a 286
    61                              <1> ;
    62                              <1> 
    63                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    64                              <1> SUBMODEL_BYTE		equ	00h	;  "
    65                              <1> 
    66                              <1> 
    67                              <1> ; 80188 peripheral control register block address
    68                              <1> CPU_CSCR	        equ	0FF00h
    69                              <1> 
    70                              <1> ; Compatible Mode registers
    71                              <1> 
    72                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    73                              <1> 
    74                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    75                              <1> 
    76                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    77                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    78                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    79                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    80                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    81                              <1> 
    82                              <1> ; Enhanced Mode registers
    83                              <1> 
    84                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    85                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    86                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    87                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    88                              <1> 
    89                              <1> 
    90                              <1> ; On-board internal peripheral equates
    91                              <1> ; Programmable Interrupt Controller
    92                              <1> PIC	        equ	CPU_CSCR+020H
    93                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    94                              <1> PIC_POLLR	equ	PIC+4
    95                              <1> PIC_POLLSR	equ	PIC+6
    96                              <1> PIC_IMASK	equ	PIC+8
    97                              <1> PIC_PMREG	equ	PIC+0AH
    98                              <1> PIC_SRVR	equ	PIC+0CH
    99                              <1> PIC_IRQR	equ	PIC+0EH
   100                              <1> PIC_IRQSR	equ	PIC+10H
   101                              <1> PIC_TCR	        equ	PIC+12H
   102                              <1> PIC_DMA0CR	equ	PIC+14H
   103                              <1> PIC_DMA1CR	equ	PIC+16H
   104                              <1> PIC_I0CON	equ	PIC+18H
   105                              <1> PIC_I1CON	equ	PIC+1AH
   106                              <1> PIC_I2CON	equ	PIC+1CH
   107                              <1> PIC_I3CON	equ	PIC+1EH
   108                              <1> 
   109                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   110                              <1> 
   111                              <1> ; Interrupt masks (Master Mode)
   112                              <1> ;
   113                              <1> mask_timer_all          equ     0001h
   114                              <1> mask_dma0               equ     0004h
   115                              <1> mask_dma1               equ     0008h
   116                              <1> mask_int0               equ     0010h
   117                              <1> mask_int1               equ     0020h
   118                              <1> mask_int2               equ     0040h
   119                              <1> mask_int3               equ     0080h
   120                              <1> 
   121                              <1> 
   122                              <1> 
   123                              <1> ; Timers
   124                              <1> TIM0	        equ	CPU_CSCR+050H
   125                              <1> TIM1	        equ	CPU_CSCR+058H
   126                              <1> TIM2	        equ	CPU_CSCR+060H
   127                              <1> 
   128                              <1> TCNT	        equ	0	; count register
   129                              <1> CMPA	        equ	2	; max count A
   130                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   131                              <1> TCON	        equ	6	; mode/control word
   132                              <1> 
   133                              <1> ; Timer control bits:
   134                              <1> tc_EN           equ     8000h   ; Enable bit
   135                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   136                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   137                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   138                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   139                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   140                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   141                              <1> tc_EXT          equ     0004h   ; External clock
   142                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   143                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   144                              <1> 
   145                              <1> 
   146                              <1> 
   147                              <1> 
   148                              <1> ; DMA
   149                              <1> DMA0	        equ	CPU_CSCR+0C0H
   150                              <1> DMA1	        equ	CPU_CSCR+0D0H
   151                              <1> DMASPL	        equ	0	; source pointer low
   152                              <1> DMASPU	        equ	2	; source pointer high
   153                              <1> DMADPL	        equ	4	; destination pointer low
   154                              <1> DMADPU	        equ	6	; destination pointer high
   155                              <1> DMATC	        equ	8	; terminal count
   156                              <1> DMACW	        equ	0AH	; control word
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> 
   161                              <1> 
   162                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   163                              <1> ;
   164                              <1> ;       SBC-188 external devices
   165                              <1> ;
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> 
   168                              <1> IO_BASE			equ	0400h
   169                              <1> 
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> 
   176                              <1> uart_base               equ     IO_BASE+0280h
   177                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   178                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   179                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   180                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   181                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   182                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   183                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   184                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   185                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   186                              <1> uart_sr			equ	uart_base+7	;Scratch
   187                              <1> 
   188                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   189                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   190                              <1> 
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   193                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   194                              <1> CTRL259		equ	IO_BASE+0238H
   195                              <1> ; LEDS are at addresses 0..3
   196                              <1> ; other control ports on 4..7
   197                              <1> LED0		equ	CTRL259+0
   198                              <1> LED1		equ	LED0+1
   199                              <1> LED2		equ	LED0+2
   200                              <1> LED3		equ	LED0+3
   201                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   202                              <1> ;unused		equ	CTRL259+5
   203                              <1> ;unused		equ	CTRL259+6
   204                              <1> ;unused		equ	CTRL259+7
   205                              <1> 
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   208                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   209                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   210                              <1> 
   211                              <1> 
   212                              <1> 
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> ; Floppy controller (Duodyne Disk IO)
   215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   216                              <1> FDC	        equ	IO_BASE+0080H
   217                              <1> FDC_MSR         equ     FDC
   218                              <1> FDC_DATA        equ     FDC+1
   219                              <1> FDC_TC	        equ	FDC+2
   220                              <1> FDC_RES	        equ	FDC+3
   221                              <1> FDC_LDCR	equ	FDC+5
   222                              <1> FDC_LDOR	equ	FDC+6
   223                              <1> FDC_DACK        equ	FDC+6
   224                              <1> FDC_DACK_TC     equ     FDC+7
   225                              <1> 
   226                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   227                              <1> ; CH376 controller (Duodyne Multi IO)
   228                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                              <1> CH376	        equ	IO_BASE+004EH
   230                              <1> 
   231                              <1> 
   232                              <1> 
   233                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   235                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   236                              <1> RTC	equ	IO_BASE+0094H
   237                              <1> 
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   240                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   241                              <1> PPI	        equ	IO_BASE+0088H
   242                              <1> 
   243                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   244                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   245                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   246                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   247                              <1> 
   248                              <1> portA           equ     PPI+0   ;
   249                              <1> portB           equ     PPI+1   ;
   250                              <1> portC           equ     PPI+2   ;
   251                              <1> 
   252                              <1> ; end CPUREGS.ASM
    31                                  %include	"equates.asm"
    32                              <1> ;========================================================================
    33                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    34                              <1> ;========================================================================
    35                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    36                              <1> ;
    37                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    38                              <1> ;
    39                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    40                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    41                              <1> ;
    42                              <1> ; This program is free software: you can redistribute it and/or modify
    43                              <1> ; it under the terms of the GNU General Public License as published by
    44                              <1> ; the Free Software Foundation, either version 3 of the License, or
    45                              <1> ; (at your option) any later version.
    46                              <1> ;
    47                              <1> ; This program is distributed in the hope that it will be useful,
    48                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    49                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    50                              <1> ; GNU General Public License for more details.
    51                              <1> ;
    52                              <1> ; You should have received a copy of the GNU General Public License
    53                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    54                              <1> ;
    55                              <1> ;========================================================================
    56                              <1> 
    57                              <1>         global  FPEM_segment
    58                              <1> 
    59                              <1> 
    60                              <1> %include "segdef.asm"
    61                              <2> ;========================================================================
    62                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    63                              <2> ;========================================================================
    64                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    65                              <2> ;
    66                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    67                              <2> ;
    68                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    69                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    70                              <2> ;
    71                              <2> ; This program is free software: you can redistribute it and/or modify
    72                              <2> ; it under the terms of the GNU General Public License as published by
    73                              <2> ; the Free Software Foundation, either version 3 of the License, or
    74                              <2> ; (at your option) any later version.
    75                              <2> ;
    76                              <2> ; This program is distributed in the hope that it will be useful,
    77                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    78                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    79                              <2> ; GNU General Public License for more details.
    80                              <2> ;
    81                              <2> ; You should have received a copy of the GNU General Public License
    82                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    83                              <2> ;
    84                              <2> ;========================================================================
    85                              <2> 
    86                              <2> %ifndef __SEGDEF_
    87                              <2> %define __SEGDEF_
    88                              <2> 
    89                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    90                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    91                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    92                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    93                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    94                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    95                              <2> 
    96                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    97                              <2> 
    98                              <2> %endif
    99                              <2> 
    61                              <1> %include "ascii.asm"
    62                              <2> ; ascii.asm
    63                              <2> ;
    64                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    65                              <2> 
    66                              <2> NUL     equ     00h
    67                              <2> BEL     equ     (CTRL & 'G')
    68                              <2> BS      equ     08h		; ^H
    69                              <2> HT      equ     09h		; ^I
    70                              <2> LF	equ	0Ah		; ^J
    71                              <2> NL      equ     LF
    72                              <2> VT	equ	0Bh		; ^K
    73                              <2> FWD	equ	0Ch		; ^L
    74                              <2> CR	equ	0Dh
    75                              <2> XON     equ     (CTRL & 'Q')
    76                              <2> XOFF    equ     (CTRL & 'S')
    77                              <2> DC1     equ     XON
    78                              <2> DC3     equ     XOFF
    79                              <2> ESC     equ	1Bh
    80                              <2> 
    81                              <2> 
    62                              <1> 
    63                              <1> 
    64                              <1> ; POST error codes. Presently one byte but can expand to word.
    65                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    66                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    67                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    68                              <1> ER_FDC	equ	08h		; Bad FDC
    69                              <1> ER_UNK1	equ	10h		; {unassigned}
    70                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    71                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    72                              <1> ER_UNK2	equ	80h		; {unassigned}
    73                              <1> 
    74                              <1> 
    75                              <1> 
    76                              <1> ;; ************************ BIOS Data Segment ******************************
    77                              <1> ;; BIOS data segment - not all will  be used
    78                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    79                              <1> %include "bda.inc"
    80                              <2> ;/*======================================================================
    81                              <2> ; bda.inc -- BIOS data area definitions
    82                              <2> ;========================================================================
    83                              <2> ;   for the N8VEM SBC-188
    84                              <2> ;
    85                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    86                              <2> ;
    87                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    88                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    89                              <2> ;
    90                              <2> ; This program is free software: you can redistribute it and/or modify
    91                              <2> ; it under the terms of the GNU General Public License as published by
    92                              <2> ; the Free Software Foundation, either version 3 of the License, or
    93                              <2> ; (at your option) any later version.
    94                              <2> ;
    95                              <2> ; This program is distributed in the hope that it will be useful,
    96                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    97                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    98                              <2> ; GNU General Public License for more details.
    99                              <2> ;
   100                              <2> ; You should have received a copy of the GNU General Public License
   101                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   102                              <2> ;
   103                              <2> ;========================================================================
   104                              <2> 
   105                              <2> 			;*/ extern				/*
   106                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   107 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   108 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   109 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   110                              <2> ;	dw	?		; 40:10 	; Equipment present word
   111                              <2> ;  						;  = (1 iff floppies) *     1.
   112                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   113                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   114                              <2> ;  						;  + (init crt mode ) *    16.
   115                              <2> ;  						;  + (# of floppies ) *    64.
   116                              <2> ;  						;  + (# serial ports) *   512.
   117                              <2> ;  						;  + (1 iff toy port) *  4096.
   118                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   119                              <2> ;  						;  + (# parallel LPT) * 16384.
   120 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   121 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   122                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   123 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   124 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   125                              <2> ;;---------------[Keyboard data area]------------;
   126 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   127                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;
   128 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   129 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   130 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   131 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   132                              <2> kbd_buffer_last	equ	$	;*/				/*
   133                              <2> ;;---------------[Diskette data area]------------;
   134 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   135 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   136 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   137 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   138                              <2> ;				Floppy return code stat byte
   139                              <2> ;				;  1 = bad ic 765 command req.
   140                              <2> ;				;  2 = address mark not found
   141                              <2> ;				;  3 = write to protected disk
   142                              <2> ;				;  4 = sector not found
   143                              <2> ;				;  8 = data late (DMA overrun)
   144                              <2> ;				;  9 = DMA failed 64K page end
   145                              <2> ;				; 16 = bad CRC on floppy read
   146                              <2> ;				; 32 = bad NEC 765 controller
   147                              <2> ;				; 64 = seek operation failed
   148                              <2> ;				;128 = disk drive timed out
   149 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   150                              <2> ;;---------------[Video display area]------------;
   151 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   152                              <2> ;			 	; Current CRT mode  (software)
   153                              <2> ;				;  0 = 40 x 25 text (no color)
   154                              <2> ;				;  1 = 40 x 25 text (16 color)
   155                              <2> ;				;  2 = 80 x 25 text (no color)
   156                              <2> ;				;  3 = 80 x 25 text (16 color)
   157                              <2> ;				;  4 = 320 x 200 grafix 4 color
   158                              <2> ;				;  5 = 320 x 200 grafix 0 color
   159                              <2> ;				;  6 = 640 x 200 grafix 0 color
   160                              <2> ;				;  7 = 80 x 25 text (mono card)
   161 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   162 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   163 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   164 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   165 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   166 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   167 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   168 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   169 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   170                              <2> ;;---------------[Used to setup ROM]-------------;
   171 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   172 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   173                              <2> ;;---------------[Timer data area]---------------;
   174 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   175 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   176                              <2> ;;---------------[System data area]--------------;
   177 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   178 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   179                              <2> ;;---------------[Hard disk scratchpad]----------;
   180 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   181                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   182 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   183 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   184                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   185 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   186 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   187                              <2> ;;---------------[EGA stuff]---------------------;
   188 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   189                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   190 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   191 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   192 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   193 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   194 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   195                              <2> ;;---------------[Additional KBD flags]----------------;
   196 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   197 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   198                              <2> ;;---------------[RTC/timer1 data]---------------------;
   199 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   200 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   201 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h,
   202                              <2> ;;---------------[Cassette I/O stuff]------------------;
   203 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   204 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   205                              <2> ;									Post Acknowleged=00;
   206 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   207 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   208 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   209                              <2> ;
   210 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   211 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   212 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   213 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   214                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   215 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   216 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   217 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   218 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   219 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   220 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   221 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   222 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   223 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   224 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   225 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   226 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   227 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   228 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   229 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   230                              <2> ;
   231                              <2> ;
   232                              <2> 
   233 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   234                              <2> 
   235 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   236                              <2> 
   237 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   238 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   239                              <2> 
   240 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib
   241                              <2> 
   242 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   243                              <2> 
   244 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   245                              <2> 
   246 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz
   247                              <2> ;								   CPU clock is half of this
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> ;
   250                              <2> ;  System configuration stuff below
   251                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   252                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   253                              <2> %if 0				;*/
   254                              <2> #define FIXED_DISK_MAX 4		/*
   255                              <2> %else
   256                              <2> %define FIXED_DISK_MAX 4
   257                              <2> %endif
   258                              <2> %if 0				;*/
   259                              <2> #define PPIDE_driver 1		/*
   260                              <2> %else
   261                              <2> %define PPIDE_driver 1
   262                              <2> %endif
   263                              <2> %if 0				;*/
   264                              <2> #define USB_driver 1		/*
   265                              <2> %else
   266                              <2> %define USB_driver 1
   267                              <2> %endif
   268                              <2> 				;*/
    80                              <1> 
    81                              <1> ;  this must be the same in EQUATES.H */
    82                              <1> %if SOFT_DEBUG
    83                              <1> %define NBREAK  8
    84                              <1> %endif
    85                              <1> 
    86                              <1> 
    87                              <1> %if 0
    88                              <1>         segment _TEXT
    89                              <1> ;; *************************************************************************
    90                              <1> 
    91                              <1> 
    92                              <1> 
    93                              <1> 
    94                              <1> ;; ************************ DOS Data Segment *******************************
    95                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    96                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    97                              <1> ;						;  1 if PrtSc xeroxing screen
    98                              <1> ;						;255 if PrtSc error in xerox
    99                              <1> ;						;  ...non-grafix PrtSc in bios
   100                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
   101                              <1> ;						;  ...IBMBIO.COM buffers the
   102                              <1> ;						;  ...directory of the boot
   103                              <1> ;						;  ...device here at IPL time
   104                              <1> ;						;  ...when locating the guts
   105                              <1> ;						;  ...of the operating system
   106                              <1> ;						;  ...filename "IBMDOS.COM"
   107                              <1> ;dosdir	ends
   108                              <1> ;; *************************************************************************
   109                              <1> ;; ************************ DOS IPL Segment ********************************
   110                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   111                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   112                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   113                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   114                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   115                              <1> ;dosseg	ends					;			      !
   116                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   117                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   118                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   119                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   120                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   121                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   122                              <1> ;iplseg	ends
   123                              <1> 
   124                              <1> %endif
    32                                  
    33                                  
    34                                  offset_BP	equ	0
    35                                  offset_BX	equ	offset_BP+2
    36                                  offset_DS	equ	offset_BX+2
    37                                  offset_IP	equ	offset_DS+2
    38                                  offset_CS	equ	offset_IP+2
    39                                  offset_FLAGS	equ	offset_CS+2
    40                                  
    41                                  EOS             equ     0FFh    ; End of String
    42                                  
    43                                  MAX_ROWS	equ	24	; terminals usually have 24 rows...
    44                                  
    45                                  
    46                                  	SEGMENT _TEXT
    47                                  ;========================================================================
    48                                  ; BIOS call entry for video service functions
    49                                  ;	int  10h
    50                                  ;========================================================================
    51                                  	global  BIOS_call_10h
    52                                  BIOS_call_10h:			; Video service entry
    53                                  
    54 00000000 FB                      	sti			; Enable interrupts
    55 00000001 1E5355                  	pushm   bp,bx,ds	; Standard register save
    56 00000004 89E5                    	mov	bp,sp		; establish stack addressing
    57                                  
    58 00000006 FC                              cld                     ; do this for all functions below
    59 00000007 6A40                    	push	bios_data_seg
    60 00000009 1F                      	popm	ds		; establish addressability
    61                                  %if SOFT_DEBUG
    62                                  	push	ax
    63                                  	call	wout
    64                                  	pop	ax
    65                                  %endif
    66                                  
    67 0000000A 88E3                    	mov     bl,ah		; set to index into dispatch table
    68 0000000C 80FC14                  	cmp     ah,.max/2
    69 0000000F 7331                    	jae     exit
    70 00000011 B700                    	mov     bh,0
    71 00000013 D1E3                    	shl     bx,1		; index words
    72                                  
    73 00000015 2EFFA7[1A00]                cs	jmp     near [.dispatch+bx]
    74                                  .dispatch:
    75 0000001A [4600]                  	dw      fn00		; Set video mode
    76 0000001C [EA00]                  	dw      fn01		; Set cursor shape
    77 0000001E [0701]                  	dw      fn02		; Set cursor position
    78 00000020 [1801]                  	dw	fn03		; Get cursor position and size
    79 00000022 [4200]                  	dw	fn04		; Read light pen position
    80 00000024 [2B01]                  	dw	fn05		; Select active display page
    81 00000026 [3501]                  	dw	fn06		; Scroll up window
    82 00000028 [3501]                  	dw	fn07		; Scroll down window
    83 0000002A [A701]                  	dw	fn08		; Read character and attribute at cursor position
    84 0000002C [B401]                  	dw	fn09		; Write character and attribute at cursor position
    85 0000002E [B401]                  	dw	fn0A		; Write character only at cursor position
    86 00000030 [4200]                  	dw	fn0B		; Set background color/Set palete
    87 00000032 [4200]                  	dw	fn0C		; Write graphics pixel
    88 00000034 [4200]                  	dw	fn0D		; Read graphics pixel
    89 00000036 [0402]                  	dw	fn0E		; Teletype output
    90 00000038 [0E02]                  	dw	fn0F		; Get current video mode
    91 0000003A [4200]                  	dw	fn10		; N/A
    92 0000003C [4200]                  	dw	fn11		; N/A
    93 0000003E [4200]                  	dw	fn12		; N/A
    94 00000040 [1E02]                  	dw	fn13		; Write string
    95                                  .max	equ     $-.dispatch
    96                                  fn04:				; nobody uses a light pen
    97                                  fn0B:				; no overscan color emulation
    98                                  fn0C:				; no graphics
    99                                  fn0D:				; no graphics
   100                                  fn10:				; not implemented for CGA and MDA
   101                                  fn11:				; -//-
   102                                  fn12:				; -//-
   103                                  exit:
   104 00000042 5D5B1F                  	popm	bp,bx,ds
   105 00000045 CF                      	iret
   106                                  
   107                                  ;------------------------------------------------------------------------
   108                                  ;----------------[Video display area]------------;
   109                                  ;video_mode      resb    1
   110                                  ;       db      ?               ; 40:49         ; Current CRT mode  (software)
   111                                  ;                                               ;  0 = 40 x 25 text (no color)
   112                                  ;                                               ;  1 = 40 x 25 text (16 color)
   113                                  ;                                               ;  2 = 80 x 25 text (no color)
   114                                  ;                                               ;  3 = 80 x 25 text (16 color)
   115                                  ;                                               ;  4 = 320 x 200 grafix 4 color
   116                                  ;                                               ;  5 = 320 x 200 grafix 0 color
   117                                  ;                                               ;  6 = 640 x 200 grafix 0 color
   118                                  ;                                               ;  7 = 80 x 25 text (mono card)
   119                                  ;video_columns   resw    1
   120                                  ;       dw      ?               ; 40:4A         ; Columns on CRT screen
   121                                  ;video_regen_bytes  resw 1
   122                                  ;       dw      ?               ; 40:4C         ; Bytes in the regen region
   123                                  ;video_regen_offset resw 1
   124                                  ;       dw      ?               ; 40:4E         ; Byte offset in regen region
   125                                  ;video_cursor_pos  resw  8
   126                                  ;       dw      8 dup(?)        ; 40:50         ; Cursor pos for up to 8 pages
   127                                  ;video_cursor_mode resw  1
   128                                  ;       dw      ?               ; 40:60         ; Current cursor mode setting
   129                                  ;video_page      resb    1
   130                                  ;       db      ?               ; 40:62         ; Current page on display
   131                                  ;video_base_seg  resw    1
   132                                  ;       dw      ?               ; 40:63         ; Base addres (B000h or B800h)
   133                                  ;video_hw_mode   resb    1
   134                                  ;       db      ?               ; 40:65         ; ic 6845 mode reg. (hardware)
   135                                  ;video_cga_palette resb  1
   136                                  
   137                                  
   138                                  ;========================================================================
   139                                  ; Function 00h - Set video mode
   140                                  ; Input:
   141                                  ;	AH = 00h
   142                                  ;	AL = desired video mode
   143                                  ; Output:
   144                                  ;	none
   145                                  ; XXX:
   146                                  ;	reimplement using a table?
   147                                  ;========================================================================
   148                                  fn00:
   149 00000046 065756525150            	pushm	ax,cx,dx,si,di,es
   150 0000004C 88C4                    	mov	ah,al		; save AL to AH
   151 0000004E 241F                    	and	al,1Fh		; limit modes to 0..1F
   152 00000050 3C00                    	cmp	al,0		; 0 = 40 x 25 text (no color)
   153 00000052 750C                    	jne	.1
   154 00000054 B328                    	mov	bl,40		; 40 columns
   155 00000056 B72C                    	mov	bh,2Ch		; hw mode - 40 columns, monochrome
   156 00000058 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   157 0000005B BAD403                  	mov	dx,03D4h	; color CRT base address
   158 0000005E EB3E                    	jmp	.set_mode
   159                                  .1:
   160 00000060 3C01                    	cmp	al,01		; 1 = 40 x 25 text (16 color)
   161 00000062 750C                    	jne	.2
   162 00000064 B328                    	mov	bl,40		; 40 columns
   163 00000066 B728                    	mov	bh,28h		; hw mode - 40 columns, color
   164 00000068 BE0008                  	mov	si,0800h	; page size = 2048 bytes
   165 0000006B BAD403                  	mov	dx,03D4h	; color CRT base address
   166 0000006E EB2E                    	jmp	.set_mode
   167                                  .2:
   168 00000070 3C02                    	cmp	al,02		; 2 = 80 x 25 text (no color)
   169 00000072 750C                    	jne	.3
   170 00000074 B350                    	mov	bl,80		; 80 columns
   171 00000076 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   172 00000078 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   173 0000007B BAD403                  	mov	dx,03D4h	; color CRT base address
   174 0000007E EB1E                    	jmp	.set_mode
   175                                  .3:
   176 00000080 3C03                    	cmp	al,03		; 3 = 80 x 25 text (16 color)
   177 00000082 750C                    	jne	.4
   178 00000084 B350                    	mov	bl,80		; 80 columns
   179 00000086 B729                    	mov	bh,29h		; hw mode - 80 columns, color
   180 00000088 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   181 0000008B BAD403                  	mov	dx,03D4h	; color CRT base address
   182 0000008E EB0E                    	jmp	.set_mode
   183                                  .4:
   184 00000090 3C07                    	cmp	al,07		; 7 = 80 x 25 text (mono card)
   185 00000092 754D                    	jne	.exit
   186 00000094 B350                    	mov	bl,80		; 80 columns
   187 00000096 B72D                    	mov	bh,2Dh		; hw mode - 80 columns, monochrome
   188 00000098 BE0010                  	mov	si,1000h	; page size = 4096 bytes
   189 0000009B BAB403                  	mov	dx,03B4h	; monochrome CRT base address
   190                                  
   191                                  .set_mode:
   192 0000009E A24900                  	mov	byte [video_mode],al
   193 000000A1 B000                    	mov	al,0
   194 000000A3 A26600                  	mov	[video_cga_palette],al		; clear location
   195                                  				; video_cga_palette = 0
   196                                  ;;	cld			; clear video part of BIOS data area
   197 000000A6 BF4A00                  	mov	di,video_mode+1
   198 000000A9 B91C00                  	mov	cx,video_cga_palette-video_mode-1
   199 000000AC 1E                      	pushm	ds
   200 000000AD 07                      	popm	es
   201 000000AE F3AA                        rep	stosb
   202                                  				; video_page = 0
   203                                  				; video_regen_offset = 0
   204                                  				; video_cursor_pos[0..7] = 0
   205                                  
   206 000000B0 883E6500                	mov	byte [video_hw_mode],bh
   207 000000B4 B700                    	mov	bh,0
   208 000000B6 891E4A00                	mov	word [video_columns],bx
   209 000000BA 89364C00                	mov	word [video_regen_bytes],si
   210 000000BE 89166300                	mov	word [video_base_seg],dx
   211 000000C2 B90706                  	mov	cx,0607h	; cursor start line 6, cursor end line - 7
   212 000000C5 890E6000                	mov	word [video_cursor_mode],cx
   213                                  
   214 000000C9 B307                    	mov	bl,07h		; set default attributes to 07h
   215 000000CB E81103                  	call	set_attributes
   216                                  %if SOFT_DEBUG
   217                                  	push	0x11
   218                                  	call	lites
   219                                  %endif
   220                                  
   221 000000CE F6C480                  	test	ah,80h		; if bit 7 of original AL set, don't clear
   222 000000D1 7503                    	jnz	.dont_clear
   223 000000D3 E8F402                  	call	clear_screen
   224                                  %if SOFT_DEBUG
   225                                  	push	0x13
   226                                  	call	lites
   227                                  %endif
   228                                  
   229                                  
   230                                  .dont_clear:
   231 000000D6 31D2                    	xor	dx,dx		; set cursor to 1,1
   232 000000D8 E87C02                  	call	cursor_set_pos
   233 000000DB E8CB02                  	call	cursor_show
   234 000000DE E88B02                  	call	auto_wrap_off
   235                                  
   236                                  .exit:
   237 000000E1 58595A5E5F07            	popm	ax,cx,dx,si,di,es
   238 000000E7 E958FF                  	jmp	exit
   239                                  
   240                                  ;========================================================================
   241                                  ; Function 01h - Set cursor shape
   242                                  ; Input:
   243                                  ;	AH = 01h
   244                                  ;	CH = cursor start and options
   245                                  ;		bit 7    = 0
   246                                  ;		bits 6,5 = 00 normal, other invisible
   247                                  ;		bits 4-0 = topmost scan line
   248                                  ;	CL = (bits 4-0) bottom scan line containing cursor
   249                                  ; Output:
   250                                  ;	none
   251                                  ;========================================================================
   252                                  fn01:
   253 000000EA 51                      	push	cx
   254 000000EB 890E6000                	mov	word [video_cursor_mode],cx
   255 000000EF F6C560                  	test	ch,60h
   256 000000F2 750C                    	jnz	.hide		; hide cursor
   257 000000F4 80E5E0                  	and	ch,0E0h
   258 000000F7 38CD                    	cmp	ch,cl
   259 000000F9 7705                    	ja	.hide		; hide cursor
   260 000000FB E8AB02                  	call	cursor_show	; show cursor
   261 000000FE EB03                    	jmp	.exit
   262                                  
   263                                  .hide:
   264 00000100 E88502                  	call	cursor_hide
   265                                  
   266                                  .exit:
   267 00000103 59                      	pop	cx
   268 00000104 E93BFF                  	jmp	exit
   269                                  
   270                                  ;========================================================================
   271                                  ; Function 02h - Set cursor position
   272                                  ; Input:
   273                                  ;	AH = 02h
   274                                  ;	BH = page number (0-based)
   275                                  ;	DH = row (0-based)
   276                                  ;	DL = column (0-based)
   277                                  ; Output:
   278                                  ;	none
   279                                  ;========================================================================
   280                                  fn02:
   281 00000107 52                      	push	dx
   282 00000108 88FB                    	mov	bl,bh
   283 0000010A B700                    	mov	bh,0
   284 0000010C D1E3                    	shl	bx,1
   285                                  %if !DUMB
   286 0000010E 895750                  	mov	word [video_cursor_pos+bx],dx
   287                                  %endif
   288 00000111 E84302                  	call	cursor_set_pos
   289 00000114 5A                      	pop	dx
   290 00000115 E92AFF                  	jmp	exit
   291                                  
   292                                  ;========================================================================
   293                                  ; Function 03h - Get cursor position and size
   294                                  ; Input:
   295                                  ;	AH = 03h
   296                                  ;	BH = page number (0-based)
   297                                  ; Output:
   298                                  ;	CH = cursor starting scan-line
   299                                  ;	CL = cursor ending scan-line
   300                                  ;	DH = current row (0-based)
   301                                  ;	DL = current column (0-based)
   302                                  ;========================================================================
   303                                  fn03:
   304 00000118 8B5E02                  	mov	bx,word [offset_BX+bp]
   305 0000011B 88FB                    	mov	bl,bh
   306 0000011D B700                    	mov	bh,0
   307 0000011F D1E3                    	shl	bx,1
   308 00000121 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   309 00000124 8B0E6000                	mov	cx,word [video_cursor_mode]
   310 00000128 E917FF                  	jmp	exit
   311                                  
   312                                  ;========================================================================
   313                                  ; Function 05h - Select active display page
   314                                  ; Input:
   315                                  ;	AH = 05h
   316                                  ;	AL = page number (0-based)
   317                                  ; Output:
   318                                  ;	none
   319                                  ;========================================================================
   320                                  fn05:
   321 0000012B 50                      	push	ax
   322 0000012C 2407                    	and	al,7			; allow 8 pages
   323 0000012E A26200                  	mov	byte [video_page],al
   324 00000131 58                      	pop	ax
   325 00000132 E90DFF                  	jmp	exit
   326                                  
   327                                  ;========================================================================
   328                                  ; Function 06h - Scroll up window
   329                                  ; Function 07h - Scroll down window
   330                                  ; Input:
   331                                  ;	AH = 06h/07h
   332                                  ;	AL = number of lines to scroll in (0=blank entire rectangle)
   333                                  ;	BH = video attribute to be used on blank line(s)
   334                                  ;	CH,CL = row,column of upper-left corner of rectangle to scroll
   335                                  ;	DH,DL = row,column of lower-right corner of rectangle to scroll
   336                                  ; Notes:
   337                                  ;	Due to ANSI limitations column values are ignored
   338                                  ;========================================================================
   339                                  fn06:
   340                                  fn07:
   341                                  
   342                                  %if	ANSI
   343 00000135 525150                  	pushm	ax,cx,dx
   344 00000138 8B5E02                  	mov	bx,word [offset_BX+bp]
   345 0000013B 88FB                    	mov	bl,bh
   346 0000013D E89F02                  	call	set_attributes
   347                                  
   348 00000140 08C0                    	or	al,al
   349 00000142 7506                    	jnz	.scroll
   350 00000144 88F0                    	mov	al,dh	; AL = 0 - blank rectangle
   351 00000146 28E8                    	sub	al,ch
   352 00000148 FEC0                    	inc	al
   353                                  
   354                                  .scroll:
   355 0000014A 88F2                    	mov	dl,dh		; DL = lower row
   356 0000014C 88EE                    	mov	dh,ch		; DH = upper row
   357 0000014E 89C1                    	mov	cx,ax		; save AX in CX
   358 00000150 B01B                    	mov	al,ESC		; set scroll region ESC[<row_up>;<row_down]r
   359 00000152 E87003                  	call	uart_out
   360 00000155 B05B                    	mov	al,'['
   361 00000157 E86B03                  	call	uart_out
   362 0000015A E8C501                  	call	coords_out
   363 0000015D B072                    	mov	al,'r'
   364 0000015F E86303                  	call	uart_out
   365                                  
   366 00000162 B01B                    	mov	al,ESC		; use ESC[<num_rows>S or ESC[<num_rows>T
   367 00000164 E85E03                  	call	uart_out	; to scroll the region up or down
   368 00000167 B05B                    	mov	al,'['
   369 00000169 E85903                  	call	uart_out
   370                                  
   371 0000016C BA0A30                  	mov	dx,300Ah	; '0' to DH - used for ASCII conversion
   372                                  				; 10 to DL for 10-base conversion
   373 0000016F 88C8                    	mov	al,cl		; convert to ASCII and output row number
   374 00000171 B400                    	mov	ah,0
   375 00000173 F6F2                    	div	dl
   376 00000175 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   377 00000177 E84B03                  	call	uart_out
   378 0000017A 88E0                    	mov	al,ah
   379 0000017C 00F0                    	add	al,dh		; al + '0' - convert to ASCII
   380 0000017E E84403                  	call	uart_out
   381                                  
   382 00000181 80FD07                  	cmp	ch,07h
   383 00000184 7407                    	je	.scroll_down
   384 00000186 B053                    	mov	al,'S'
   385 00000188 E83A03                  	call	uart_out	; scroll up
   386 0000018B EB05                    	jmp	.reset_scroll
   387                                  
   388                                  .scroll_down:
   389 0000018D B054                    	mov	al,'T'
   390 0000018F E83303                  	call	uart_out	; scroll down
   391                                  
   392                                  .reset_scroll:
   393 00000192 B01B                    	mov	al,ESC
   394 00000194 E82E03                  	call	uart_out
   395 00000197 B05B                    	mov	al,'['
   396 00000199 E82903                  	call	uart_out
   397 0000019C B072                    	mov	al,'r'
   398 0000019E E82403                  	call	uart_out
   399                                  .exit:
   400 000001A1 58595A                  	popm	ax,cx,dx
   401 000001A4 E99BFE                  	jmp	exit
   402                                   %endif
   403                                  ;========================================================================
   404                                  ; Function 08h - Read character and attribute at cursor position
   405                                  ; Input:
   406                                  ;	AH = 08h
   407                                  ;	BH = page number (0-based)
   408                                  ; Output:
   409                                  ;	AL = character read
   410                                  ;	BH = video attribute
   411                                  ; Notes:
   412                                  ;	Impossible to emulate, returns AL = 20h, BH = 07h
   413                                  ;========================================================================
   414                                  fn08:
   415 000001A7 B020                    	mov	al,20h
   416 000001A9 8B5E02                  	mov	bx,word [offset_BX+bp]
   417 000001AC B707                    	mov	bh,07h
   418 000001AE 895E02                  	mov	word [offset_BX+bp],bx
   419 000001B1 E98EFE                  	jmp	exit
   420                                  
   421                                  ;========================================================================
   422                                  ; Function 09h - Write character and attribute at cursor position
   423                                  ; Function 0Ah - Write character only at cursor position
   424                                  ; Input:
   425                                  ;	AH = 09h/0Ah
   426                                  ;	AL = character to write
   427                                  ;	BH = page number (0-based)
   428                                  ;	BL = video attribute (AH = 09h only)
   429                                  ;	CX = repeat count
   430                                  ; Output:
   431                                  ;	none
   432                                  ;========================================================================
   433                                  fn09:
   434                                  fn0A:
   435                                  %if UART
   436 000001B4 525150                  	pushm	ax,cx,dx
   437 000001B7 3C20                    	cmp	al,20h
   438 000001B9 7243                    	jb	.exit		; non-printable character
   439 000001BB 3C7F                    	cmp	al,7Fh
   440 000001BD 743F                    	je	.exit		; non-printable character
   441 000001BF 8B5E02                      	mov	bx,word [offset_BX+bp]
   442 000001C2 80FC0A                  	cmp	ah,0Ah
   443 000001C5 7403                    	je	.no_attributes
   444 000001C7 E81502                  	call	set_attributes
   445                                  .no_attributes:
   446 000001CA 88FB                    	mov	bl,bh
   447 000001CC B700                    	mov	bh,0
   448 000001CE D1E3                    	shl	bx,1
   449 000001D0 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   450                                  
   451                                  .loop:
   452 000001D3 E8EF02                  	call	uart_out
   453                                  
   454 000001D6 FEC2                    	inc	dl		; increment column
   455 000001D8 3A164A00                	cmp	dl,byte [video_columns]
   456 000001DC 7304                    	jae	.next_line
   457 000001DE E2F3                    	loop	.loop
   458 000001E0 EB0E                    	jmp	.exit_loop
   459                                  
   460                                  .next_line:
   461 000001E2 B200                    	mov	dl,0
   462 000001E4 FEC6                    	inc	dh		; increment row
   463 000001E6 80FE18                  	cmp	dh,MAX_ROWS	; on the last row? (assume 25 rows)
   464 000001E9 7305                    	jae	.exit_loop
   465 000001EB E86901                  	call	cursor_set_pos
   466 000001EE E2E3                    	loop	.loop
   467                                  
   468                                  .exit_loop:
   469 000001F0 8A1E6200                	mov	bl,byte [video_page]
   470 000001F4 B700                    	mov	bh,0
   471 000001F6 D1E3                    	shl	bx,1
   472                                  %if !DUMB
   473 000001F8 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   474                                  %endif
   475 000001FB E85901                  	call	cursor_set_pos
   476                                  .exit:
   477 000001FE 58595A                  	popm	ax,cx,dx
   478                                  %endif
   479 00000201 E93EFE                  	jmp	exit
   480                                  
   481                                  ;========================================================================
   482                                  ; Function 0Eh - Teletype output
   483                                  ; Input:
   484                                  ;	AH = 0Eh
   485                                  ;	AL = character to write
   486                                  ;	BH = page number (0-based)
   487                                  ;	BL = foreground color (graphics modes only, ignored)
   488                                  ; Output:
   489                                  ;	none
   490                                  ;========================================================================
   491                                  fn0E:
   492 00000204 5250                    	pushm	ax,dx		; preserve AX, too
   493                                  %if UART
   494 00000206 E8BC02                  	call	uart_out	; we've got a regular character
   495                                  %endif
   496 00000209 585A                    	popm	ax,dx		; restore AX also
   497 0000020B E934FE                  	jmp	exit
   498                                  
   499                                  ;========================================================================
   500                                  ; Function 0Fh - Get current video mode
   501                                  ; Input:
   502                                  ;	AH = 0Fh
   503                                  ; Output:
   504                                  ;	AH = number of character columns
   505                                  ;	AL = video mode
   506                                  ;	BH = active page
   507                                  ;========================================================================
   508                                  fn0F:
   509 0000020E A06200                  	mov	al,byte [video_page]
   510 00000211 884603                  	mov	byte [bp+offset_BX+1],al	; set BH for return
   511 00000214 8A264A00                	mov	ah,byte [video_columns]		; set AH
   512 00000218 A04900                  	mov	al,byte [video_mode]		; set AL
   513 0000021B E924FE                  	jmp	exit
   514                                  
   515                                  ;========================================================================
   516                                  ; Function 13h - Write string
   517                                  ; Input:
   518                                  ;	AH = 13h
   519                                  ;	AL = 00h - use video attribute in BL, don't move cursor
   520                                  ;	AL = 01h - use video attribute in BL, update cursor
   521                                  ;		BL = video attribute
   522                                  ;	AL = 02h - use video attribute from string, don't move cursor
   523                                  ;	AL = 03h - use video attribute from string, update cursor
   524                                  ;	BH = page number (0-based)
   525                                  ;	CX = length of the string
   526                                  ;	DH = row (0-based)
   527                                  ;	DL = column (0-based)
   528                                  ;	ES:BP = pointer to the string
   529                                  ; Output:
   530                                  ;	none
   531                                  ; XXX:
   532                                  ;	When printing the last character on the screen cursor will be moved
   533                                  ;	to the first column of the last line
   534                                  ;========================================================================
   535                                  fn13:
   536 0000021E 5251                    	pushm	cx,dx
   537 00000220 5550                    	pushm	ax,bp
   538 00000222 8B6E00                  	mov	bp,word [offset_BP+bp]
   539 00000225 E82F01                  	call	cursor_set_pos
   540 00000228 A802                    	test	al,02h
   541 0000022A 756D                    	jnz	fn13_2		; read attribute from the string implementation
   542 0000022C E8B001                  	call	set_attributes
   543                                  .loop:
   544 0000022F 268A4600                    es	mov	al,byte [bp]
   545 00000233 45                      	inc	bp
   546 00000234 3C07                    	cmp	al,07h
   547 00000236 743B                    	je	.bell
   548 00000238 3C0A                    	cmp	al,0Ah
   549 0000023A 743F                    	je	.lf
   550 0000023C 3C0D                    	cmp	al,0Dh
   551 0000023E 744C                    	je	.cr
   552 00000240 3C20                    	cmp	al,20h
   553 00000242 7251                    	jb	.next		; control character
   554 00000244 3C7F                    	cmp	al,7Fh
   555 00000246 744D                    	je	.next		; DEL
   556                                  
   557 00000248 E87A02                  	call	uart_out
   558                                  
   559 0000024B FEC2                    	inc	dl		; increment column
   560 0000024D 3A164A00                	cmp	dl,byte [video_columns]
   561 00000251 7305                    	jae	.next_line
   562 00000253 E2DA                    	loop	.loop
   563 00000255 E9AB00                  	jmp	fn13_exit
   564                                  
   565                                  .next_line:
   566 00000258 B200                    	mov	dl,0
   567 0000025A FEC6                    	inc	dh		; increment row
   568 0000025C 80FE18                  	cmp	dh,MAX_ROWS
   569 0000025F 7203E99F00              	jae	fn13_exit
   570 00000264 B00D                    	mov	al,0Dh
   571 00000266 E85C02                  	call	uart_out
   572 00000269 B00A                    	mov	al,0Ah
   573 0000026B E85702                  	call	uart_out
   574 0000026E E2BF                    	loop	.loop
   575 00000270 E99000                  	jmp	fn13_exit
   576                                  
   577                                  .bell:
   578 00000273 E84F02                  	call	uart_out
   579 00000276 E2B7                    	loop	.loop
   580 00000278 E98800                  	jmp	fn13_exit
   581                                  
   582                                  .lf:
   583 0000027B 80FE18                  	cmp	dh,24
   584 0000027E 7203E98000              	jae	fn13_exit
   585 00000283 FEC6                    	inc	dh
   586 00000285 E83D02                  	call	uart_out
   587 00000288 E2A5                    	loop	.loop
   588 0000028A EB77                    	jmp	fn13_exit
   589                                  
   590                                  .cr:
   591 0000028C B200                    	mov	dl,0
   592 0000028E E83402                  	call	uart_out
   593 00000291 E29C                    	loop	.loop
   594 00000293 EB6E                    	jmp	fn13_exit
   595                                  
   596                                  .next:
   597 00000295 E298                    	loop	.loop
   598 00000297 EB6A                    	jmp	fn13_exit
   599                                  
   600                                  fn13_2:
   601 00000299 8A3E4A00                	mov	bh,byte [video_columns]
   602                                  .loop:
   603 0000029D 268A4600                    es	mov	al,byte [bp]
   604 000002A1 45                      	inc	bp
   605 000002A2 3C07                    	cmp	al,07h
   606 000002A4 743C                    	je	.bell
   607 000002A6 3C0A                    	cmp	al,0Ah
   608 000002A8 743F                    	je	.lf
   609 000002AA 3C0D                    	cmp	al,0Dh
   610 000002AC 7449                    	je	.cr
   611 000002AE 3C20                    	cmp	al,20h
   612 000002B0 724E                    	jb	.next		; control character
   613 000002B2 3C7F                    	cmp	al,7Fh
   614 000002B4 744A                    	je	.next		; DEL
   615                                  
   616 000002B6 268A5E00                    es	mov	bl,byte [bp]
   617 000002BA 45                      	inc	bp
   618 000002BB E82101                  	call	set_attributes
   619                                  
   620 000002BE E80402                  	call	uart_out
   621                                  
   622 000002C1 FEC2                    	inc	dl		; increment column
   623 000002C3 38FA                    	cmp	dl,bh		; bh = video columns
   624 000002C5 7304                    	jae	.next_line
   625 000002C7 E2D4                    	loop	.loop
   626 000002C9 EB38                    	jmp	fn13_exit
   627                                  
   628                                  .next_line:
   629 000002CB B200                    	mov	dl,0
   630 000002CD FEC6                    	inc	dh		; increment row
   631 000002CF 80FE18                  	cmp	dh,MAX_ROWS
   632 000002D2 732F                    	jae	fn13_exit
   633                                  ;	call	cursor_set_pos
   634 000002D4 B00D                    	mov	al,0Dh
   635 000002D6 E8EC01                  	call	uart_out
   636 000002D9 B00A                    	mov	al,0Ah
   637 000002DB E8E701                  	call	uart_out
   638 000002DE E2BD                    	loop	.loop
   639 000002E0 EB21                    	jmp	fn13_exit
   640                                  
   641                                  .bell:
   642 000002E2 E8E001                  	call	uart_out
   643 000002E5 E2B6                    	loop	.loop
   644 000002E7 EB1A                    	jmp	fn13_exit
   645                                  
   646                                  .lf:
   647 000002E9 80FE18                  	cmp	dh,24
   648 000002EC 7315                    	jae	fn13_exit
   649 000002EE FEC6                    	inc	dh
   650 000002F0 E8D201                  	call	uart_out
   651 000002F3 E2A8                    	loop	.loop
   652 000002F5 EB0C                    	jmp	fn13_exit
   653                                  
   654                                  .cr:
   655 000002F7 B200                    	mov	dl,0
   656 000002F9 E8C901                  	call	uart_out
   657 000002FC E29F                    	loop	.loop
   658 000002FE EB03                    	jmp	fn13_exit
   659                                  
   660                                  .next:
   661 00000300 45                      	inc	bp		; skip the attribute
   662 00000301 E29A                    	loop	.loop
   663                                  
   664                                  fn13_exit:
   665 00000303 585D                    	popm	ax,bp
   666 00000305 8B5E02                  	mov	bx,word [offset_BX+bp]
   667 00000308 88FB                    	mov	bl,bh
   668 0000030A B700                    	mov	bh,0
   669 0000030C D1E3                    	shl	bx,1		; bx = page number * 2
   670 0000030E A801                    	test	al,01h		; AL, bit 0 = 1 - update cursor
   671 00000310 7508                    	jne	.update_cursor
   672 00000312 8B5750                  	mov	dx,word [video_cursor_pos+bx]
   673 00000315 E83F00                  	call	cursor_set_pos
   674 00000318 EB03                    	jmp	.exit
   675                                  
   676                                  .update_cursor:
   677 0000031A 895750                  	mov	word [video_cursor_pos+bx],dx
   678                                  
   679                                  .exit:
   680 0000031D 595A                    	popm	cx,dx
   681 0000031F E920FD                  	jmp	exit
   682                                  
   683                                  ;========================================================================
   684                                  ; coords_out - Output coordinates in ANSI format X;Y
   685                                  ; Input:
   686                                  ;	DH = X coordinate
   687                                  ;	DL = Y coordinate
   688                                  ; Output:
   689                                  ;	AX is trashed
   690                                  ;	none
   691                                  ;========================================================================
   692                                  coords_out:
   693                                  %if	ANSI
   694 00000322 5251                    	pushm	cx,dx
   695 00000324 81C20101                	add	dx,0101h
   696 00000328 B90A30                  	mov	cx,300Ah	; '0' to CH - used for ASCII conversion
   697                                  				; 10 to CL for 10-base conversion
   698 0000032B 88F0                    	mov	al,dh		; convert to ASCII and output row number
   699 0000032D B400                    	mov	ah,0
   700 0000032F F6F1                    	div	cl
   701 00000331 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   702 00000333 E88F01                  	call	uart_out
   703 00000336 88E0                    	mov	al,ah
   704 00000338 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   705 0000033A E88801                  	call	uart_out
   706                                  
   707 0000033D B03B                    	mov	al,';'		; output ';' delimiter
   708 0000033F E88301                  	call	uart_out
   709                                  
   710 00000342 88D0                    	mov	al,dl		; convert to ASCII and output column number
   711 00000344 B400                    	mov	ah,0
   712 00000346 F6F1                    	div	cl
   713 00000348 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   714 0000034A E87801                  	call	uart_out
   715 0000034D 88E0                    	mov	al,ah
   716 0000034F 00E8                    	add	al,ch		; al + '0' - convert to ASCII
   717 00000351 E87101                  	call	uart_out
   718 00000354 595A                    	popm	cx,dx
   719                                  %endif	; ANSI
   720 00000356 C3                      	ret
   721                                  
   722                                  ;========================================================================
   723                                  ; cursor_set_pos - move cursor to specified position
   724                                  ; Input:
   725                                  ;	DH = row (0-based)
   726                                  ;	DL = column (0-based)
   727                                  ; Output:
   728                                  ;	none
   729                                  ; Notes:
   730                                  ;	Uses ESC[<row>;<column>H ANSI sequence, row and column are 0-based
   731                                  ;========================================================================
   732                                  cursor_set_pos:
   733                                  %if	ANSI
   734 00000357 50                      	push	ax
   735 00000358 B01B                    	mov	al,ESC		; output CSI sequence
   736 0000035A E86801                  	call	uart_out
   737 0000035D B05B                    	mov	al,'['
   738 0000035F E86301                  	call	uart_out
   739 00000362 E8BDFF                  	call	coords_out
   740 00000365 B048                    	mov	al,'H'		; output 'H' command
   741 00000367 E85B01                  	call	uart_out
   742 0000036A 58                      	pop	ax
   743                                  %elif	DUMB
   744                                  ; setting the cursor position back on the same line can be done
   745                                  ; by emitting the correct number of BS (backspace) characters
   746                                  	xchg	dx,[video_cursor_pos + 0]	; page 0 always
   747                                  	sub	dl,[video_cursor_pos]		; - delta
   748                                  	jz	.5
   749                                  	mov	ax,0x0100+FWD		; forward space is ^L
   750                                  	js	.1
   751                                  	mov	ax,0xFF00+BS		;
   752                                  .1:	call	uart_out
   753                                  	add	dl,ah
   754                                  	jnz	.1
   755                                  
   756                                  .5:	sub	dh,[video_cursor_pos+1]
   757                                  	jz	.9
   758                                  	mov	ax,0x0100+LF		;line feed (down)
   759                                  	js	.7
   760                                  	mov	ax,0xFF00+VT		;line feed (up)
   761                                  .7:	call	uart_out
   762                                  	add	dh,ah
   763                                  	jnz	.7
   764                                  .9:
   765                                  %endif	; ANSI
   766 0000036B C3                      	ret
   767                                  
   768                                  ;========================================================================
   769                                  ; auto_wrap_off - disable auto wraparound mode
   770                                  ; Input:
   771                                  ;	none
   772                                  ; Output:
   773                                  ;	none
   774                                  ; Notes:
   775                                  ;	Uses ESC[?7l ANSI sequence
   776                                  ;========================================================================
   777                                  auto_wrap_off:
   778                                  %if	ANSI
   779 0000036C 50                      	push	ax
   780 0000036D B01B                    	mov	al,ESC
   781 0000036F E85301                  	call	uart_out
   782 00000372 B05B                    	mov	al,'['
   783 00000374 E84E01                  	call	uart_out
   784 00000377 B03F                    	mov	al,'?'
   785 00000379 E84901                  	call	uart_out
   786 0000037C B037                    	mov	al,'7'
   787 0000037E E84401                  	call	uart_out
   788 00000381 B06C                    	mov	al,'l'
   789 00000383 E83F01                  	call	uart_out
   790 00000386 58                      	pop	ax
   791                                  %endif	; ANSI
   792 00000387 C3                      	ret
   793                                  
   794                                  ;========================================================================
   795                                  ; cursor_hide - hide cursor
   796                                  ; Input:
   797                                  ;	none
   798                                  ; Output:
   799                                  ;	none
   800                                  ; Notes:
   801                                  ;	Uses ESC[?25l ANSI sequence
   802                                  ;========================================================================
   803                                  cursor_hide:
   804                                  %if	ANSI
   805 00000388 50                      	push	ax
   806 00000389 B01B                    	mov	al,ESC
   807 0000038B E83701                  	call	uart_out
   808 0000038E B05B                    	mov	al,'['
   809 00000390 E83201                  	call	uart_out
   810 00000393 B03F                    	mov	al,'?'
   811 00000395 E82D01                  	call	uart_out
   812 00000398 B032                    	mov	al,'2'
   813 0000039A E82801                  	call	uart_out
   814 0000039D B035                    	mov	al,'5'
   815 0000039F E82301                  	call	uart_out
   816 000003A2 B06C                    	mov	al,'l'
   817 000003A4 E81E01                  	call	uart_out
   818 000003A7 58                      	pop	ax
   819                                  %endif	; ANSI
   820 000003A8 C3                      	ret
   821                                  
   822                                  ;========================================================================
   823                                  ; cursor_show - show cursor
   824                                  ; Input:
   825                                  ;	none
   826                                  ; Output:
   827                                  ;	none
   828                                  ; Notes:
   829                                  ;	Uses ESC[?25h ANSI sequence
   830                                  ;========================================================================
   831                                  cursor_show:
   832                                  %if	ANSI
   833 000003A9 50                      	push	ax
   834 000003AA B01B                    	mov	al,ESC
   835 000003AC E81601                  	call	uart_out
   836 000003AF B05B                    	mov	al,'['
   837 000003B1 E81101                  	call	uart_out
   838 000003B4 B03F                    	mov	al,'?'
   839 000003B6 E80C01                  	call	uart_out
   840 000003B9 B032                    	mov	al,'2'
   841 000003BB E80701                  	call	uart_out
   842 000003BE B035                    	mov	al,'5'
   843 000003C0 E80201                  	call	uart_out
   844 000003C3 B068                    	mov	al,'h'
   845 000003C5 E8FD00                  	call	uart_out
   846 000003C8 58                      	pop	ax
   847                                  %endif	; ANSI
   848 000003C9 C3                      	ret
   849                                  
   850                                  ;========================================================================
   851                                  ; clear_screen
   852                                  ; Input:
   853                                  ;	none
   854                                  ; Output:
   855                                  ;	AL is trashed
   856                                  ;========================================================================
   857                                  clear_screen:
   858                                  %if   ANSI
   859 000003CA B01B                    	mov	al,ESC		; clear screen - ESC[2J
   860 000003CC E8F600                  	call	uart_out
   861 000003CF B05B                    	mov	al,'['
   862 000003D1 E8F100                  	call	uart_out
   863 000003D4 B032                    	mov	al,'2'
   864 000003D6 E8EC00                  	call	uart_out
   865 000003D9 B04A                    	mov	al,'J'
   866 000003DB E8E700                  	call	uart_out
   867                                  %endif  ; ANSI
   868 000003DE C3                      	ret
   869                                  
   870                                  ;========================================================================
   871                                  ; set_attributes - set specified background/foreground color
   872                                  ; Input:
   873                                  ;	BL = attributes
   874                                  ;		color mode:
   875                                  ;			bit 7 	 = 1 - blinking
   876                                  ;			bits 6-4 = background color
   877                                  ;			bits 3-0 = foreground color
   878                                  ;		color mode with high intensity background
   879                                  ;			bits 7-4 = background color
   880                                  ;			bits 3-0 = foreground color
   881                                  ;		monochrome mode
   882                                  ;			01h = underline
   883                                  ;			07h = normal
   884                                  ;			09h = bright underline
   885                                  ;			0Fh = bold
   886                                  ;			70h = reverse (black on white)
   887                                  ;			81h = blinking underline
   888                                  ;			87h = blinking normal
   889                                  ;			89h = blinking bright underline
   890                                  ;			8Fh = blinking bold
   891                                  ; Output:
   892                                  ;	none
   893                                  ; XXX:
   894                                  ;	Add attribute cache, so we won't spend time setting the same attribute again
   895                                  ;========================================================================
   896                                  set_attributes:
   897                                  %if	ANSI
   898 000003DF 50                      	push	ax
   899                                  
   900 000003E0 B01B                    	mov	al,ESC
   901 000003E2 E8E000                  	call	uart_out
   902 000003E5 B05B                    	mov	al,'['
   903 000003E7 E8DB00                  	call	uart_out
   904                                  
   905 000003EA F6C308                  	test	bl,08h	; bold?
   906 000003ED 750A                    	jnz	.bold
   907 000003EF B032                    	mov	al,'2'		; set normal mode - ESC[22m
   908 000003F1 E8D100                  	call	uart_out
   909 000003F4 E8CE00                  	call	uart_out
   910 000003F7 EB05                    	jmp	.check_mode
   911                                  
   912                                  .bold:
   913 000003F9 B031                    	mov	al,'1'		; set bold attribute - ESC[1m
   914 000003FB E8C700                  	call	uart_out
   915                                  
   916                                  .check_mode:
   917 000003FE A04900                  	mov	al,byte [video_mode]
   918 00000401 3C07                    	cmp	al,7
   919 00000403 7530                    	jne	.color
   920                                  
   921 00000405 B03B                    	mov	al,';'
   922 00000407 E8BB00                  	call	uart_out
   923                                  				; monochrome - set underline attribute
   924 0000040A 88D8                    	mov	al,bl
   925 0000040C 2407                    	and	al,7		; get foreground attribute part
   926 0000040E 3C01                    	cmp	al,1		; underlined
   927 00000410 740C                    	je	.underline
   928 00000412 B032                    	mov	al,'2'		; set not underlined attribute - ESC[24m
   929 00000414 E8AE00                  	call	uart_out
   930 00000417 B034                    	mov	al,'4'
   931 00000419 E8A900                  	call	uart_out
   932 0000041C EB05                    	jmp	.mono_to_color
   933                                  
   934                                  .underline:
   935 0000041E B034                    	mov	al,'4'		; set underlined attribute - ESC[4m
   936 00000420 E8A200                  	call	uart_out
   937                                  
   938                                  .mono_to_color:
   939 00000423 88D8                    	mov	al,bl
   940 00000425 2407                    	and	al,07h
   941 00000427 7403                    	jz	.mono_bg	; black foreground
   942 00000429 80CB07                  	or	bl,07h		; anything else is white
   943                                  .mono_bg:
   944 0000042C 88D8                    	mov	al,bl
   945 0000042E 2470                    	and	al,70h
   946 00000430 7403                    	jz	.color		; black background
   947 00000432 80CB70                  	or	bl,70h		; anything else is white
   948                                  .color:
   949 00000435 B03B                    	mov	al,';'
   950 00000437 E88B00                  	call	uart_out
   951                                  
   952 0000043A 88D8                    	mov	al,bl		; need to exchange bit 0 with 2
   953 0000043C 80E3AA                  	and	bl,0AAh		; and bit 4 with bit 6
   954 0000043F A801                    	test	al,01h
   955 00000441 7403                    	jz	.no_blue_fg
   956 00000443 80CB04                  	or	bl,04h
   957                                  .no_blue_fg:
   958 00000446 A804                    	test	al,04h
   959 00000448 7403                    	jz	.no_red_fg
   960 0000044A 80CB01                  	or	bl,01h
   961                                  .no_red_fg:
   962 0000044D A810                    	test	al,10h
   963 0000044F 7403                    	jz	.no_blue_bg
   964 00000451 80CB40                  	or	bl,40h
   965                                  .no_blue_bg:
   966 00000454 A840                    	test	al,40h
   967 00000456 7403                    	jz	.no_red_bg
   968 00000458 80CB10                  	or	bl,10h
   969                                  .no_red_bg:
   970 0000045B B033                    	mov	al,'3'		; set foreground color - ESC[3<0..7>m
   971 0000045D E86500                  	call	uart_out
   972 00000460 88D8                    	mov	al,bl
   973 00000462 2407                    	and	al,07h
   974 00000464 0430                    	add	al,'0'
   975 00000466 E85C00                  	call	uart_out
   976                                  
   977 00000469 B03B                    	mov	al,';'
   978 0000046B E85700                  	call	uart_out
   979                                  
   980 0000046E F6C380                  	test	bl,80h
   981 00000471 741F                    	jz	.normal_bg	; normal background
   982 00000473 A06500                  	mov	al,byte [video_hw_mode]
   983 00000476 A820                    	test	al,20h		; intense colors
   984 00000478 7518                    	jnz	.normal_bg	; normal background, blinking
   985                                  
   986 0000047A B031                    	mov	al,'1'		; set intense background color - ESC[10<0..7>m
   987 0000047C E84600                  	call	uart_out	; note - this is not supported everywhere
   988 0000047F B030                    	mov	al,'0'
   989 00000481 E84100                  	call	uart_out
   990 00000484 88D8                    	mov	al,bl
   991 00000486 2470                    	and	al,70h
   992 00000488 C0E804                  	shr	al,4
   993 0000048B 0430                    	add	al,'0'
   994 0000048D E83500                  	call	uart_out
   995 00000490 EB2C                    	jmp	.exit
   996                                  
   997                                  .normal_bg:
   998 00000492 B034                    	mov	al,'4'		; set background color - ESC[4<0..7>m
   999 00000494 E82E00                  	call	uart_out
  1000 00000497 88D8                    	mov	al,bl
  1001 00000499 2470                    	and	al,70h
  1002 0000049B C0E804                  	shr	al,4
  1003 0000049E 0430                    	add	al,'0'
  1004 000004A0 E82200                  	call	uart_out
  1005                                  
  1006 000004A3 B03B                    	mov	al,';'
  1007 000004A5 E81D00                  	call	uart_out
  1008                                  
  1009 000004A8 F6C380                  	test	bl,80h
  1010 000004AB 750C                    	jnz	.blink
  1011 000004AD B032                    	mov	al,'2'		; set not blinking attribute - ESC[25m
  1012 000004AF E81300                  	call	uart_out
  1013 000004B2 B035                    	mov	al,'5'
  1014 000004B4 E80E00                  	call	uart_out
  1015 000004B7 EB05                    	jmp	.exit
  1016                                  
  1017                                  .blink:
  1018 000004B9 B035                    	mov	al,'5'		; set blinking attribute - ESC[5m
  1019 000004BB E80700                  	call	uart_out
  1020                                  
  1021                                  .exit:
  1022 000004BE B06D                    	mov	al,'m'
  1023 000004C0 E80200                  	call	uart_out
  1024                                  
  1025 000004C3 58                      	pop	ax
  1026                                  %endif	; ANSI
  1027 000004C4 C3                      	ret
  1028                                  
  1029                                  ;========================================================================
  1030                                  ; uart_out - write character to serial port
  1031                                  ; Input:
  1032                                  ;	AL = character to write
  1033                                  ; Output:
  1034                                  ;	none
  1035                                  ;========================================================================
  1036                                  uart_out:
  1037 000004C5 52                      	push	dx
  1038 000004C6 50                      	push	ax
  1039                                  %if UART_DSR_PROTOCOL
  1040                                          extern  microsecond
  1041                                  .wait_dsr:
  1042                                          mov     dx,uart_msr
  1043                                  BIT_DSR         equ     1<<5
  1044                                          in      al,dx           ; read the Modem Status Register
  1045                                          test    al,BIT_DSR      ; Data Set Ready
  1046                                          jnz     .nowait
  1047                                          push    cx
  1048                                          mov     cx,100
  1049                                          call    microsecond
  1050                                          pop     cx
  1051                                          jmp     .wait_dsr
  1052                                  .nowait:
  1053                                  %endif
  1054                                  .1:
  1055 000004C7 BA8506                  	mov	dx,uart_lsr
  1056 000004CA EC                      	in	al,dx
  1057 000004CB A820                    	test	al,20h		; THRE is empty
  1058 000004CD 74F8                    	jz	.1
  1059 000004CF 58                      	pop	ax
  1060 000004D0 BA8006                  	mov	dx,uart_thr
  1061 000004D3 EE                      	out	dx,al		; write character
  1062 000004D4 5A                      	pop	dx
  1063 000004D5 C3                      	ret
  1064                                  
  1065                                  
  1066                                  ;========================================================================
  1067                                  ; video_init - initialize video service
  1068                                  ; Input:
  1069                                  ;	AL = baud rate
  1070                                  ;	DS = DGROUP
  1071                                  ; Output:
  1072                                  ;	none
  1073                                  ;========================================================================
  1074                                  	global	video_init
  1075                                  video_init:
  1076                                  		; XXX - move interrupt registration code here
  1077 000004D6 50                      	push	ax
  1078 000004D7 E80301                  	call	uart_init
  1079 000004DA BA8006                  	mov	dx,uart_base
  1080 000004DD E84801                  	call	uart_detect
  1081 000004E0 50                      	push	ax
  1082                                  %if SOFT_DEBUG
  1083                                  	extern	lites
  1084                                  	or	al,0C0h
  1085                                  	push	ax
  1086                                  	call	lites
  1087                                  	extern	crlf,boutsp,wout,bout,cout
  1088                                  %if 1
  1089                                  	pop	ax
  1090                                  	push	ax
  1091                                  	call	boutsp
  1092                                  	call	crlf
  1093                                  	pushm	dx,cx
  1094                                  	mov	cx,uart_sr-uart_iir+1
  1095                                  	mov	dx,uart_iir
  1096                                  .234:	in	al,dx
  1097                                  	call	boutsp
  1098                                  	inc	dl
  1099                                  	loop	.234
  1100                                  	popm	dx,cx
  1101                                  %endif
  1102                                  %endif
  1103 000004E1 B80700                  	mov	ax,0007h
  1104 000004E4 CD10                    	int	10h
  1105 000004E6 58                      	pop	ax
  1106                                  %if SOFT_DEBUG
  1107                                  	push	ax
  1108                                  	call	boutsp
  1109                                  	pop	ax
  1110                                  %endif
  1111 000004E7 0E                      	push	cs
  1112 000004E8 3C04                    	cmp	al,UART_16550A
  1113 000004EA 7205                    	jb	.no_fifo
  1114 000004EC 68[D605]                	push	.enabled
  1115 000004EF EB03                    	jmp	.print_uart
  1116                                  .no_fifo:
  1117 000004F1 68[D905]                	push	.disabled
  1118                                  .print_uart:
  1119 000004F4 0E                      	push	cs
  1120 000004F5 3C01                    	cmp	al,UART_8250
  1121 000004F7 7505                    	jne	.check_16450
  1122 000004F9 68[9705]                	push	.uart_8250
  1123 000004FC EB42                    	jmp	.print_hi
  1124                                  .check_16450:
  1125 000004FE 3C02                    	cmp	al,UART_16450
  1126 00000500 7505                    	jne	.check_16550
  1127 00000502 68[9C05]                	push	.uart_16450
  1128 00000505 EB39                    	jmp	.print_hi
  1129                                  .check_16550:
  1130 00000507 3C03                    	cmp	al,UART_16550
  1131 00000509 7505                    	jne	.check_16550A
  1132 0000050B 68[A805]                	push	.uart_16550
  1133 0000050E EB30                    	jmp	.print_hi
  1134                                  .check_16550A:
  1135 00000510 3C04                    	cmp	al,UART_16550A
  1136 00000512 7505                    	jne	.check_16550C
  1137 00000514 68[AE05]                	push	.uart_16550A
  1138 00000517 EB27                    	jmp	.print_hi
  1139                                  .check_16550C:
  1140 00000519 3C05                    	cmp	al,UART_16550C
  1141 0000051B 7505                    	jne	.check_16650
  1142 0000051D 68[B505]                	push	.uart_16550C
  1143 00000520 EB1E                    	jmp	.print_hi
  1144                                  .check_16650:
  1145 00000522 3C06                    	cmp	al,UART_16650
  1146 00000524 7505                    	jne	.check_16750
  1147 00000526 68[BC05]                	push	.uart_16650
  1148 00000529 EB15                    	jmp	.print_hi
  1149                                  .check_16750:
  1150 0000052B 3C07                    	cmp	al,UART_16750
  1151 0000052D 7505                    	jne	.check_16850
  1152 0000052F 68[C205]                	push	.uart_16750
  1153 00000532 EB0C                    	jmp	.print_hi
  1154                                  .check_16850:
  1155 00000534 3C08                    	cmp	al,UART_16850
  1156 00000536 7505                    	jne	.unknown
  1157 00000538 68[C805]                	push	.uart_16850
  1158 0000053B EB03                    	jmp	.print_hi
  1159                                  .unknown:
  1160 0000053D 68[CE05]                	push	.uart_unknown
  1161                                  .print_hi:
  1162 00000540 0E                      	push	cs
  1163 00000541 68[4C05]                	push	.hi
  1164                                  	extern	_cprintf
  1165 00000544 E8(0000)                	call	_cprintf	; _cprintf uses int10 0Eh
  1166 00000547 83C40C                  	add	sp,12
  1167                                  
  1168 0000054A 58                      	pop	ax
  1169                                  %if SOFT_DEBUG
  1170                                  ;;;	hlt
  1171                                  %endif
  1172 0000054B C3                      	ret
  1173                                  
  1174                                  .hi:
  1175                                  
  1176                                  %if UART
  1177 0000054C 53657269616C20492F-     	db	'Serial I/O BIOS (c) 2010 Sergey Kiselev', NL
  1177 00000555 4F2042494F53202863-
  1177 0000055E 292032303130205365-
  1177 00000567 72676579204B697365-
  1177 00000570 6C65760A           
  1178 00000574 446574656374656420-     	db	'Detected %s UART, FIFO is %sabled', NL
  1178 0000057D 257320554152542C20-
  1178 00000586 4649464F2069732025-
  1178 0000058F 7361626C65640A     
  1179                                  %endif
  1180 00000596 00                      	db	0
  1181                                  
  1182                                  .uart_8250:
  1183 00000597 3832353000              	db	'8250', 0
  1184                                  .uart_16450:
  1185 0000059C 38323530412F313634-     	db	'8250A/16450', 0
  1185 000005A5 353000             
  1186                                  .uart_16550:
  1187 000005A8 313635353000            	db	'16550', 0
  1188                                  .uart_16550A:
  1189 000005AE 31363535304100          	db	'16550A', 0
  1190                                  .uart_16550C:
  1191 000005B5 31363535304300          	db	'16550C', 0
  1192                                  .uart_16650:
  1193 000005BC 313636353000            	db	'16650', 0
  1194                                  .uart_16750:
  1195 000005C2 313637353000            	db	'16750', 0
  1196                                  .uart_16850:
  1197 000005C8 313638353000            	db	'16850', 0
  1198                                  .uart_unknown:
  1199 000005CE 756E6B6E6F776E00        	db	'unknown', 0
  1200                                  .enabled:
  1201 000005D6 656E00                  	db	'en', 0
  1202                                  .disabled:
  1203 000005D9 64697300                	db	'dis', 0
  1204                                  
  1205                                  ;========================================================================
  1206                                  ; uart_init - initialize UART
  1207                                  ; Input:
  1208                                  ;	AL = baud rate
  1209                                  ; Output:
  1210                                  ;	none
  1211                                  ;========================================================================
  1212                                  uart_init:
  1213 000005DD 525350                  	pushm	ax,bx,dx
  1214 000005E0 B400                    	mov	ah,0
  1215 000005E2 D0E0                    	shl	al,1
  1216 000005E4 89C3                    	mov	bx,ax		; Index in the .divisors table
  1217 000005E6 2E8B9F[1806]               cs	mov	bx,word[.divisors+bx]
  1218                                  	; Divisor Latch Access bit set, no parity, one stop bit, 8 data bits
  1219 000005EB B083                    	mov	al,83h
  1220 000005ED BA8306                  	mov	dx,uart_lcr
  1221 000005F0 EE                      	out	dx,al
  1222                                  	; Lookup table for baud rates
  1223 000005F1 88D8                    	mov	al,bl		; low byte
  1224 000005F3 BA8006                  	mov	dx,uart_dll
  1225 000005F6 EE                      	out	dx,al
  1226 000005F7 88F8                    	mov	al,bh		; high byte
  1227 000005F9 BA8106                  	mov	dx,uart_dlm
  1228 000005FC EE                      	out	dx,al
  1229                                  	; no parity, one stop bit, 8 data bits
  1230 000005FD B003                    	mov	al,03h
  1231 000005FF BA8306                  	mov	dx,uart_lcr
  1232 00000602 EE                      	out	dx,al
  1233                                  	; XXX?
  1234 00000603 BA8406                  	mov	dx,uart_mcr
  1235 00000606 EC                      	in	al,dx				; for SBC3
  1236 00000607 0C07                    	or	al,7
  1237 00000609 EE                      	out	dx,al
  1238                                  	; disable interrupts for now
  1239 0000060A B000                    	mov	al,0		; AL = 0
  1240 0000060C BA8106                  	mov	dx,uart_ier
  1241 0000060F EE                      	out	dx,al
  1242                                  	; disable FIFO for now
  1243                                  	; note - AL = 0
  1244 00000610 BA8206                  	mov	dx,uart_fcr
  1245 00000613 EE                      	out	dx,al
  1246 00000614 585B5A                  	popm	ax,bx,dx
  1247 00000617 C3                      	ret
  1248                                  
  1249                                  .divisors:
  1250 00000618 6000                    	dw	UART_OSC/16/1200	; 1200 Kbit/sec
  1251 0000061A 3000                    	dw	UART_OSC/16/2400	; 2400 Kbit/sec
  1252 0000061C 1800                    	dw	UART_OSC/16/4800	; 4800 Kbit/sec
  1253 0000061E 0C00                    	dw	UART_OSC/16/9600	; 9600 Kbit/sec
  1254 00000620 0600                    	dw	UART_OSC/16/19200	; 19200 Kbit/sec
  1255 00000622 0300                    	dw	UART_OSC/16/38400	; 38400 Kbit/sec
  1256 00000624 0200                    	dw	UART_OSC/16/57600	; 57600 Kbit/sec
  1257 00000626 0100                    	dw	UART_OSC/16/115200	; 115200 Kbit/sec
  1258                                  
  1259                                  %if 0
  1260                                  ;========================================================================
  1261                                  ; uart_detect - detect UART type, enable FIFO if present
  1262                                  ; Input:
  1263                                  ;	none
  1264                                  ; Output:
  1265                                  ;	AL = UART type
  1266                                  ;
  1267                                  ; UART detection code from
  1268                                  ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1269                                  ;========================================================================
  1270                                  UART_8250	equ	1
  1271                                  UART_16450	equ	2
  1272                                  UART_16550	equ	3
  1273                                  UART_16550A	equ	4
  1274                                  UART_16550C	equ	5
  1275                                  UART_16650	equ	6
  1276                                  UART_16750	equ	7
  1277                                  UART_16850	equ	8
  1278                                  
  1279                                  uart_detect:
  1280                                  	push	dx
  1281                                  	; Set the value "0xE7" to the FCR to test the status of the FIFO flags
  1282                                  	mov	al,0E7h
  1283                                  	mov	dx,uart_fcr
  1284                                  	out	dx,al
  1285                                  	; Read the value of the IIR to test for what flags actually got set
  1286                                  	mov	dx,uart_iir
  1287                                  	in	al,dx
  1288                                  	test	al,40h
  1289                                  	jz	.no_fifo
  1290                                  	test	al,80h
  1291                                  	jz	.uart_16550
  1292                                  	test	al,20h
  1293                                  	jz	.uart_16550A
  1294                                  	mov	al,UART_16750
  1295                                  	jmp	.exit
  1296                                  .uart_16550A:
  1297                                  	mov	al,UART_16550A
  1298                                  	jmp	.exit
  1299                                  .uart_16550:
  1300                                  	; Disable FIFO on 16550 (FIFO is broken)
  1301                                  	mov	al,0
  1302                                  	mov	dx,uart_fcr
  1303                                  	out	dx,al
  1304                                  	mov	al,UART_16550
  1305                                  	jmp	.exit
  1306                                  .no_fifo:
  1307                                  	; Chip doesn't use FIFO, so we need to check the scratch register
  1308                                  	; Set some arbitrary value like 0x2A to the Scratch Register
  1309                                  	mov	al,2Ah
  1310                                  	mov	dx,uart_sr
  1311                                  	out	dx,al
  1312                                  	; Read the value of the Scratch Register
  1313                                  	in	al,dx
  1314                                  	cmp	al,2Ah
  1315                                  	jnz	.uart_8250
  1316                                  	; If the arbitrary value comes back identical
  1317                                  	mov	al,UART_16450
  1318                                  	jmp	.exit
  1319                                  .uart_8250:
  1320                                  	mov	al,UART_8250
  1321                                  .exit:
  1322                                  	pop	dx
  1323                                  	ret
  1324                                  %else
  1325                                  %include "uart_det.asm"
  1326                              <1> ;========================================================================
  1327                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1328                              <1> ;========================================================================
  1329                              <1> ;
  1330                              <1> ; Copyright (C) 2012,2020 John R Coffman.  All rights reserved.
  1331                              <1> ; Provided for hobbyist use on the RetroBrew Computers' SBC-188 boards.
  1332                              <1> ;
  1333                              <1> ; This program is free software: you can redistribute it and/or modify
  1334                              <1> ; it under the terms of the GNU General Public License as published by
  1335                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1336                              <1> ; (at your option) any later version.
  1337                              <1> ;
  1338                              <1> ; This program is distributed in the hope that it will be useful,
  1339                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1340                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1341                              <1> ; GNU General Public License for more details.
  1342                              <1> ;
  1343                              <1> ; You should have received a copy of the GNU General Public License
  1344                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1345                              <1> ;
  1346                              <1> ; Updated for the Duodyne 80c188 SBC
  1347                              <1> ;========================================================================
  1348                              <1> ; History:
  1349                              <1> ;   Derived from the RetroBrew/JRCoffman UNA source code 'uart_det.s'
  1350                              <1> ;   Copyright (C) 2012 John Coffman.  All rights reserved.
  1351                              <1> ;   Distributed under the above GPL license.
  1352                              <1> ;========================================================================
  1353                              <1> %ifdef STANDALONE
  1354                              <1> %include "config.asm"
  1355                              <1> %include "cpuregs.asm"
  1356                              <1> ;
  1357                              <1> ; C-language interface:
  1358                              <1> ;	unsigned char near uart_det(unsigned dev);
  1359                              <1> 	global	uart_det_
  1360                              <1>    SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
  1361                              <1> uart_det_:
  1362                              <1> 	mov	dx,ax
  1363                              <1> 	call	uart_detect
  1364                              <1> 	ret
  1365                              <1> %endif
  1366                              <1> ;========================================================================
  1367                              <1> ; uart_detect - detect UART type, enable FIFO if present
  1368                              <1> ;
  1369                              <1> ; Input:
  1370                              <1> ;	DX = UART device code to probe
  1371                              <1> ;
  1372                              <1> ; Output:
  1373                              <1> ;	AL = UART type
  1374                              <1> ;
  1375                              <1> ; UART detection code from
  1376                              <1> ; http://en.wikibooks.org/wiki/Serial_Programming/8250_UART_Programming
  1377                              <1> ;========================================================================
  1378                              <1> UART_NONE	equ	0	; no UART detected
  1379                              <1> UART_8250	equ	1	; no Scratch register
  1380                              <1> UART_16450	equ	2	; or 8250A
  1381                              <1> UART_16550	equ	3
  1382                              <1> UART_16550A	equ	4
  1383                              <1> UART_16550C	equ	5
  1384                              <1> UART_16650	equ	6
  1385                              <1> UART_16750	equ	7
  1386                              <1> UART_16850	equ	8
  1387                              <1> ;*******************************************************************
  1388                              <1> ;***N.B.:  the above list must be kept in sync with 'sio.h' enum ***
  1389                              <1> ;*******************************************************************
  1390                              <1> 
  1391                              <1> ; macros assume DI is set to base UART register
  1392                              <1> %macro	uget 2		; dest reg8, src UART reg or offset
  1393                              <1> 	mov	bl,(%2)&0xFF
  1394                              <1> 	call	udet_get
  1395                              <1> 	mov	%1,al
  1396                              <1> %endmacro
  1397                              <1> 
  1398                              <1> %macro	uput 2		; dest UART reg or offset, src reg8
  1399                              <1> 	mov	bl,(%1)&0xFF
  1400                              <1> 	mov	al,%2
  1401                              <1> 	call	udet_put
  1402                              <1> %endmacro
  1403                              <1> 
  1404                              <1> %macro	 ucmp 2		; dest UART reg (read to AL), src reg8 or value
  1405                              <1> 	mov	bl,(%1)&0xFF
  1406                              <1> 	call	udet_get
  1407                              <1> 	cmp	al,(%2)&0xFF
  1408                              <1> %endmacro
  1409                              <1> 
  1410                              <1> uart_detect:
  1411 00000628 57535152            <1> 	pushm	dx,cx,bx,di
  1412 0000062C 31C9                <1> 	xor	cx,cx		; no uart present CL=0
  1413 0000062E 83E2F8              <1> 	and	dx,~7		; mask 8 UART registers
  1414 00000631 89D7                <1> 	mov	di,dx		; device base to di
  1415                              <1> ; UART is present if toggling the DLAT bit in LCR makes divisor available
  1416                              <1> 	uget	ch,uart_lcr	; save LCR value
  1393 00000633 B383                <2>  mov bl,(%2)&0xFF
  1394 00000635 E8EC00              <2>  call udet_get
  1395 00000638 88C5                <2>  mov %1,al
  1417                              <1> 	uput	uart_lcr,0	; make DLAT inaccessible
  1399 0000063A B383                <2>  mov bl,(%1)&0xFF
  1400 0000063C B000                <2>  mov al,%2
  1401 0000063E E8DA00              <2>  call udet_put
  1418                              <1> 	uput	uart_ier,0	; IER==DLM
  1399 00000641 B381                <2>  mov bl,(%1)&0xFF
  1400 00000643 B000                <2>  mov al,%2
  1401 00000645 E8D300              <2>  call udet_put
  1419                              <1> 	uput	uart_lcr,0x80	; LCR  set DLAT bit
  1399 00000648 B383                <2>  mov bl,(%1)&0xFF
  1400 0000064A B080                <2>  mov al,%2
  1401 0000064C E8CC00              <2>  call udet_put
  1420                              <1> 	uget	bh,uart_dlm	; save DLM
  1393 0000064F B381                <2>  mov bl,(%2)&0xFF
  1394 00000651 E8D000              <2>  call udet_get
  1395 00000654 88C7                <2>  mov %1,al
  1421                              <1> 	uput	uart_dlm,0x5a	; DLM==IER  set some pattern
  1399 00000656 B381                <2>  mov bl,(%1)&0xFF
  1400 00000658 B05A                <2>  mov al,%2
  1401 0000065A E8BE00              <2>  call udet_put
  1422                              <1> 	ucmp	uart_dlm,0x5a	; does it read back the same?
  1405 0000065D B381                <2>  mov bl,(%1)&0xFF
  1406 0000065F E8C200              <2>  call udet_get
  1407 00000662 3C5A                <2>  cmp al,(%2)&0xFF
  1423 00000664 7403E9AA00          <1> 	jne	.exit		; no UART here
  1424                              <1> 	uput	uart_lcr,0x00	; LCR=00, reset DLAT
  1399 00000669 B383                <2>  mov bl,(%1)&0xFF
  1400 0000066B B000                <2>  mov al,%2
  1401 0000066D E8AB00              <2>  call udet_put
  1425                              <1> 	ucmp	uart_dlm,0x5a	; is it still 0x5A?
  1405 00000670 B381                <2>  mov bl,(%1)&0xFF
  1406 00000672 E8AF00              <2>  call udet_get
  1407 00000675 3C5A                <2>  cmp al,(%2)&0xFF
  1426 00000677 7503E99700          <1> 	je	.exit		; no uart if still 0x5A
  1427                              <1> 
  1428                              <1> ; restore DLM
  1429                              <1> 	uput	uart_lcr,0x80
  1399 0000067C B383                <2>  mov bl,(%1)&0xFF
  1400 0000067E B080                <2>  mov al,%2
  1401 00000680 E89800              <2>  call udet_put
  1430                              <1> 	uput	uart_dlm,bh
  1399 00000683 B381                <2>  mov bl,(%1)&0xFF
  1400 00000685 88F8                <2>  mov al,%2
  1401 00000687 E89100              <2>  call udet_put
  1431 0000068A 80E57F              <1> 	and	ch,~0x80	; clear DLAT
  1432                              <1> 	uput	uart_lcr,ch	; restore DLAT
  1399 0000068D B383                <2>  mov bl,(%1)&0xFF
  1400 0000068F 88E8                <2>  mov al,%2
  1401 00000691 E88700              <2>  call udet_put
  1433 00000694 41                  <1> 	inc	cx		; UART=8250 or above is present
  1434                              <1> ; look for the Scratch register
  1435                              <1> 	uput	uart_sr,0x5a	; set a value
  1399 00000695 B387                <2>  mov bl,(%1)&0xFF
  1400 00000697 B05A                <2>  mov al,%2
  1401 00000699 E87F00              <2>  call udet_put
  1436                              <1> 	ucmp	uart_sr,0x5a	; does it read back
  1405 0000069C B387                <2>  mov bl,(%1)&0xFF
  1406 0000069E E88300              <2>  call udet_get
  1407 000006A1 3C5A                <2>  cmp al,(%2)&0xFF
  1437 000006A3 756E                <1> 	jne	.exit		; test for no Scratch register
  1438                              <1> 
  1439 000006A5 41                  <1> 	inc	cx		; 8250A, 16450 or higher
  1440                              <1> 	uput	uart_lcr,0xBF	; special value for higher UARTs
  1399 000006A6 B383                <2>  mov bl,(%1)&0xFF
  1400 000006A8 B0BF                <2>  mov al,%2
  1401 000006AA E86E00              <2>  call udet_put
  1441                              <1> 	ucmp	uart_sr,0x5A	; is it still 0x5a?
  1405 000006AD B387                <2>  mov bl,(%1)&0xFF
  1406 000006AF E87200              <2>  call udet_get
  1407 000006B2 3C5A                <2>  cmp al,(%2)&0xFF
  1442 000006B4 7404                <1> 	je	.below650
  1443 000006B6 B106                <1> 	mov	cl,6		; it is a 16650 or 16850, which cannot
  1444 000006B8 EB59                <1> 	jmp	.exit		;  be distinguished
  1445                              <1> .below650:
  1446                              <1> ; UART is 16550C or below
  1447                              <1> 	uput	uart_lcr,0x80	; set DLAT again
  1399 000006BA B383                <2>  mov bl,(%1)&0xFF
  1400 000006BC B080                <2>  mov al,%2
  1401 000006BE E85A00              <2>  call udet_put
  1448                              <1> 	uput	uart_fcr,0xE1	; output to FCR (FIFO Control)
  1399 000006C1 B382                <2>  mov bl,(%1)&0xFF
  1400 000006C3 B0E1                <2>  mov al,%2
  1401 000006C5 E85300              <2>  call udet_put
  1449                              <1> 	uget	bh,uart_iir	; FCR=IIR
  1393 000006C8 B382                <2>  mov bl,(%2)&0xFF
  1394 000006CA E85700              <2>  call udet_get
  1395 000006CD 88C7                <2>  mov %1,al
  1450                              <1> 	uput	uart_lcr,0x07	; reset the LCR DLAT bit & set 8n2
  1399 000006CF B383                <2>  mov bl,(%1)&0xFF
  1400 000006D1 B007                <2>  mov al,%2
  1401 000006D3 E84500              <2>  call udet_put
  1451                              <1> ; test for a FIFO
  1452 000006D6 F6C740              <1> 	test	bh,1<<6		; test low order FIFO bit
  1453 000006D9 7438                <1> 	jz	.exit		; 16450 if zero
  1454                              <1> 
  1455 000006DB 41                  <1> 	inc	cx		; 16550 or higher
  1456 000006DC F6C780              <1> 	test	bh,1<<7		; test high FIFO bit
  1457 000006DF 7432                <1> 	jz	.exit		; 16550 if zero
  1458                              <1> 
  1459 000006E1 41                  <1> 	inc	cx		; 16550A or higher
  1460 000006E2 F6C720              <1> 	test	bh,1<<5		; test for 64-byte FIFO
  1461 000006E5 7404                <1> 	jz	.is550AorC
  1462                              <1> ; has a 64-byte FIFO
  1463 000006E7 B107                <1> 	mov	cl,7		; it is a 16750
  1464 000006E9 EB28                <1> 	jmp	.exit
  1465                              <1> 
  1466                              <1> ; two levels of UART left to distinguish
  1467                              <1> .is550AorC:
  1468                              <1> ;;;;				; 16550A or higher
  1469                              <1> 	uget	bh,uart_mcr	; save MCR setting
  1393 000006EB B384                <2>  mov bl,(%2)&0xFF
  1394 000006ED E83400              <2>  call udet_get
  1395 000006F0 88C7                <2>  mov %1,al
  1470 000006F2 80CF20              <1> 	or	bh,1<<5		; set bit 5
  1471                              <1> 	uput	uart_mcr,bh	; set the AFE bit (auto flowcontrol enable)
  1399 000006F5 B384                <2>  mov bl,(%1)&0xFF
  1400 000006F7 88F8                <2>  mov al,%2
  1401 000006F9 E81F00              <2>  call udet_put
  1472                              <1> 	uget	bh,uart_mcr	; read it back
  1393 000006FC B384                <2>  mov bl,(%2)&0xFF
  1394 000006FE E82300              <2>  call udet_get
  1395 00000701 88C7                <2>  mov %1,al
  1473 00000703 F6C720              <1> 	test	bh,1<<5		; is the bit still set
  1474 00000706 740B                <1> 	jz	.exit
  1475 00000708 41                  <1> 	inc	cx		; 16550C found
  1476 00000709 80E7DF              <1> 	and	bh,0xFF-(1<<5)	; clear the AFE bit
  1477                              <1> 	uput	uart_mcr,bh	; AFC is broken on DIP version of 16550
  1399 0000070C B384                <2>  mov bl,(%1)&0xFF
  1400 0000070E 88F8                <2>  mov al,%2
  1401 00000710 E80800              <2>  call udet_put
  1478                              <1> .exit:
  1479 00000713 88C8                <1> 	mov	al,cl		; return UART ID
  1480 00000715 98                  <1> 	cbw
  1481 00000716 5A595B5F            <1> 	popm	dx,cx,bx,di
  1482 0000071A C3                  <1> 	ret
  1483                              <1> 
  1484                              <1> udet_put:
  1485 0000071B 53                  <1> 	push	bx
  1486 0000071C 83E307              <1> 	and	bx,7		; mask to uart offset
  1487 0000071F 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1488 00000721 EE                  <1> 	out	dx,al
  1489 00000722 5B                  <1> 	pop	bx
  1490 00000723 C3                  <1> 	ret
  1491                              <1> udet_get:
  1492 00000724 53                  <1> 	push	bx
  1493 00000725 83E307              <1> 	and	bx,7		; mask to uart offset
  1494 00000728 8D11                <1> 	lea	dx,[di+bx]	; device code to DX
  1495 0000072A EC                  <1> 	in	al,dx
  1496 0000072B 5B                  <1> 	pop	bx
  1497 0000072C C3                  <1> 	ret
  1498                              <1> 
  1499                              <1> 
  1500                              <1> ;;; end of UART_DET.ASM
  1326                                  %endif
  1327                                  
  1328                                  ;========================================================================
  1329                                  ; uart_putchar - write the character in teletype mode
  1330                                  ; Input:
  1331                                  ;	AL = character
  1332                                  ;========================================================================
  1333                                          global  @VIDEO_putchar
  1334                                  	global  @uart_putchar
  1335                                  @VIDEO_putchar:
  1336                                  @uart_putchar:
  1337 0000072D 50                              push    ax
  1338 0000072E 53                              push    bx
  1339 0000072F B40E                            mov     ah,0Eh
  1340 00000731 BB0700                          mov     bx,0007h        ; page 0, normal attributes
  1341 00000734 CD10                            int     10h
  1342 00000736 5B                              pop     bx
  1343 00000737 58                              pop     ax
  1344 00000738 C3                              ret
  1345                                  
  1346                                  ;========================================================================
