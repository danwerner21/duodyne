     1                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  	; floppy.asm - - WD37C65B floppy disk controller driver
     3                                  	; Version 2.0 - - Apr 2013, JRC
     4                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  	;
     6                                  	; This version is for assembly by NASM 0.98.39 or later
     7                                  	;
     8                                  	; Copyright (C) 2010 - 2013 John R. Coffman. All rights reserved.
     9                                  	; Provided for hobbyist use on the N8VEM SBC - 188 board.
    10                                  	;
    11                                  	; This program is free software: you can redistribute it and / or modify
    12                                  	; it under the terms of the GNU General Public License as published by
    13                                  	; the Free Software Foundation, either version 3 of the License, or
    14                                  	; (at your option) any later version.
    15                                  	;
    16                                  	; This program is distributed in the hope that it will be useful,
    17                                  	; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    19                                  	; GNU General Public License for more details.
    20                                  	;
    21                                  	; You should have received a copy of the GNU General Public License
    22                                  	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
    23                                  	;
    24                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  	%include "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    51                              <1> ;UART_RATE	equ	0		; 1200
    52                              <1> ;UART_RATE	equ	1		; 2400
    53                              <1> ;UART_RATE	equ	2		; 4800
    54                              <1> UART_RATE	equ	3		; 9600
    55                              <1> ;UART_RATE	equ	4		; 19200
    56                              <1> ;UART_RATE	equ	5		; 38400
    57                              <1> ;UART_RATE	equ	6		; 57600
    58                              <1> ;UART_RATE	equ	7		; 115200
    59                              <1> 
    60                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    61                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    62                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    63                              <1> 						; but not ANSI
    64                              <1> ; Define the size of the ROM image on the system in Kilobytes
    65                              <1> ; It may be smaller than the actual EPROM in use.
    66                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    67                              <1> %ifndef ROM
    68                              <1> ROM             equ     32              ; 64 is the default
    69                              <1> %endif
    70                              <1> 
    71                              <1> ; Define the number of Wait States at which the ROM operates
    72                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    73                              <1> 
    74                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    75                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    76                              <1> RAM_DOS         equ     640
    77                              <1> 
    78                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    79                              <1> ; the default is 512 kilobytes
    80                              <1> RAM             equ     512             ; (512 is the default)
    81                              <1> 
    82                              <1> ; Define the number of Wait States at which the RAM operates
    83                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    84                              <1> 
    85                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    86                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    87                              <1> 
    88                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    89                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    90                              <1> 
    91                              <1> ; Define the time zone in which we build the Relocatable BIOS
    92                              <1> %ifndef TIMEZONE
    93                              <1> %define TIMEZONE "CST"
    94                              <1> %endif
    95                              <1> 
    96                              <1> ; Has the REDBUG debugger been loaded?
    97                              <1> %ifndef SOFT_DEBUG
    98                              <1> %define SOFT_DEBUG 0
    99                              <1> %endif
   100                              <1> 
   101                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   102                              <1> %ifndef TBASIC
   103                              <1> TBASIC          equ     1		; default is 1
   104                              <1> %endif
   105                              <1> 
   106                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   107                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   108                              <1> %ifndef FPEM
   109                              <1> FPEM            equ     1               ; default is 1
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   113                              <1> EMM_BOARDS      equ     0
   114                              <1> 
   115                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   116                              <1> ; or at locations 0280h..3FFh in low memory?
   117                              <1> %if SOFT_DEBUG
   118                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   119                              <1> %else
   120                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   121                              <1> %endif
   122                              <1> 
   123                              <1> ; Define the size of the EPROM that is to be installed on the system
   124                              <1> ; It may be larger than the actual ROM image to be generated.
   125                              <1> %ifndef CHIP
   126                              <1> CHIP            equ     64
   127                              <1> %endif
   128                              <1> 
   129                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   130                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   131                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   132                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   133                              <1> 
   134                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   135                              <1> ; If the wiring update is installed, or you have a later board, then
   136                              <1> ; set this to 0.  If you are using the software workaround, then set this
   137                              <1> ; to 1.  The rev 1.0 board has this fix already.
   138                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   139                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   140                              <1> 
   141                              <1> ; Define the UART oscillator speed
   142                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   143                              <1> 
   144                              <1> 
   145                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   146                              <1> ; end of the User configuration
   147                              <1> ;       Do Not modify anything below this point
   148                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   149                              <1> 
   150                              <1> ; Define existence of any uart chip
   151                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   152                              <1> startuplength   equ     512                     ; may be up to 1024
   153                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   154                              <1> highrom         equ     (ROM*400h)&0FFFFh
   155                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   156                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   157                              <1> 
   158                              <1> 
   159                              <1> %define ARG(n) [bp+2+(n)*2]
   160                              <1> 
   161                              <1> %macro  check   1.nolist
   162                              <1>  %if (%1)
   163                              <1>    %error Check Failure: %1
   164                              <1>  %endif
   165                              <1> %endm
   166                              <1> %macro  range   3.nolist
   167                              <1>  %if (%1)<(%2)
   168                              <1>    %error Out of Range: %1
   169                              <1>  %elif (%1)>(%3)
   170                              <1>    %error Out of Range: %1
   171                              <1>  %endif
   172                              <1> %endm
   173                              <1> _terminal equ UART
   174                              <1>  check   RAM_DOS&15
   175                              <1>  check   RAM&(RAM-1)
   176                              <1>  check   ROM&(ROM-1)
   177                              <1>  range   RAM,32,512
   178                              <1>  range   ROM,32,256
   179                              <1>  range   RAM_WS,0,3
   180                              <1>  range   ROM_WS,0,3
   181                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   182                              <1>  range   LCL_IO_WS,0,3
   183                              <1>  range   BUS_IO_WS,0,3
   184                              <1>  range   UART_OSC,500000,16000000
   185                              <1>  range   UART_RATE,0,7
   186                              <1>  range	 UART,0,1
   187                              <1>  range	 _terminal,1,2
   188                              <1> 
   189                              <1> %ifndef SOFT_DEBUG
   190                              <1> %define SOFT_DEBUG 0
   191                              <1> %endif
   192                              <1> 
   193                              <1> %ifndef TRACE
   194                              <1> %define TRACE 0
   195                              <1> %endif
   196                              <1> 
   197                              <1> %ifdef MAKE_OBJECT_FILE
   198                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   199                              <1>         export _ROMsize
   200                              <1>         export _CHIPsize
   201                              <1> _ROMsize        dw      ROM
   202                              <1> _CHIPsize       dw      CHIP
   203                              <1> %endif
   204                              <1> ; end of the Hardware configuration file
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> ;*/
    26                                  	%include "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ; Updated for the Duodyne 80c188 SBC
    50                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    51                              <1> %include	"macros.inc"
    52                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <2> ; MACROS.INC  
    54                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <2> ;
    56                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    57                              <2> ;
    58                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    59                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    60                              <2> ;
    61                              <2> ; This program is free software: you can redistribute it and/or modify
    62                              <2> ; it under the terms of the GNU General Public License as published by
    63                              <2> ; the Free Software Foundation, either version 3 of the License, or
    64                              <2> ; (at your option) any later version.
    65                              <2> ;
    66                              <2> ; This program is distributed in the hope that it will be useful,
    67                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    68                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    69                              <2> ; GNU General Public License for more details.
    70                              <2> ;
    71                              <2> ; You should have received a copy of the GNU General Public License
    72                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    73                              <2> ;
    74                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                              <2> 
    76                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    77                              <2> ;
    78                              <2> ;
    79                              <2> %ifndef __MACROS_DEFINED_
    80                              <2> %define __MACROS_DEFINED_ 1
    81                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                              <2> ;
    83                              <2> ; some useful macros:
    84                              <2> ;
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> 	cpu	186
    88                              <2> 
    89                              <2> %imacro setloc  1.nolist
    90                              <2>  times   (%1-($-$$)) db 0FFh
    91                              <2> %endm
    92                              <2> 
    93                              <2> %imacro db_lo   1
    94                              <2>  db (%1)&255
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro cnop    0.nolist
    98                              <2> %if SOFT_DEBUG
    99                              <2>         nop
   100                              <2> %endif
   101                              <2> %endm
   102                              <2> 
   103                              <2> %imacro popm 1-*.nolist
   104                              <2> %rep %0
   105                              <2> %ifidni %1,ALL
   106                              <2>  popa
   107                              <2> %elifidni %1,F
   108                              <2>  popf
   109                              <2> %else
   110                              <2>  pop %1
   111                              <2> %ifidni %1,DS
   112                              <2>  cnop
   113                              <2> %elifidni %1,ES
   114                              <2>  cnop
   115                              <2> %endif
   116                              <2> %endif
   117                              <2> %rotate 1
   118                              <2> %endrep
   119                              <2> %endm
   120                              <2> 
   121                              <2> %imacro pushm 1-*.nolist
   122                              <2> %rep %0
   123                              <2> %rotate -1
   124                              <2> %ifidni %1,ALL
   125                              <2>  pusha
   126                              <2> %elifidni %1,F
   127                              <2>  pushf
   128                              <2> %else
   129                              <2>  push %1
   130                              <2> %endif
   131                              <2> %endrep
   132                              <2> %endm
   133                              <2> 
   134                              <2> ;
   135                              <2> ; added from the 386EX project
   136                              <2> ;
   137                              <2> 
   138                              <2> ; call arguments
   139                              <2> %define ARG(n) [bp+2+(n)*2]
   140                              <2> 
   141                              <2> ;
   142                              <2> ; format of the BYTE initialization table:  address, byte
   143                              <2> ;
   144                              <2> %imacro  binit 2
   145                              <2>         dw      %1
   146                              <2>         db      %2
   147                              <2> %endmacro
   148                              <2> ; end with DW -1
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the WORD initialization table:  address, word
   152                              <2> ;
   153                              <2> %imacro  winit 2
   154                              <2>         dw      %1
   155                              <2>         dw      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> 
   160                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   161                              <2> %imacro get_bda	1.nolist
   162                              <2> 	push	0x0040
   163                              <2> 	pop	%1
   164                              <2> 	cnop
   165                              <2> %endm
   166                              <2> 
   167                              <2> 
   168                              <2> %endif
    52                              <1> 
    53                              <1> 	cpu     186
    54                              <1> ;
    55                              <1> ;
    56                              <1> ; IBM model byte -- must be less than a 286
    57                              <1> ;
    58                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    59                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    60                              <1> 
    61                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    62                              <1> SUBMODEL_BYTE		equ	00h	;  "
    63                              <1> 
    64                              <1> 
    65                              <1> ; 80188 peripheral control register block address
    66                              <1> CPU_CSCR	        equ	0FF00h
    67                              <1> 
    68                              <1> ; Compatible Mode registers
    69                              <1> 
    70                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    71                              <1> 
    72                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    73                              <1> 
    74                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    75                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    76                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    77                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    78                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    79                              <1> 
    80                              <1> ; Enhanced Mode registers
    81                              <1> 
    82                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    83                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    84                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    85                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    86                              <1> 
    87                              <1> 
    88                              <1> ; On-board internal peripheral equates
    89                              <1> ; Programmable Interrupt Controller
    90                              <1> PIC	        equ	CPU_CSCR+020H
    91                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    92                              <1> PIC_POLLR	equ	PIC+4
    93                              <1> PIC_POLLSR	equ	PIC+6
    94                              <1> PIC_IMASK	equ	PIC+8
    95                              <1> PIC_PMREG	equ	PIC+0AH
    96                              <1> PIC_SRVR	equ	PIC+0CH
    97                              <1> PIC_IRQR	equ	PIC+0EH
    98                              <1> PIC_IRQSR	equ	PIC+10H
    99                              <1> PIC_TCR	        equ	PIC+12H
   100                              <1> PIC_DMA0CR	equ	PIC+14H
   101                              <1> PIC_DMA1CR	equ	PIC+16H
   102                              <1> PIC_I0CON	equ	PIC+18H
   103                              <1> PIC_I1CON	equ	PIC+1AH
   104                              <1> PIC_I2CON	equ	PIC+1CH
   105                              <1> PIC_I3CON	equ	PIC+1EH
   106                              <1> 
   107                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   108                              <1> 
   109                              <1> ; Interrupt masks (Master Mode)
   110                              <1> ;
   111                              <1> mask_timer_all          equ     0001h
   112                              <1> mask_dma0               equ     0004h
   113                              <1> mask_dma1               equ     0008h
   114                              <1> mask_int0               equ     0010h
   115                              <1> mask_int1               equ     0020h
   116                              <1> mask_int2               equ     0040h
   117                              <1> mask_int3               equ     0080h
   118                              <1> 
   119                              <1> 
   120                              <1> 
   121                              <1> ; Timers
   122                              <1> TIM0	        equ	CPU_CSCR+050H
   123                              <1> TIM1	        equ	CPU_CSCR+058H
   124                              <1> TIM2	        equ	CPU_CSCR+060H
   125                              <1> 
   126                              <1> TCNT	        equ	0	; count register
   127                              <1> CMPA	        equ	2	; max count A
   128                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   129                              <1> TCON	        equ	6	; mode/control word
   130                              <1> 
   131                              <1> ; Timer control bits:
   132                              <1> tc_EN           equ     8000h   ; Enable bit
   133                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   134                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   135                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   136                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   137                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   138                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   139                              <1> tc_EXT          equ     0004h   ; External clock
   140                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   141                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   142                              <1> 
   143                              <1> 
   144                              <1> 
   145                              <1> 
   146                              <1> ; DMA
   147                              <1> DMA0	        equ	CPU_CSCR+0C0H
   148                              <1> DMA1	        equ	CPU_CSCR+0D0H
   149                              <1> DMASPL	        equ	0	; source pointer low
   150                              <1> DMASPU	        equ	2	; source pointer high
   151                              <1> DMADPL	        equ	4	; destination pointer low
   152                              <1> DMADPU	        equ	6	; destination pointer high
   153                              <1> DMATC	        equ	8	; terminal count
   154                              <1> DMACW	        equ	0AH	; control word
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   161                              <1> ;
   162                              <1> ;       SBC-188 external devices
   163                              <1> ;
   164                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   165                              <1> 
   166                              <1> IO_BASE			equ	0400h
   167                              <1> 
   168                              <1> 
   169                              <1> 
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> 
   174                              <1> uart_base               equ     IO_BASE+0280h
   175                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   176                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   177                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   178                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   179                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   180                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   181                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   182                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   183                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   184                              <1> uart_sr			equ	uart_base+7	;Scratch
   185                              <1> 
   186                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   187                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   188                              <1> 
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> CTRL259		equ	IO_BASE+0238H
   193                              <1> ; LEDS are at addresses 0..3
   194                              <1> ; other control ports on 4..7
   195                              <1> LED0		equ	CTRL259+0
   196                              <1> LED1		equ	LED0+1
   197                              <1> LED2		equ	LED0+2
   198                              <1> LED3		equ	LED0+3
   199                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   200                              <1> ;unused		equ	CTRL259+5
   201                              <1> ;unused		equ	CTRL259+6
   202                              <1> ;unused		equ	CTRL259+7
   203                              <1> 
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   208                              <1> 
   209                              <1> 
   210                              <1> 
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> ; Floppy controller (Duodyne Disk IO)
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> FDC	        equ	IO_BASE+0080H
   215                              <1> FDC_MSR         equ     FDC
   216                              <1> FDC_DATA        equ     FDC+1
   217                              <1> FDC_TC	        equ	FDC+2
   218                              <1> FDC_RES	        equ	FDC+3
   219                              <1> FDC_LDCR	equ	FDC+5
   220                              <1> FDC_LDOR	equ	FDC+6
   221                              <1> FDC_DACK        equ	FDC+6
   222                              <1> FDC_DACK_TC     equ     FDC+7
   223                              <1> 
   224                              <1> 
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   227                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   228                              <1> RTC	equ	IO_BASE+0094H
   229                              <1> 
   230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> PPI	        equ	IO_BASE+0088H
   234                              <1> 
   235                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   236                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   237                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   238                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   239                              <1> 
   240                              <1> portA           equ     PPI+0   ;
   241                              <1> portB           equ     PPI+1   ;
   242                              <1> portC           equ     PPI+2   ;
   243                              <1> 
   244                              <1> ; end CPUREGS.ASM
    27                                  	%include "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define DIDE_driver 0		/*
   261                              <2> %else
   262                              <2> %define DIDE_driver 0
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define DISKIO_driver 1		/*
   266                              <2> %else
   267                              <2> %define DISKIO_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define MFPIC_driver 1		/*
   271                              <2> %else
   272                              <2> %define MFPIC_driver 1
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DSD_driver 1		/*
   276                              <2> %else
   277                              <2> %define DSD_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define V3IDE8_driver (SBC188==3)		/*
   281                              <2> %else
   282                              <2> %define V3IDE8_driver (SBC188==3)
   283                              <2> %endif
   284                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                  	%define DUMP 1
    30                                  	%define DEBUG 1
    31                                  	%define SOFT_DEBUG 1
    32                                  	; sterilize SOFT_DEBUG for now
    33                                  	%if SOFT_DEBUG > 1
    34                                  	%undef SOFT_DEBUG
    35                                  	%define SOFT_DEBUG 1
    36                                  	%endif
    37                                  
    38                                  	global BIOS_call_13h
    39                                  	;; global Floppy_BIOS_call_13h_entry
    40                                  	global wait12
    41                                  	global @enable, @disable
    42                                  	%if SOFT_DEBUG
    43                                  	extern _cprintf
    44                                  	global undefined
    45                                  	global fn00, fn02, fn03, fn04
    46                                  	global get_msr
    47                                  	global check_DL
    48                                  	global get_disk_type
    49                                  	global get_media
    50                                  	global set_media_pointer
    51                                  	global rwv_common
    52                                  	global Seek, recalibrate, Specify
    53                                  	global rwv_common.marker
    54                                  	global end_rwv
    55                                  	global xfer_read_sector, xfer_write_sector, xfer_verify_sector
    56                                  	global xfer_format_track
    57                                  	global Check_RW_Status
    58                                  	%endif
    59                                  
    60                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    61                                  	; Error, Okay, Complete status conditions
    62                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                                  
    64                                  	%define Error stc
    65                                  	; test with:
    66                                  	; JC xxx (jump on error)
    67                                  	; JNC xxx (jump on no error)
    68                                  
    69                                  	%define Okay xor ah, ah
    70                                  	; test with:
    71                                  	; JZ xxx (jump okay)
    72                                  	; JNZ xxx (jump not okay)
    73                                  
    74                                  	%define Complete or ah, 3
    75                                  	; test with:
    76                                  	; JA xxx (jump complete AND no error)
    77                                  	; JNZ xxx (jump complete)
    78                                  	; JZ xxx (jump not complete)
    79                                  
    80                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    81                                  
    82                                  
    83                                  	; at most we use 2 floppies
    84                                  	%define FLOPPY_MAX 2
    85                                  
    86                                  	; there is some disagreement about whether ES:DI gets set
    87                                  	; for Floppy calls to "int 13h, function 8"
    88                                  	FN08_SET_ES_DI equ 1
    89                                  	;FN08_SET_ES_DI equ 0
    90                                  
    91                                  	; Define the three modes of operation of the WD37C65B floppy controller
    92                                  	%define BASE 0FFh
    93                                  	%define SPECIAL 80h
    94                                  	%define PC_AT 00h
    95                                  
    96                                  	; DMA watch threshhold
    97                                  	%define THRESHHOLD 12
    98                                  
    99                                  	; Do we use DMA or Programmed I / O
   100                                  	%define USE_DMA 1            ; We want this to be 1
   101                                  	%define USE_DMA_INTs 1       ; Use DMA interrupts
   102                                  
   103                                  	; Define the mode in which the WD37C65B is operated
   104                                  	%define MODE PC_AT           ; This MUST NOT be changed
   105                                  
   106                                  	; specify bits in the Operations Register
   107                                  	%define DSEL1 00h
   108                                  	%define DSEL2 01h
   109                                  	%define DSEL_MASK (DSEL1|DSEL2)
   110                                  	%define NO_RESET 04h
   111                                  	%define RESET 00h
   112                                  	%define DMAEN 08h
   113                                  	%define MOEN1 10h
   114                                  	%define MOEN2 20h
   115                                  	%define MOEN_MASK (MOEN1|MOEN2)
   116                                  
   117                                  	%define TurnOn 8             ; used by all DSEL's
   118                                  
   119                                  	; the Motor turn - on delay in milliseconds
   120                                  	%define MOTOR_DELAY (TurnOn * 125)
   121                                  
   122                                  	; define the disk density clock rate selects
   123                                  	%define FDC_HD 00h
   124                                  	%define FDC_DD 02h
   125                                  
   126                                  	; The individual floppy disk status bits
   127                                  	%define FDC_DRIVE_PRESENT 1
   128                                  	%define FDC_DRIVE_READY 2
   129                                  
   130                                  
   131                                  	; define the MSR bits:
   132                                  	RQM equ 80h                  ; request for master
   133                                  	DIO equ 40h                  ; data IN=1, out=0
   134                                  	EXM equ 20h                  ; Execution phase in non - DMA mode
   135                                  	; this should NEVER be set
   136                                  	BUSY equ 10h                 ; Controller Busy
   137                                  	FD3 equ 08h                  ; DS3 is seeking
   138                                  	FD2 equ 04h                  ; DS2 is seeking
   139                                  	FD1 equ 02h                  ; DS1 is seeking
   140                                  	FD0 equ 01h                  ; DS0 is seeking
   141                                  
   142                                  	; MSR I / O status (in / out from CPU)
   143                                  	MSR_IN equ RQM | DIO
   144                                  	MSR_OUT equ RQM
   145                                  	MSR_MASK equ RQM | DIO
   146                                  
   147                                  	; This is the list of controller commands that we use
   148                                  
   149                                  	CMD_RECALIBRATE equ 7        ; 1 param byte (unit #)
   150                                  	; No result bytes
   151                                  	CMD_SENSE_INT_STATUS equ 8   ; No paramter bytes
   152                                  	; 2 result bytes
   153                                  	CMD_SENSE_DRIVE_STATUS equ 4 ; 1 param byte
   154                                  	; 1 result byte
   155                                  	CMD_SPECIFY equ 3            ; 2 parameter bytes
   156                                  	; No result bytes
   157                                  	CMD_SEEK equ 15              ; 2 parameter bytes
   158                                  	; No result bytes
   159                                  	CMD_READ_ID equ 10           ; param in cmd; 1 param byte
   160                                  	; 7 result bytes
   161                                  	CMD_READ_DATA equ 6          ; params in cmd; 8 param bytes
   162                                  	; 7 result bytes
   163                                  	CMD_WRITE_DATA equ 5         ; params in cmd; 8 param bytes
   164                                  	; 7 result bytes
   165                                  	CMD_READ_A_TRACK equ 2       ; params in cmd; 8 param bytes
   166                                  	; 7 result bytes
   167                                  	CMD_FORMAT_A_TRACK equ 13    ; params in cmd; 5 param bytes
   168                                  	; 7 result bytes
   169                                  	CMD_SCAN_EQUAL equ 11h       ; params in cmd; 8 param bytes
   170                                  	; 7 result bytes
   171                                  	CMD_SCAN_LOW_OR_EQUAL equ 19h ; params in cmd; 8 param bytes
   172                                  	; 7 result bytes
   173                                  	CMD_SCAN_HIGH_OR_EQUAL equ 1Dh ; params in cmd; 8 param bytes
   174                                  	; 7 result bytes
   175                                  
   176                                  
   177                                  	; define the extra bits in some command codes
   178                                  
   179                                  	CMD_MT equ 80h               ; Multi - track operation
   180                                  	CMD_MF equ 40h               ; MFM recording mode
   181                                  	CMD_SK equ 20h               ; skip deleted data mark
   182                                  
   183                                  
   184                                  
   185                                  	; define the ST3 status bits
   186                                  
   187                                  	ST3_WP equ 40h               ; NOT Write Protected
   188                                  	ST3_TR00 equ 10h             ; Track 0 signal
   189                                  	ST3_WP2 equ 08h              ; duplicate of ST3_WP; ST3_2S for 8" floppies
   190                                  	ST3_HS equ 04h               ; head 0 or 1
   191                                  	ST3_US equ 03h               ; Unit mask (0..3)
   192                                  
   193                                  
   194                                  	; define the ST2 status bits
   195                                  
   196                                  	ST2_CM equ 40h               ; Control Mark (deleted data mark)
   197                                  	ST2_DD equ 20h               ; Data Error (data field)
   198                                  	ST2_WC equ 10h               ; Wrong Cylinder
   199                                  	ST2_SH equ 08h               ; Scan Hit (not used here)
   200                                  	ST2_SN equ 04h               ; Scan Not Satisfied (not used here)
   201                                  	ST2_BC equ 02h               ; Bad Cylinder
   202                                  	ST2_MD equ 01h               ; Missing address mark
   203                                  
   204                                  	ST2_ANY equ ST2_CM + ST2_DD + ST2_WC + ST2_BC + ST2_MD
   205                                  
   206                                  
   207                                  	; define the ST1 status bits
   208                                  
   209                                  	ST1_EN equ 80h               ; End of cylinder
   210                                  	ST1_DE equ 20h               ; Data error (CRC err in address or data field)
   211                                  	ST1_OR equ 10h               ; Overrun (we will always see this flag)
   212                                  	ST1_ND equ 04h               ; No Data
   213                                  	ST1_NW equ 02h               ; Not writeable (WP is set)
   214                                  	ST1_MA equ 01h               ; Missing address mark
   215                                  
   216                                  	%if FDC_PIGGYBACK_FIX
   217                                  	ST1_ANY equ ST1_EN + ST1_DE + ST1_OR + ST1_ND + ST1_NW + ST1_MA
   218                                  	%else
   219                                  	;ST1_ANY equ ST1_EN + ST1_DE + ST1_ND + ST1_NW + ST1_MA
   220                                  	ST1_ANY equ ST1_DE + ST1_ND + ST1_NW + ST1_MA
   221                                  	%endif
   222                                  
   223                                  	; define the ST0 status bits
   224                                  
   225                                  	ST0_IC equ 0C0h              ; Interrupt code mask
   226                                  	; 00 = normal termination
   227                                  	; 01 = abnormal termination
   228                                  	; 10 = invalid command
   229                                  	; 11 = abnormal termination - - change in ready status
   230                                  
   231                                  	ST0_SE equ 20h               ; Seek end
   232                                  	ST0_EC equ 10h               ; Equipment check
   233                                  	ST0_NR equ 08h               ; Not Ready (always 0 on WD37C65B)
   234                                  	ST0_HS equ 04h               ; Head Select
   235                                  	;ST0_US equ 03h ; Unit select mask
   236                                  	ST0_US equ 01h               ; Unit select mask
   237                                  
   238                                  	ST0_ANY equ ST0_EC + ST0_NR  ; Any ST0 error
   239                                  
   240                                  
   241                                  
   242                                  	; The FDC interrupt control register
   243                                  	fdc_int_control equ PIC_I3CON
   244                                  
   245                                  
   246                                  	; Standard int 13h stack frame layout is
   247                                  	; created by: PUSHM ALL, DS, ES
   248                                  	; MOV BP, SP
   249                                  	;
   250                                  	offset_DI equ 0
   251                                  	offset_SI equ offset_DI + 2
   252                                  	offset_BP equ offset_SI + 2
   253                                  	offset_SP equ offset_BP + 2
   254                                  	offset_BX equ offset_SP + 2
   255                                  	offset_DX equ offset_BX + 2
   256                                  	offset_CX equ offset_DX + 2
   257                                  	offset_AX equ offset_CX + 2
   258                                  	offset_DS equ offset_AX + 2
   259                                  	offset_ES equ offset_DS + 2
   260                                  	offset_IP equ offset_ES + 2
   261                                  	offset_CS equ offset_IP + 2
   262                                  	offset_FLAGS equ offset_CS + 2
   263                                  
   264                                  	; The byte registers in the stack
   265                                  	offset_AL equ offset_AX
   266                                  	offset_AH equ offset_AX + 1
   267                                  	offset_BL equ offset_BX
   268                                  	offset_BH equ offset_BX + 1
   269                                  	offset_CL equ offset_CX
   270                                  	offset_CH equ offset_CX + 1
   271                                  	offset_DL equ offset_DX
   272                                  	offset_DH equ offset_DX + 1
   273                                  
   274                                  
   275                                  	; FDC error codes (returned in AH)
   276                                  	;
   277                                  	ERR_no_error equ 0           ; no error (return Carry clear)
   278                                  	; everything below returns with the Carry set to indicate an error
   279                                  	ERR_invalid_command equ 1
   280                                  	ERR_address_mark_not_found equ 2
   281                                  	ERR_write_protect equ 3
   282                                  	ERR_sector_not_found equ 4
   283                                  	ERR_disk_removed equ 6
   284                                  	ERR_dma_overrun equ 8
   285                                  	ERR_dma_crossed_64k equ 9
   286                                  
   287                                  
   288                                  	ERR_media_type_not_found equ 12 ; 0Ch
   289                                  	ERR_uncorrectable_CRC_error equ 10h
   290                                  	ERR_controller_failure equ 20h
   291                                  	ERR_seek_failed equ 40h
   292                                  	ERR_disk_timeout equ 80h
   293                                  
   294                                  	ERR_81 equ 81h               ; fdc_ready_for_cmd, not rdy for input
   295                                  	ERR_82 equ 82h               ; fdc_ready_for_result, not rdy for output
   296                                  	ERR_83 equ 83h               ; input_result_from_fdc, after input, still busy
   297                                  	ERR_84 equ 84h               ; fdc_wait_seek_done, abnormal ST0_IC code
   298                                  	ERR_85 equ 85h               ; xfer_read_sector timeout
   299                                  	ERR_86 equ 86h               ; cylinder requested is invalid for drive
   300                                  	ERR_87 equ 87h               ; not on track 0 after recalibrate
   301                                  	ERR_88 equ 88h               ; wait for operation complete to be posted
   302                                  	ERR_89 equ 89h               ; fdc_ready_for_cmd, unexpectedly BUSY
   303                                  	ERR_8A equ 8Ah               ; second "seek failed" error (ignore during Format)
   304                                  
   305                                  	ERR_unknown equ 8Fh          ; ADDED - - JRC (may need to change)
   306                                  
   307                                  
   308                                  	SEGMENT _TEXT
   309                                  	%if SOFT_DEBUG > 1
   310                                  	extern lites
   311                                  	%endif
   312                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   313                                  	; BIOS call entry for Floppy Disk driver
   314                                  	; int 13h
   315                                  	;
   316                                  	; The Fixed Disk driver will move the vector from 13h to 40h
   317                                  	; At the moment there is no Fixed Disk Driver
   318                                  	;
   319                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   320                                  	global BIOS_call_13h
   321                                  BIOS_call_13h:                ; Floppy driver entry
   322 00000000 FB                      	sti                          ; Enable interrupts
   323 00000001 061E60                  	pushm all, ds, es            ; Standard register save
   324 00000004 89E5                    	mov bp, sp                   ; establish stack addressing
   325                                  
   326 00000006 FC                      	cld                          ; may NOT assume direction flag is clear
   327 00000007 6A40                    	push bios_data_seg
   328 00000009 1F90                    	popm ds                      ; establish addressability for all functions
   329 0000000B C606AE0000              	mov byte [lock_count], 0     ; clear the lock counter
   330                                  
   331                                  	%if SOFT_DEBUG & DUMP
   332 00000010 06525150                	pushm ax, cx, dx, es
   333                                  
   334 00000014 53                      	push bx
   335 00000015 06                      	push es
   336 00000016 30FF                    	xor bh, bh
   337 00000018 88D3                    	mov bl, dl
   338 0000001A 53                      	push bx
   339 0000001B 88CB                    	mov bl, cl
   340 0000001D 53                      	push bx
   341 0000001E 88F3                    	mov bl, dh
   342 00000020 53                      	push bx
   343 00000021 88EB                    	mov bl, ch
   344 00000023 53                      	push bx
   345 00000024 89C3                    	mov bx, ax
   346 00000026 53                      	push bx
   347 00000027 0E                      	push cs
   348 00000028 68[9108]                	push rwvc
   349 0000002B E8(0000)                	call _cprintf
   350 0000002E 83C412                  	add sp, 18
   351                                  
   352 00000031 58595A0790              	popm ax, cx, dx, es
   353 00000036 30FF                    	xor bh, bh
   354                                  	%endif
   355 00000038 88E3                    	mov bl, ah                   ; set to index into dispatch table
   356 0000003A 80FC19                  	cmp ah, max / 2
   357 0000003D 7202                    	jb .1
   358 0000003F B314                    	mov bl, 14h                  ; fn not defined for Floppy diskette
   359 00000041 30FF                    .1: xor bh, bh
   360 00000043 D1E3                    	shl bx, 1                    ; index words
   361 00000045 2EFF97[8300]            	cs call near [dispatch + bx]
   362                                  
   363                                  	; returns come here with AH set
   364                                  
   365 0000004A 08E4                    	or ah, ah                    ; is return code 0? sets carry=0, too
   366 0000004C 7401                    	jz exit_pops
   367                                  error_exit:
   368 0000004E F9                      	stc
   369                                  exit_pops:
   370 0000004F 88660F                  	mov [bp + offset_AH], ah     ; store for return
   371 00000052 89EC                    	mov sp, bp                   ; remove any allocated variables
   372                                  	%if SOFT_DEBUG & DUMP
   373 00000054 9C                      	pushm f                      ;, ax, bx, cx, dx, es
   374 00000055 88E0                    	mov al, ah                   ; save AH in AL
   375 00000057 9F                      	lahf                         ; get flags
   376 00000058 30FF                    	xor bh, bh                   ; Zap BH
   377 0000005A 8A1E9300                	mov bl, [fdc_op_start + 1]
   378 0000005E 53                      	push bx
   379 0000005F 8A1E9200                	mov bl, [fdc_op_start]
   380 00000063 53                      	push bx
   381 00000064 88E3                    	mov bl, ah
   382 00000066 83E301                  	and bx, 1                    ; mask Carry
   383 00000069 53                      	push bx
   384 0000006A 88C3                    	mov bl, al                   ; former AH
   385 0000006C 53                      	push bx
   386 0000006D 0E                      	push cs                      ; far pointer to ...
   387 0000006E 68[C508]                	push fnret                   ; format
   388 00000071 E8(0000)                	call _cprintf
   389 00000074 83C40C                  	add sp, 12
   390 00000077 9D                      	popm f                       ;, ax, bx, cx, dx, es
   391                                  	%endif
   392 00000078 611F900790              	popm all, ds, es
   393 0000007D CA0200                  	retf 2                       ; return the carry
   394                                  
   395                                  
   396                                  
   397                                  	;fn00 ; Reset Disk System
   398                                  fn01:                         ; Get Disk System Status
   399                                  	;fn02 ; Read Sector
   400                                  	;fn03 ; Write Sector
   401                                  	;fn04 ; Verify Sector
   402                                  	;fn05: ; Format Track
   403                                  fn06:                         ; Format Bad Track (fixed disk) [PC]
   404                                  fn07:                         ; Format Drive (fixed disk) [PC]
   405                                  	;fn08 ; Get Drive Parameters
   406                                  fn09:
   407                                  fn0A:
   408                                  fn0B:
   409                                  fn0C:
   410                                  fn0D:
   411                                  fn0E:
   412                                  fn0F:
   413                                  fn10:
   414                                  fn11:
   415                                  fn12:
   416                                  fn13:
   417                                  fn14:                         ; * * * fixed disk only * * *
   418                                  	;fn15: ; Get Disk Type [AT]
   419                                  	;fn16: ; Get Disk Change Status (floppy)
   420                                  fn17:                         ; Set Disk Type (floppy)
   421                                  	;fn18: ; Set Media Type for Format (floppy)
   422                                  undefined:
   423 00000080 B401                    	mov ah, ERR_invalid_command  ; equ 1
   424 00000082 C3                      	ret
   425                                  
   426                                  
   427                                  dispatch:
   428 00000083 [ED02]                  	dw fn00                      ; Reset Disk System
   429 00000085 [8000]                  	dw fn01                      ;
   430 00000087 [9003]                  	dw fn02
   431 00000089 [9A03]                  	dw fn03
   432 0000008B [A403]                  	dw fn04
   433 0000008D [2404]                  	dw fn05
   434 0000008F [8000]                  	dw fn06
   435 00000091 [8000]                  	dw fn07
   436 00000093 [4E03]                  	dw fn08
   437 00000095 [8000]                  	dw fn09
   438 00000097 [8000]                  	dw fn0A
   439 00000099 [8000]                  	dw fn0B
   440 0000009B [8000]                  	dw fn0C
   441 0000009D [8000]                  	dw fn0D
   442 0000009F [8000]                  	dw fn0E
   443 000000A1 [8000]                  	dw fn0F
   444 000000A3 [8000]                  	dw fn10
   445 000000A5 [8000]                  	dw fn11
   446 000000A7 [8000]                  	dw fn12
   447 000000A9 [8000]                  	dw fn13
   448 000000AB [8000]                  	dw fn14
   449 000000AD [C104]                  	dw fn15
   450 000000AF [D704]                  	dw fn16
   451 000000B1 [8000]                  	dw fn17
   452 000000B3 [EF04]                  	dw fn18
   453                                  	max equ $ - dispatch
   454                                  
   455                                  
   456                                  	;
   457                                  	; Floppy Drive Types (fn08)
   458                                  	;
   459                                  	; We support:
   460                                  	; 1 = 5.25" 360K 40track yes
   461                                  	; 2 = 5.25" 1.2M 80track yes
   462                                  	; 3 = 3.5" 720K 80track yes
   463                                  	; 4 = 3.5" 1.44M 80track yes
   464                                  	; 6 = 3.5" 2.88M 80track no (WD37C65CJM & 32Mhz osc)
   465                                  	; 7 = 3.5" 1.28M 1024sect no (Japan)
   466                                  	;
   467                                  	; Floppy Combos
   468                                  	; 5 = 5.25" 360K 40track in Drive Type 2 no
   469                                  	; 8 = 5.25" 512k 77track / 128sector in Drv 2 (future) CP / M
   470                                  	; 9 = 3.5" 256k 77track / 128sector in Drv 3 (future) CP / M
   471                                  	; 10 = 3.5" 512k 77track / 128sector in Drv 4 (future) CP / M
   472                                  	;;
   473                                  
   474                                  D_table:
   475 000000B5 0000                    	dw 0
   476 000000B7 [CB00]                  	dw DTAB1                     ; 360K (MFM)
   477 000000B9 [D800]                  	dw DTAB2                     ; 1.2M
   478 000000BB [E500]                  	dw DTAB3                     ; 720K
   479 000000BD [F200]                  	dw DTAB4                     ; 1.44M
   480 000000BF 0000                    	dw 0                         ; DTAB5
   481 000000C1 0000                    	dw 0                         ; DTAB6
   482 000000C3 [1901]                  	dw DTAB7                     ; 1024 byte sectors (Japan)
   483 000000C5 [2601]                  	dw DTAB8                     ; CP / M 26 / 77 in 1.2M drive (128 byte FM sectors)
   484 000000C7 [3301]                  	dw DTAB9                     ; CP / M 13 / 77 in 720K drive
   485 000000C9 [4001]                  	dw DTAB10                    ; CP / M 26 / 77 in 1.44M drive
   486                                  	L_table equ ($ - D_table) / 2
   487                                  
   488                                  
   489                                  	; Disk Information
   490                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   491                                  	;;; The DOS MFM floppies
   492                                  	; 360K 5.25" DD floppy
   493 000000CB DF022502092AFF50F6-     DTAB1: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   493 000000D4 0F082780           
   494                                  
   495                                  	; 1.2M 5.25" HD floppy
   496 000000D8 DF0225020F1BFF54F6-     DTAB2: db 0DFh, 2, 25h, 2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   496 000000E1 0F084F00           
   497                                  
   498                                  	; 720K 3.5" or 5.25" DD floppy
   499 000000E5 DF022502092AFF50F6-     DTAB3: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   499 000000EE 0F084F80           
   500                                  
   501                                  	; 1.44M 3.5" HD floppy
   502 000000F2 AF022502121BFF6CF6-     DTAB4: db 0AFh, 2, 25h, 2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   502 000000FB 0F084F00           
   503                                  
   504                                  	; 360K 5.25" DD floppy in 1.2M HD drive
   505 000000FF DF022502092AFF50F6-     DTAB5: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   505 00000108 0F082740           
   506                                  
   507                                  	; 2.88M 3.5" XD floppy
   508 0000010C AF022502241BFF50F6-     DTAB6: db 0AFh, 2, 25h, 2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   508 00000115 0F084FC0           
   509                                  
   510                                  	; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   511 00000119 AF0225030835FF74F6-     DTAB7: db 0AFh, 2, 25h, 3, 8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   511 00000122 0F084F00           
   512                                  
   513                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   514                                  	;;; The CP / M FM floppies
   515                                  	; 500K 5.25" CP / M (FM) floppy in 1.2M drive
   516 00000126 DF0225001A098023E5-     DTAB8: db 0DFh, 2, 25h, 0, 26, 9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   516 0000012F 0F084C00           
   517                                  	;;; 7h 1Bh
   518                                  
   519                                  	; 250K 3.5" CP / M (FM) floppy in 720K drive
   520 00000133 DF0225000D138046E5-     DTAB9: db 0DFh, 2, 25h, 0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   520 0000013C 0F084C80           
   521                                  
   522                                  	; 500K 3.5" CP / M (FM) floppy in 1.44M drive
   523 00000140 AF0225001A15804BE5-     DTAB10: db 0AFh, 2, 25h, 0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   523 00000149 0F084C00           
   524                                  
   525                                  
   526                                  	; DTAB table offsets
   527                                  	DTAB_specify equ 0
   528                                  	DTAB_specify2 equ DTAB_specify + 1
   529                                  	DTAB_turnoff_ticks equ DTAB_specify2 + 1
   530                                  	DTAB_N_param equ DTAB_turnoff_ticks + 1
   531                                  	DTAB_EOT_nsect equ DTAB_N_param + 1
   532                                  	DTAB_rw_gap equ DTAB_EOT_nsect + 1
   533                                  	DTAB_data_len equ DTAB_rw_gap + 1
   534                                  	DTAB_fmt_gap3 equ DTAB_data_len + 1
   535                                  	DTAB_fmt_fill equ DTAB_fmt_gap3 + 1
   536                                  	DTAB_unknown equ DTAB_fmt_fill + 1
   537                                  	DTAB_startup equ DTAB_unknown + 1 ; in 1 / 8 seconds
   538                                  	DTAB_max_cylinder equ DTAB_startup + 1
   539                                  	DTAB_control equ DTAB_max_cylinder + 1
   540                                  
   541                                  
   542                                  
   543                                  	;
   544                                  	; Returns:
   545                                  	; AL = contents of FDC_MSR (Main Status Register)
   546                                  	;
   547                                  get_msr:
   548 0000014D 52                      	push dx
   549 0000014E BA8004                  	mov dx, FDC_MSR
   550 00000151 EC                      	in al, dx
   551                                  	%if SOFT_DEBUG > 1
   552                                  	push ax
   553                                  	call lites
   554                                  	%endif
   555 00000152 5A                      	pop dx
   556 00000153 C3                      	ret
   557                                  
   558                                  	; delay for about 12 microseconds for MSR to be set
   559                                  	extern microsecond
   560                                  	global wait12
   561                                  wait12:
   562 00000154 51                      	push cx
   563                                  	%if 1
   564                                  	; mov cx, 12 ; 12 microseconds
   565 00000155 30ED                    	xor ch, ch
   566 00000157 8A0EFF00                	mov cl, [cpu_xtal]           ; 2x clock (32usec on 16Mhz CPU)
   567 0000015B D0E9                    	shr cl, 1
   568 0000015D 83E905                  	sub cx, 5                    ; fudge factor for overhead
   569                                  	%else
   570                                  	xor ch, ch
   571                                  	mov cl, [wait12_count]
   572                                  	%endif
   573 00000160 E8(0000)                	call microsecond
   574 00000163 59                      	pop cx
   575 00000164 C3                      	ret
   576                                  
   577                                  
   578                                  wait1000:
   579 00000165 51                      	push cx
   580 00000166 B9E803                  	mov cx, 1000                 ; 1 ms delay
   581 00000169 E8(0000)                	call microsecond
   582 0000016C 59                      	pop cx
   583 0000016D C3                      	ret
   584                                  
   585                                  	;
   586                                  	; Convention used below
   587                                  	; Flags: Meaning:
   588                                  	; C=1 error
   589                                  	; C=0, AH=0 okay
   590                                  	; C=0, AH=3 + complete
   591                                  	;
   592                                  	global fdc_ready_for_command
   593                                  fdc_ready_for_command:
   594 0000016E 51                      	push cx
   595                                  
   596                                  .0:
   597 0000016F B9E803                  	mov cx, 1000
   598 00000172 E8DFFF                  .1: call wait12
   599 00000175 E8D5FF                  	call get_msr
   600 00000178 A880                    	test al, RQM                 ; C=0
   601 0000017A E1F6                    	loopz .1
   602                                  	; try to compensate for MSDOS anomaly with a BUSY test
   603 0000017C 7508                    	jnz .req
   604 0000017E A810                    	test al, BUSY                ; How does MSDOS manage this???
   605 00000180 74ED                    	jz .0
   606 00000182 B489                    	mov ah, ERR_89
   607 00000184 EB06                    	jmp .err
   608                                  
   609                                  .req:
   610 00000186 A840                    	test al, DIO                 ; C=0, clear the carry
   611 00000188 7405                    	jz .2                        ; ready for input?
   612 0000018A B481                    	mov ah, ERR_81               ; not ready for input
   613 0000018C F9                      .err: Error                   ; C=1, signal error
   614 0000018D EB02                    	jmp .99
   615                                  
   616 0000018F 30E4                    .2: Okay                      ; AH=0, C=0
   617 00000191 59                      .99: pop cx
   618 00000192 C3                      	ret
   619                                  	; returns Error or Okay
   620                                  
   621                                  
   622                                  	global fdc_ready_for_result
   623                                  fdc_ready_for_result:
   624 00000193 E8BEFF                  	call wait12
   625 00000196 E8B4FF                  	call get_msr
   626 00000199 A810                    	test al, BUSY                ; controller busy?
   627 0000019B 7505                    	jnz .0                       ; jump if busy
   628 0000019D 80CC03                  	Complete                     ; not busy, return Complete
   629 000001A0 EB15                    	jmp .99
   630                                  .0:
   631 000001A2 E8AFFF                  	call wait12
   632 000001A5 E8A5FF                  .1: call get_msr
   633 000001A8 A880                    	test al, RQM                 ; wait for RQM
   634 000001AA 74F9                    	jz .1
   635                                  
   636 000001AC A840                    	test al, DIO                 ; set C=0, Z - flag
   637 000001AE 7505                    	jnz .5                       ; DIO==1 means output
   638 000001B0 B482                    	mov ah, ERR_82
   639 000001B2 F9                      	Error
   640 000001B3 EB02                    	jmp .99
   641                                  
   642 000001B5 30E4                    .5: Okay
   643 000001B7 C3                      .99: ret
   644                                  	; returns Error, Okay, or Complete
   645                                  
   646                                  
   647                                  
   648                                  	; byte to output is in AL
   649                                  	; AH=0 and Carry=0 if all Okay
   650                                  	; Carry=1, AH=code if FDC not ready
   651                                  	global output_byte_to_fdc
   652                                  output_byte_to_fdc:
   653 000001B8 52                      	pushm dx
   654                                  
   655 000001B9 88C2                    	mov dl, al
   656 000001BB E8B0FF                  	call fdc_ready_for_command
   657 000001BE 88D0                    	mov al, dl
   658 000001C0 7206                    	jc .8                        ; propagate error
   659                                  
   660 000001C2 BA8104                  	mov dx, FDC_DATA
   661 000001C5 EE                      	out dx, al
   662 000001C6 30E4                    	Okay                         ; C=0, AH=okay
   663                                  .8:
   664 000001C8 5A                      	popm dx
   665 000001C9 C3                      	ret                          ; C=0, AH=okay
   666                                  	; returns Error or Okay
   667                                  
   668                                  
   669                                  	global input_byte_from_fdc
   670                                  input_byte_from_fdc:
   671 000001CA 52                      	push dx
   672 000001CB E8C5FF                  	call fdc_ready_for_result
   673 000001CE 7208                    	jc .9                        ; propagate error
   674 000001D0 7506                    	jnz .9                       ; if (Complete) return Complete;
   675                                  
   676 000001D2 BA8104                  	mov dx, FDC_DATA
   677 000001D5 EC                      	in al, dx
   678 000001D6 30E4                    	Okay                         ; return Okay
   679                                  .9:
   680 000001D8 5A                      	pop dx
   681 000001D9 C3                      	ret                          ;
   682                                  	; returns Error, Okay, or Complete
   683                                  
   684                                  
   685                                  	; CX = length of command
   686                                  	; DX:SI = pointer to command (not DS:SI, we'll set this up)
   687                                  	;
   688                                  	global output_cmd_to_fdc
   689                                  output_cmd_to_fdc:
   690 000001DA 0656                    	pushm si, es
   691 000001DC 8EC2                    	mov es, dx                   ; DS:SI is now the source
   692 000001DE 90                      	cnop
   693                                  
   694                                  	%if SOFT_DEBUG & DUMP
   695 000001DF 268A04                  	es mov al, [si]              ; record two bytes of command
   696 000001E2 A29200                  	mov [fdc_op_start], al
   697 000001E5 268A4401                	es mov al, [si + 1]          ; first & second
   698 000001E9 A29300                  	mov [fdc_op_start + 1], al
   699                                  	%endif
   700                                  
   701 000001EC E8F406                  	call @disable
   702                                  .1:
   703 000001EF 26AC                    	es lodsb                     ; note segment override
   704 000001F1 E8C4FF                  	call output_byte_to_fdc      ; returns error or okay
   705 000001F4 7206                    	jc .7                        ; propagate any error
   706 000001F6 E2F7                    	loop .1
   707                                  
   708 000001F8 30E4                    	Okay                         ; return ok
   709 000001FA EB01                    	jmp .9
   710                                  
   711 000001FC F9                      .7: Error                     ; propagate error
   712                                  
   713 000001FD E8F406                  .9: call @enable
   714 00000200 5E0790                  	popm si, es
   715 00000203 C3                      	ret
   716                                  	; returns Error or Okay
   717                                  
   718                                  
   719                                  
   720                                  	; assumes DS points at BIOS Data Area
   721                                  	; preserves DI
   722                                  	global input_result_from_fdc
   723                                  input_result_from_fdc:
   724 00000204 5157                    	pushm di, cx
   725 00000206 E8DA06                  	call @disable                ; lock the operation
   726                                  
   727 00000209 BF4200                  	mov di, fdc_ctrl_status      ; in BIOS Data Area
   728 0000020C B90800                  	mov cx, 8                    ; 7 bytes input, then 'complete'
   729                                  
   730 0000020F E8B8FF                  .0: call input_byte_from_fdc
   731 00000212 7217                    	jc .9                        ; propagate error
   732 00000214 7511                    	jnz .8                       ; if complete, return okay
   733                                  
   734 00000216 8805                    	mov byte [di], al            ; store the result
   735 00000218 47                      	inc di
   736 00000219 E2F4                    	loop .0
   737                                  
   738 0000021B E836FF                  	call wait12                  ;
   739 0000021E E82CFF                  	call get_msr                 ; check for busy
   740 00000221 A810                    	test al, BUSY
   741                                  
   742 00000223 B483                    	mov ah, ERR_83
   743 00000225 7504                    	jnz .95                      ; return error if busy
   744                                  
   745                                  .8:
   746 00000227 30E4                    	Okay                         ; return okay
   747 00000229 EB01                    	jmp .99                      ; single return point
   748                                  
   749                                  .9:
   750 0000022B F9                      .95: Error                    ; return error;
   751                                  
   752 0000022C E8C506                  .99: call @enable             ; unlock the operation
   753 0000022F 5F59                    	popm di, cx
   754 00000231 C3                      	ret
   755                                  	; returns Error, Okay, or Complete
   756                                  
   757                                  
   758                                  	%define INT_ENABLE 1
   759                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   760                                  	;
   761                                  	; Floppy Disk Controller
   762                                  	; Interrupt Handler
   763                                  	;
   764                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   765                                  	global fdc_interrupt_level
   766                                  fdc_interrupt_level:
   767                                  	%if INT_ENABLE
   768 00000232 FB                      	sti
   769                                  	%endif
   770 00000233 1E60                    	pushm all, ds
   771 00000235 FC                      	cld                          ; just be sure
   772                                  
   773 00000236 6A40                    	push bios_data_seg
   774 00000238 1F90                    	popm ds
   775                                  	%if INT_ENABLE==0
   776                                  	inc byte [lock_count]        ; so we don't re - enable
   777                                  	%endif
   778 0000023A E810FF                  	call get_msr
   779 0000023D A810                    	test al, BUSY                ; test for controller busy
   780 0000023F 740A                    	jz .4
   781                                  	; BUSY is set
   782 00000241 E8C0FF                  	call input_result_from_fdc
   783 00000244 18C0                    	sbb al, al                   ; carry to AL
   784 00000246 A24100                  	mov byte [fdc_status], al    ; FF=error, 0=okay
   785 00000249 EB2C                    	jmp .9                       ; we got the results
   786                                  
   787                                  
   788                                  	; FDC not busy:
   789                                  
   790                                  .4:
   791                                  	;; xor bh, bh ; BH = false
   792 0000024B B008                    .5: mov al, CMD_SENSE_INT_STATUS
   793 0000024D E868FF                  	call output_byte_to_fdc
   794 00000250 7225                    	jc .9                        ; quit if error
   795 00000252 E8AFFF                  	call input_result_from_fdc
   796 00000255 7220                    	jc .9
   797                                  
   798 00000257 A04200                  	mov al, [fdc_ctrl_status]    ; get ST0
   799 0000025A 3480                    	xor al, 80h                  ; IC= 10xxxxxxb (invalid)
   800 0000025C 24C0                    	and al, ST0_IC               ; isolate IC
   801 0000025E 7417                    	je .9                        ; invalid command
   802                                  
   803 00000260 A14200                  	mov ax, [fdc_ctrl_status]    ; get ST0 + PCN (present cylinder)
   804 00000263 A820                    	test al, ST0_SE              ; test Seek End condition
   805 00000265 74E4                    	jz .5
   806                                  
   807 00000267 89C7                    	mov di, ax                   ;
   808 00000269 83E701                  	and di, ST0_US               ; isolate unit number
   809 0000026C 88A59400                	mov [fdc_cylinder + di], ah  ; set PCN from controller
   810 00000270 800E3E0004              	or byte [fdc_drv_calib], 04h ;POST Seek End seen
   811 00000275 EBD4                    	jmp .5
   812                                  
   813                                  
   814                                  .9:
   815 00000277 800E3E0001              	or byte [fdc_drv_calib], 01h ;POST end of FDC interrupt
   816                                  	%if INT_ENABLE==0
   817                                  	dec byte [lock_count]        ; restore the lock count
   818                                  	%endif
   819                                  	; signal EOI (End of Interrupt)
   820 0000027C BA22FF                  	mov dx, PIC_EOI              ; EOI register
   821 0000027F B80080                  	mov ax, EOI_NSPEC            ; non - specific
   822 00000282 EF                      	out dx, ax                   ; signal it
   823                                  
   824 00000283 611F90                  	popm all, ds
   825 00000286 CF                      	iret
   826                                  
   827                                  
   828                                  
   829                                  	global fdc_timer_hook
   830                                  	; called from Timer Tick code with DS - >BIOS data area
   831                                  	; Destroys AX and DX
   832                                  	global fdc_timer_hook
   833                                  fdc_timer_hook:
   834 00000287 803E400000              	cmp byte [fdc_motor_ticks], 0
   835 0000028C 740E                    	je .9
   836 0000028E FE0E4000                	dec byte [fdc_motor_ticks]
   837 00000292 7508                    	jnz .9
   838                                  	; timer expired, stop the motors
   839 00000294 80263F00CF              	and byte [fdc_motor_LDOR], ~(MOEN1 + MOEN2)
   840 00000299 E80100                  	call out_LDOR_mem
   841 0000029C C3                      .9: ret
   842                                  
   843                                  
   844                                  
   845                                  	; FDC Operations Register operations
   846                                  	; put out the LDOR write - only register
   847                                  	; Assumes DS is BIOS data segment
   848                                  	; Destroys AX and DX
   849                                  out_LDOR_mem:
   850 0000029D A03F00                  	mov al, [fdc_motor_LDOR]
   851 000002A0 BA8604                  	mov dx, FDC_LDOR
   852 000002A3 EE                      	out dx, al
   853 000002A4 C3                      	ret
   854                                  
   855                                  
   856                                  	; wait until all seeking is done
   857                                  	; assumes DS is set to BIOS data area
   858                                  	;
   859                                  	global fdc_wait_seek_done
   860                                  fdc_wait_seek_done:
   861                                  .1:
   862 000002A5 E8ACFE                  	call wait12
   863 000002A8 E8A2FE                  	call get_msr
   864 000002AB A80F                    	test al, 0Fh                 ; test all the seek bits
   865 000002AD 740C                    	jz .8
   866 000002AF 803E400000              	cmp byte [fdc_motor_ticks], 0
   867 000002B4 75EF                    	jnz .1
   868 000002B6 B480                    	mov ah, ERR_disk_timeout
   869 000002B8 F9                      .7: Error                     ; signal error
   870 000002B9 EB22                    	jmp .9
   871                                  
   872                                  .8:                           ; seek is done, check ST0 bits
   873 000002BB F6063E0004              	test byte [fdc_drv_calib], 04h ; Seek End seen?
   874 000002C0 7512                    	jnz .okay
   875                                  
   876 000002C2 F6064200C0              	test byte [fdc_ctrl_status], ST0_IC ; interrupt code
   877 000002C7 B484                    	mov ah, ERR_84
   878 000002C9 75ED                    	jnz .7
   879 000002CB F606420020              	test byte [fdc_ctrl_status], ST0_SE ; Seek End
   880 000002D0 B440                    	mov ah, ERR_seek_failed
   881 000002D2 74E4                    	jz .7
   882                                  .okay:
   883                                  
   884                                  	%if 0
   885                                  	; add settle time - - may not really be needed
   886                                  	mov al, [fdc_motor_ticks]
   887                                  	add al, 450 / 54
   888                                  	xchg al, [fdc_motor_ticks]
   889                                  .settle:
   890                                  	cmp [fdc_motor_ticks], al
   891                                  	ja .settle
   892                                  	%else
   893                                  	; add time for more revolutions if a seek occurs
   894 000002D4 2E8A4702                	cs mov al, [DTAB_turnoff_ticks + bx]
   895 000002D8 A24000                  	mov [fdc_motor_ticks], al
   896                                  	%endif
   897                                  
   898 000002DB 30E4                    	Okay                         ; IC==00 and SE=1
   899 000002DD C3                      	.9 ret
   900                                  
   901                                  	;
   902                                  	; power on init
   903                                  	;
   904                                  	global @floppy_init
   905                                  @floppy_init:
   906                                  
   907                                  	%if DEBUG
   908                                  	; do some debug I / O
   909 000002DE 52                      	push dx
   910 000002DF 50                      	push ax
   911 000002E0 BA3006                  	mov dx, FRONT_PANEL_LED      ;JRC's debug lights
   912 000002E3 B003                    	mov al, 03h
   913 000002E5 EE                      	out dx, al
   914 000002E6 58                      	pop ax
   915 000002E7 5A                      	pop dx
   916                                  	%endif
   917                                  
   918 000002E8 B400                    	mov ah, 0                    ; fn00
   919 000002EA CD13                    	int 13h
   920 000002EC C3                      	ret
   921                                  
   922                                  
   923                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   924                                  	; Function 00h Reset the Disk System
   925                                  	; Used both at power on and after a serious error
   926                                  	;
   927                                  	; Enter with:
   928                                  	; AH = 00h
   929                                  	; DL = drive 0 or 1
   930                                  	;
   931                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   932                                  fn00:
   933                                  
   934 000002ED C606AD0020              	mov byte [wait12_count], 32  ; this is about the max.
   935 000002F2 E85FFE                  	call wait12                  ; wait 12 microseconds
   936 000002F5 E855FE                  	call get_msr                 ; set BASE mode
   937 000002F8 E859FE                  	call wait12                  ; wait 12 microseconds
   938                                  
   939 000002FB C6063F0008              	mov byte [fdc_motor_LDOR], (MODE + RESET + DMAEN) ; set PC_AT mode
   940 00000300 E89AFF                  	call out_LDOR_mem
   941 00000303 E84EFE                  	call wait12
   942                                  
   943                                  	%if 1
   944                                  	;;; This read may not be necessary, unless Special Mode is set
   945 00000306 BA8504                  	mov dx, FDC_LDCR
   946 00000309 EC                      	in al, dx                    ; read a write - only register to latch Mode
   947                                  	;;;;;
   948                                  	%endif
   949 0000030A E858FE                  	call wait1000
   950                                  
   951 0000030D 800E3F000C              	or byte [fdc_motor_LDOR], (MODE + NO_RESET + DMAEN) ; remove the RESET
   952 00000312 E888FF                  	call out_LDOR_mem
   953 00000315 E83CFE                  	call wait12
   954                                  
   955                                  	%if 0
   956                                  	mov dx, FDC_LDCR
   957                                  	mov al, FDC_HD               ; set for HD disks
   958                                  	out dx, al
   959                                  	%endif
   960                                  
   961 00000318 BACAFF                  	mov dx, DMA0 + DMACW
   962                                  	%if 1
   963 0000031B B80400                  	mov ax, 4                    ; set change bit
   964                                  	%else
   965                                  	in ax, dx
   966                                  	and ax, ~2                   ; clear the stop bit
   967                                  	or ax, 4                     ; set the change bit
   968                                  	%endif
   969 0000031E EF                      	out dx, ax
   970                                  
   971 0000031F BA34FF                  	mov dx, PIC_DMA0CR
   972 00000322 B80700                  	mov ax, 0007h                ; MSK=0, PRI=7
   973 00000325 EF                      	out dx, ax                   ; enable DMA0 interrupts
   974                                  
   975 00000326 31C0                    	xor ax, ax
   976 00000328 A24000                  	mov [fdc_motor_ticks], al    ; Zero the timer tick counter
   977 0000032B A28B00                  	mov [fdc_last_rate], al      ; force a specify command
   978                                  
   979 0000032E 8EC0                    	mov es, ax
   980 00000330 90                      	cnop
   981 00000331 26A37800                	es mov [1Eh * 4], ax
   982 00000335 26A37A00                	es mov [1Eh * 4 + 2], ax     ; Zap the parameter pointer
   983                                  
   984 00000339 C7069400FFFF            	mov word [fdc_cylinder], - 1 ; Specify & Recalibration needed
   985                                  
   986                                  	; now allow time for the polling interrupts
   987 0000033F B90100                  	mov cx, 102400>>16           ; 0.1 seconds
   988 00000342 31D2                    	xor dx, dx                   ; CX:DX is delay in usec
   989 00000344 B486                    	mov ah, 86h                  ; delay in microseconds
   990 00000346 CD15                    	int 15h
   991                                  
   992 00000348 E8B9FE                  	call input_result_from_fdc
   993                                  
   994 0000034B 30E4                    	Okay                         ; signal good execution
   995 0000034D C3                      	ret                          ; end of FN00
   996                                  
   997                                  
   998                                  
   999                                  
  1000                                  
  1001                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1002                                  	; Function 08h Get Drive Parameters
  1003                                  	;
  1004                                  	; Enter with:
  1005                                  	; AH = 08h
  1006                                  	; DL = drive 0 or 1
  1007                                  	;
  1008                                  	; Return with:
  1009                                  	; Carry clear if no error
  1010                                  	; BL = drive type (2 or 4 for us)
  1011                                  	; CH = max cylinder number
  1012                                  	; CL = max sector number
  1013                                  	; DH = max head number
  1014                                  	; DL = number of drives
  1015                                  	; ES:DI = address of disk parameter table
  1016                                  	;
  1017                                  	; Carry set on error
  1018                                  	; AH = error code
  1019                                  	;
  1020                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1021                                  fn08:                         ; Get Drive Parameters
  1022 0000034E A01000                  	mov al, [equipment_flag]
  1023 00000351 B401                    	mov ah, 1
  1024 00000353 20C4                    	and ah, al                   ; any floppies at all?
  1025 00000355 7407                    	jz .2
  1026 00000357 C0C002                  	rol al, 2                    ; at least one
  1027 0000035A 2403                    	and al, 3
  1028 0000035C 00C4                    	add ah, al                   ; 1..4
  1029                                  .2:
  1030 0000035E 88660A                  	mov [offset_DL + bp], ah     ; return # of drives
  1031 00000361 E8E601                  	call check_DL
  1032 00000364 7221                    	jc .err_no_drive
  1033 00000366 E8F801                  	call get_disk_type
  1034 00000369 884608                  	mov [offset_BL + bp], al     ; return BL = disk type
  1035 0000036C E80102                  	call get_media
  1036 0000036F 2E8A670B                	cs mov ah, [DTAB_max_cylinder + bx]
  1037 00000373 2E8A4704                	cs mov al, [DTAB_EOT_nsect + bx]
  1038 00000377 89460C                  	mov [offset_CX + bp], ax     ; return CYL | SECT in CX
  1039 0000037A C6460B01                	mov byte [offset_DH + bp], 1 ; head max. always 1
  1040 0000037E 8C4E12                  	mov [offset_ES + bp], cs     ; return ES param table
  1041 00000381 895E00                  	mov [offset_DI + bp], bx     ; return DI param table
  1042                                  
  1043 00000384 30E4                    	xor ah, ah                   ; no error
  1044 00000386 C3                      	ret
  1045                                  
  1046                                  .err_no_drive:
  1047 00000387 B401                    	mov ah, ERR_invalid_command  ; error if no floppies
  1048 00000389 C3                      	ret                          ; DL is still zero !!!
  1049                                  
  1050                                  
  1051                                  
  1052                                  
  1053                                  
  1054                                  
  1055                                  	%if 0
  1056                                  	; validate the READ / WRITE CHS, SC parameters
  1057                                  	; Enter with DI pointing at the type table
  1058                                  	;
  1059                                  	; Carry clear if okay
  1060                                  	; Carry set if invalid
  1061                                  	; AX & all other registers are preserved
  1062                                  validate_call:
  1063                                  	push ax
  1064                                  
  1065                                  	cs cmp ch, [DTAB_max_cyl + di]
  1066                                  	jnbe .7
  1067                                  	cs mov ah, [DI_heads + di]
  1068                                  	sub ah, dh
  1069                                  	jbe .7
  1070                                  	cs mov al, [DTAB_EOT_nsect + di]
  1071                                  	dec cl                       ; base sectors at 0
  1072                                  	cmp cl, al
  1073                                  	jnc .6                       ; JNC = JNB = JAE
  1074                                  	mul ah
  1075                                  	; AX is 1 or 2 * sectors
  1076                                  	sub al, cl
  1077                                  	; AL is the maximum number of sectors we can transfer
  1078                                  	cmp al, [offset_AX + bp]     ; compare to sector count
  1079                                  .6: inc cl                    ; back to sectors from 1
  1080                                  	jnc .8                       ; JAE = JNB = JNC
  1081                                  .7: stc
  1082                                  .8: pop ax                    ;
  1083                                  	ret
  1084                                  	%endif
  1085                                  
  1086                                  
  1087                                  
  1088                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1089                                  	; Function 02h Read Sectors
  1090                                  	; Function 03h Write Sectors
  1091                                  	; Function 04h Verify Sectors
  1092                                  	;
  1093                                  	; Enter with:
  1094                                  	; AH = 02h (read)
  1095                                  	; AH = 03h (write)
  1096                                  	; AH = 04h (verify)
  1097                                  	; AL = number of sectors to transfer
  1098                                  	; CH = cylinder number
  1099                                  	; CL = sector number
  1100                                  	; DH = head number
  1101                                  	; DL = drive 0 or 1
  1102                                  	; ES:BX = buffer to read into or write from
  1103                                  	;
  1104                                  	; Return with:
  1105                                  	; Carry clear if no error
  1106                                  	; AH = 0
  1107                                  	; AL = number of sectors transferred
  1108                                  	;
  1109                                  	; Carry set on error
  1110                                  	; AH = error code
  1111                                  	;
  1112                                  	; All other registers are preserved.
  1113                                  	;
  1114                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1115                                  	;
  1116                                  	; Stack variables
  1117                                  	;
  1118                                  	rwv_return equ - 2           ; offset from BP
  1119                                  	rwv_dma equ rwv_return - 2
  1120                                  	rwv_xfer equ rwv_dma - 2
  1121                                  	rwv_cmd equ rwv_xfer - 9
  1122                                  	rwv_AL equ rwv_cmd - 1
  1123                                  	rwv_stack equ - rwv_AL
  1124                                  
  1125                                  	;FDC_DMA_READ equ (101b<<13) + (011b<<10) + (11b<<8) + (01b<<6) + (00b<<4) + 0110b
  1126                                  	FDC_DMA_READ equ (101b<<13) + (000b<<10) + (11b<<8) + (01b<<6) + (10b<<4) + 0110b
  1127                                  
  1128                                  	;FDC_DMA_WRITE equ (011b<<13) + (101b<<10) + (11b<<8) + (10b<<6) + (00b<<4) + 0110b
  1129                                  	FDC_DMA_WRITE equ (000b<<13) + (101b<<10) + (11b<<8) + (10b<<6) + (10b<<4) + 0110b
  1130                                  
  1131                                  	;FDC_DMA_READ equ (101b<<13) + (000b<<10) + (11b<<8) + (01b<<6) + (10b<<4) + 0110b
  1132                                  	FDC_DMA_SCAN equ (100b<<13) + (000b<<10) + (11b<<8) + (01b<<6) + (10b<<4) + 0110b
  1133                                  
  1134                                  	FDC_DMA_FORMAT equ FDC_DMA_WRITE
  1135                                  
  1136                                  
  1137                                  	%if SOFT_DEBUG
  1138 0000038A 66A3                    	dw FDC_DMA_READ
  1139 0000038C A617                    	dw FDC_DMA_WRITE
  1140 0000038E 6683                    	dw FDC_DMA_SCAN
  1141                                  	%endif
  1142                                  
  1143                                  fn02:                         ; READ
  1144 00000390 B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1145 00000392 BF66A3                  	mov di, FDC_DMA_READ
  1146 00000395 BB[5406]                	mov bx, xfer_read_sector
  1147 00000398 EB12                    	jmp rwv_common
  1148                                  
  1149                                  	%define EXTRA 0
  1150                                  fn03:                         ; WRITE
  1151                                  	%if EXTRA
  1152                                  	cmp al, 1
  1153                                  	jbe .10
  1154                                  
  1155                                  	mov bx, [offset_BX + bp]     ; restore BX
  1156                                  	mov [offset_AH + bp], al     ; use return code as counter
  1157                                  
  1158                                  .1: mov ax, 0301h             ; write 1 sector
  1159                                  	int 13h
  1160                                  	jc .5
  1161                                  
  1162                                  	inc cl                       ; increment sector number
  1163                                  	add bx, 200h                 ; increment transfer address
  1164                                  	dec byte [offset_AH + bp]
  1165                                  	jnz .1
  1166                                  
  1167                                  	Okay                         ; all went Okay
  1168                                  	ret
  1169                                  
  1170                                  	; process error return
  1171                                  	; AH = error code
  1172                                  .5: mov al, [offset_AL + bp]  ; sectors requested
  1173                                  	sub al, [offset_AH + bp]     ; sectors remaining
  1174                                  	mov [offset_AL + bp], al     ; set sectors transferred
  1175                                  	Error
  1176                                  	ret
  1177                                  
  1178                                  .10:
  1179                                  	%endif
  1180 0000039A B4C5                    	mov ah, (CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1181 0000039C BFA617                  	mov di, FDC_DMA_WRITE
  1182 0000039F BB[CF06]                	mov bx, xfer_write_sector
  1183 000003A2 EB08                    	jmp rwv_common
  1184                                  
  1185                                  fn04:                         ; VERIFY
  1186 000003A4 B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1187 000003A6 BF6683                  	mov di, FDC_DMA_SCAN
  1188 000003A9 BB[0407]                	mov bx, xfer_verify_sector
  1189                                  	;;; jmp rwv_common
  1190                                  
  1191                                  	; Common code to READ, WRITE, and VERIFY
  1192                                  rwv_common:
  1193 000003AC 57                      	push di                      ; dma control register
  1194 000003AD 53                      	push bx                      ; transfer function
  1195 000003AE 83EC08                  	sub sp, rwv_stack - 8        ; 4 words in stack by pushes or Call
  1196 000003B1 50                      	push ax                      ; including this push
  1197                                  
  1198 000003B2 E89501                  	call check_DL                ; sets DI
  1199 000003B5 B401                    	mov ah, ERR_invalid_command
  1200 000003B7 7267                    	jc .exit
  1201 000003B9 E8A501                  	call get_disk_type
  1202 000003BC E8B101                  	call get_media               ; get media pointer to CS:BX
  1203 000003BF E8BA01                  	call set_media_pointer       ; set up Int 1Eh
  1204 000003C2 E82A02                  	call motor_on                ; use DI to start motor
  1205                                  
  1206 000003C5 E8C003                  	call Seek                    ; use CH to seek to track
  1207                                  	; recalibrate is possible
  1208 000003C8 7256                    	jc .exit                     ; AH is error code
  1209                                  
  1210 000003CA E87002                  	call make_head_unit          ; AL is next byte
  1211                                  
  1212 000003CD 571E06                  	pushm es, ds, di
  1213 000003D0 8D7EF2                  	lea di, [rwv_cmd + 1 + bp]   ; SS override not needed
  1214 000003D3 8D7703                  	lea si, [DTAB_N_param + bx]
  1215 000003D6 160E                    	pushm cs, ss
  1216 000003D8 1F900790                	popm ds, es
  1217 000003DC AA                      	stosb                        ; store head unit in cmd stream
  1218 000003DD 88E8                    	mov al, ch                   ; cylinder
  1219 000003DF AA                      	stosb
  1220 000003E0 88F0                    	mov al, dh                   ; head
  1221 000003E2 AA                      	stosb
  1222 000003E3 88C8                    	mov al, cl                   ; sector (R)
  1223 000003E5 AA                      	stosb
  1224 000003E6 AC                      	lodsb                        ; get N
  1225 000003E7 88C1                    	mov cl, al
  1226 000003E9 AA                      	stosb                        ; store N
  1227 000003EA A4                      	movsb                        ; EOT
  1228 000003EB A4                      	movsb                        ; GPL
  1229 000003EC A4                      	movsb                        ; DTL = FF
  1230 000003ED 8D76F1                  	lea si, [rwv_cmd + bp]       ; get command start
  1231 000003F0 07901F905F              	popm es, ds, di
  1232                                  
  1233 000003F5 B88000                  	mov ax, 128                  ; minimum sector size
  1234 000003F8 F666F0                  	mul byte [rwv_AL + bp]       ; times number of sectors to transfer
  1235 000003FB D3E0                    	shl ax, cl                   ; shift by N_param
  1236 000003FD 89C1                    	mov cx, ax                   ; CX is byte count of transfer
  1237                                  
  1238 000003FF 53                      	pushm bx                     ; save DTAB pointer
  1239                                  
  1240 00000400 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1241 00000403 8CC3                    	mov bx, es                   ; segment to AX
  1242 00000405 89DA                    	mov dx, bx                   ; and to DX
  1243 00000407 C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1244 0000040A C1E204                  	shl dx, 4                    ; high part of offset from segment
  1245 0000040D 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1246 0000040F 83D300                  	adc bx, 0                    ; and carry into the high bits
  1247                                  
  1248 00000412 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1249                                  
  1250                                  .marker:
  1251                                  	; BX:AX transfer 20 - bit address in memory
  1252                                  	; CX transfer byte count
  1253                                  	; DX:SI pointer to 9 - byte FDC command
  1254                                  	;
  1255 00000414 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1256                                  
  1257 00000419 FF56FA                  	call near [rwv_xfer + bp]    ;call specific transfer function
  1258                                  
  1259 0000041C 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1260                                  	;;; jc .exit ; AH is set to error code
  1261                                  
  1262 0000041D E8CC03                  	call Check_RW_Status         ; get final return code
  1263                                  
  1264                                  .exit:
  1265 00000420 8D66FE                  	lea sp, [rwv_return + bp]
  1266 00000423 C3                      	ret
  1267                                  
  1268                                  	%if SOFT_DEBUG
  1269                                  	end_rwv equ $
  1270                                  	%endif
  1271                                  
  1272                                  
  1273                                  
  1274                                  	; Format stack layout
  1275                                  	fmt_return equ - 2           ; return from fn05 call
  1276                                  	fmt_dma equ fmt_return - 2
  1277                                  	fmt_cmd equ fmt_dma - 6
  1278                                  	fmt_stack equ - fmt_cmd      ; stack size
  1279                                  
  1280                                  	%if fmt_dma != rwv_dma
  1281                                  	%error "fmt_dma != rwv_dma"
  1282                                  	%endif
  1283                                  
  1284                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1285                                  	; Function 05h Format a Track
  1286                                  	;
  1287                                  	; Precede with call to Function 18h (or 17h) to set the disk type
  1288                                  	;
  1289                                  	; Enter with:
  1290                                  	; AH = 05h
  1291                                  	; CH = cylinder number
  1292                                  	; DH = head number
  1293                                  	; DL = drive 0 or 1
  1294                                  	; ES:BX = segment / offset of address field list (C / H / R / N)
  1295                                  	;
  1296                                  	; Return with:
  1297                                  	; Carry clear if no error
  1298                                  	; AH = 0
  1299                                  	;
  1300                                  	; Carry set on error
  1301                                  	; AH = error code
  1302                                  	;
  1303                                  	; All other registers are preserved.
  1304                                  	;
  1305                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1306                                  fn05:
  1307 00000424 83EC0A                  	sub sp, fmt_stack            ; allocate stack space
  1308 00000427 C746FCA617              	mov word [fmt_dma + bp], FDC_DMA_FORMAT
  1309                                  
  1310 0000042C E81B01                  	call check_DL                ; sets DI
  1311 0000042F B401                    	mov ah, ERR_invalid_command
  1312 00000431 7272                    	jc .exit
  1313                                  
  1314 00000433 06                      	pushm es                     ; save ES
  1315 00000434 6A00                    	push 0
  1316 00000436 0790                    	popm es
  1317 00000438 8CCB                    	mov bx, cs                   ; get CS segment
  1318 0000043A 263B1E7A00              	es cmp bx, [1Eh * 4 + 2]     ; check segment is CS
  1319 0000043F 7564                    	jne .exit                    ; (will restore stack)
  1320                                  
  1321 00000441 268B1E7800              	es mov bx, [1Eh * 4]         ; get CS:BX as disk param table pointer
  1322 00000446 0790                    	popm es                      ; restore Stack
  1323                                  
  1324 00000448 E8A401                  	call motor_on                ; use DI to start motor
  1325                                  
  1326 0000044B E83A03                  	call Seek                    ; use CH to seek to track
  1327                                  	; recalibrate is possible
  1328 0000044E 7255                    	jc .exit                     ; AH is error code
  1329                                  
  1330 00000450 E8EA01                  	call make_head_unit          ; AL is next byte
  1331 00000453 88C4                    	mov ah, al                   ; save head / unit in AH
  1332                                  
  1333 00000455 571E06                  	pushm es, ds, di
  1334                                  
  1335 00000458 160E                    	pushm cs, ss
  1336 0000045A 1F900790                	popm ds, es
  1337 0000045E 8D7EF6                  	lea di, [bp + fmt_cmd]
  1338 00000461 8D7703                  	lea si, [bx + DTAB_N_param]
  1339                                  
  1340 00000464 B00D                    	mov al, CMD_FORMAT_A_TRACK
  1341 00000466 803C00                  	cmp byte [si], 0             ; is N==0
  1342 00000469 7402                    	je .2
  1343 0000046B 0C40                    	or al, CMD_MF                ; MFM recording
  1344                                  .2:
  1345 0000046D AB                      	stosw                        ; AH=head / unit, AL=format cmd
  1346 0000046E A4                      	movsb                        ; set N
  1347 0000046F AC                      	lodsb                        ; get SC
  1348 00000470 88C1                    	mov cl, al                   ; save SC in AL
  1349 00000472 AA                      	stosb                        ; set SC
  1350 00000473 83C602                  	add si, 2                    ; advance to GPL3
  1351 00000476 A5                      	movsw                        ; set GPL3 and Fill
  1352                                  
  1353 00000477 8D76F6                  	lea si, [bp + fmt_cmd]
  1354 0000047A 07901F905F              	popm es, ds, di              ; restore regs
  1355                                  
  1356 0000047F 30ED                    	xor ch, ch                   ; CX = sector count
  1357 00000481 C1E102                  	shl cx, 2                    ; CX = byte count of param table
  1358                                  
  1359 00000484 53                      	pushm bx                     ; save DTAB pointer
  1360                                  
  1361 00000485 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1362 00000488 8CC3                    	mov bx, es                   ; segment to AX
  1363 0000048A 89DA                    	mov dx, bx                   ; and to DX
  1364 0000048C C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1365 0000048F C1E204                  	shl dx, 4                    ; high part of offset from segment
  1366 00000492 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1367 00000494 83D300                  	adc bx, 0                    ; and carry into the high bits
  1368                                  
  1369 00000497 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1370                                  
  1371                                  	;.marker:
  1372                                  	; BX:AX transfer 20 - bit address in memory
  1373                                  	; CX transfer byte count
  1374                                  	; DX:SI pointer to 9 - byte FDC command
  1375                                  	;
  1376 00000499 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1377                                  
  1378 0000049E E82E02                  	call xfer_format_track       ; format the track
  1379                                  
  1380 000004A1 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1381                                  	;;; jc .exit ; AH is set to error code
  1382                                  
  1383 000004A2 E84703                  	call Check_RW_Status         ; get final return code
  1384                                  
  1385                                  
  1386                                  .exit:
  1387 000004A5 8D66FE                  	lea sp, [rwv_return + bp]    ; restore stack location
  1388 000004A8 C3                      	ret
  1389                                  
  1390                                  
  1391                                  
  1392                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1393                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1394                                  	global dma0_interrupt
  1395                                  dma0_interrupt:
  1396 000004A9 1E5250                  	pushm ax, dx, ds
  1397                                  
  1398 000004AC 6A40                    	push bios_data_seg
  1399 000004AE 1F90                    	popm ds
  1400                                  
  1401                                  	%if SOFT_DEBUG
  1402 000004B0 800E3E0002              	or byte [fdc_drv_calib], 02h ;POST dma interrupt
  1403                                  	%endif
  1404                                  
  1405                                  	%if 0
  1406                                  	mov dx, FDC_TC               ; Terminal Count
  1407                                  	in al, dx                    ; pulse the line
  1408                                  	%endif
  1409                                  
  1410                                  	%if 0
  1411                                  	mov dx, DMA0 + DMACW         ; DMA0 control word
  1412                                  	in ax, dx
  1413                                  	mov [dma0_cw], ax            ; post the resulting CW
  1414                                  	%endif
  1415                                  
  1416                                  	; signal EOI (End of Interrupt)
  1417 000004B5 BA22FF                  	mov dx, PIC_EOI              ; EOI register
  1418 000004B8 B80080                  	mov ax, EOI_NSPEC            ; non - specific
  1419 000004BB EF                      	out dx, ax                   ; signal it
  1420                                  
  1421 000004BC 585A1F90                	popm ax, dx, ds
  1422 000004C0 CF                      	iret
  1423                                  
  1424                                  
  1425                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1426                                  	; Function 15h Get Disk Type
  1427                                  	;
  1428                                  	; Enter with:
  1429                                  	; AH = 15h
  1430                                  	; DL = drive 0 or 1
  1431                                  	;
  1432                                  	; Return with:
  1433                                  	; Carry clear if no error
  1434                                  	; AH = drive type code
  1435                                  	; 0 = no drive present
  1436                                  	; 1 = floppy without change line support
  1437                                  	; 2 = floppy with change line support
  1438                                  	; 3 = fixed disk
  1439                                  	;
  1440                                  	; Carry set on error
  1441                                  	; AH = error code
  1442                                  	;
  1443                                  	; All other registers are preserved.
  1444                                  	;
  1445                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1446                                  fn15:
  1447 000004C1 30E4                    	xor ah, ah                   ; No drive present
  1448 000004C3 E88400                  	call check_DL
  1449 000004C6 7309                    	jnc .ok
  1450 000004C8 83FFFF                  	cmp di, - 1
  1451 000004CB 7503E9B0FB              	je undefined                 ; DL is really bad
  1452 000004D0 C3                      	ret                          ; AH=0, no drive present
  1453                                  	; carry will be cleared
  1454                                  .ok:
  1455 000004D1 FEC4                    	inc ah                       ; drive ok, no change line support
  1456 000004D3 F8                      	clc
  1457 000004D4 E978FB                  	jmp exit_pops                ;
  1458                                  
  1459                                  
  1460                                  
  1461                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1462                                  	; Function 16h Get Disk Change Status
  1463                                  	;
  1464                                  	; Enter with:
  1465                                  	; AH = 16h
  1466                                  	; DL = drive 0 or 1
  1467                                  	;
  1468                                  	; Return with:
  1469                                  	; Carry clear
  1470                                  	; AH = 0 disk not changed
  1471                                  	;
  1472                                  	; Carry set
  1473                                  	; AH = 6 disk has been changed
  1474                                  	; 0 error
  1475                                  	;
  1476                                  	; All other registers are preserved.
  1477                                  	;
  1478                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1479                                  fn16:
  1480 000004D7 E87000                  	call check_DL
  1481 000004DA 7303E9A1FB              	jc undefined
  1482                                  
  1483 000004DF 89F8                    	mov ax, di                   ; AL = 0, 1 AH = 0
  1484                                  	; AH is now 0
  1485 000004E1 FEC0                    	inc al                       ; AL = 1, 2
  1486 000004E3 C0C004                  	rol al, 4                    ; AL = MOEN1 or MOEN2
  1487 000004E6 84063F00                	test [fdc_motor_LDOR], al    ; test if motor running
  1488 000004EA 7502                    	jnz .on
  1489                                  
  1490 000004EC B406                    	mov ah, ERR_disk_removed     ; signal disk changed
  1491                                  .on:
  1492 000004EE C3                      	ret                          ; AH=6, Carry will be set
  1493                                  
  1494                                  
  1495                                  
  1496                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1497                                  	; Function 17h Set Disk Type for Format (PC - AT)
  1498                                  	;
  1499                                  	; Enter with:
  1500                                  	; AH = 17h
  1501                                  	; AL = 00h not used
  1502                                  	; 01h 160, 180, 320, or 360Kb diskette in 360kb drive
  1503                                  	; 02h 360Kb diskette in 1.2Mb drive
  1504                                  	; 03h 1.2Mb diskette in 1.2Mb drive
  1505                                  	; 04h 720Kb diskette in 720Kb drive
  1506                                  	; DL = drive number
  1507                                  	;
  1508                                  	; Return with:
  1509                                  	; AH = 0 success
  1510                                  	; Carry clear
  1511                                  	;
  1512                                  	; Carry set error
  1513                                  	; AH = error code
  1514                                  	;
  1515                                  	; note 1) This function is probably enhanced for the PS / 2 series to detect
  1516                                  	; 1.44 in 1.44 and 720k in 1.44.
  1517                                  	; 2) This function is not supported for floppy disks on the PC or XT.
  1518                                  	; 3) If the change line is active for the specified drive, it is reset.
  1519                                  	; 4) The BIOS sets the data rate for the specified drive and media type.
  1520                                  	; The rate is 250k / sec for double - density media and 500k / sec for high
  1521                                  	; density media. The proper hardware is required.
  1522                                  	; 5) This function is used by DOS <= 3.1
  1523                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1524                                  	;fn17:
  1525                                  	;;; ret
  1526                                  
  1527                                  
  1528                                  
  1529                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1530                                  	; Function 18h Set Media Type For Format (diskette) (AT, XT2, XT / 286, PS / 2)
  1531                                  	;
  1532                                  	; Enter with:
  1533                                  	; AH = 18h
  1534                                  	; CH = max. cylinder number (80 or 40 minus 1)
  1535                                  	; CL = number of sectors (9, 15, 18)
  1536                                  	; DL = drive number
  1537                                  	;
  1538                                  	; Return with:
  1539                                  	; Carry clear - - no errors
  1540                                  	; AH = 00h if requested combination supported
  1541                                  	; ES:DI pointer to 13 - byte parameter table
  1542                                  	;
  1543                                  	; Carry set - - error
  1544                                  	; AH = 01h if function not available
  1545                                  	; 0Ch if not suppported or drive type unknown
  1546                                  	; 80h if there is no media in the drive
  1547                                  	;
  1548                                  	; note 1) A floppy disk must be present in the drive.
  1549                                  	; 2) This function should be called prior to formatting a disk with Int 13h
  1550                                  	; Fn 05h so the BIOS can set the correct data rate for the media.
  1551                                  	; 3) If the change line is active for the specified drive, it is reset.
  1552                                  	; 4) This function is used by DOS >= 3.2
  1553                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1554                                  fn18:
  1555 000004EF E85800                  	call check_DL                ; check validity of drive no.
  1556 000004F2 7303E989FB              	jc undefined
  1557                                  
  1558 000004F7 E86700                  	call get_disk_type           ; get disk type to AL
  1559 000004FA 3C0B                    	cmp al, L_table
  1560 000004FC 7327                    	jnb .alt
  1561 000004FE 88C3                    	mov bl, al
  1562 00000500 30FF                    	xor bh, bh
  1563 00000502 D1E3                    	shl bx, 1
  1564 00000504 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1565 00000509 85DB                    	test bx, bx
  1566 0000050B 743A                    	jz .errC
  1567 0000050D 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1568 00000511 7512                    	jne .alt                     ; try alternate
  1569 00000513 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1570 00000517 750C                    	jne .alt
  1571                                  .found:
  1572 00000519 E86000                  	call set_media_pointer
  1573 0000051C 895E00                  	mov [offset_DI + bp], bx
  1574 0000051F 8C4E12                  	mov [offset_ES + bp], cs     ; return in ES:DI
  1575 00000522 30E4                    	xor ah, ah
  1576 00000524 C3                      	ret
  1577                                  
  1578                                  .alt:
  1579 00000525 E84000                  	call get_disk_alt_type       ; get disk type to AL
  1580 00000528 3C0B                    	cmp al, L_table
  1581 0000052A 731B                    	jnb .errC
  1582 0000052C 88C3                    	mov bl, al
  1583 0000052E 30FF                    	xor bh, bh
  1584 00000530 D1E3                    	shl bx, 1
  1585 00000532 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1586 00000537 85DB                    	test bx, bx
  1587 00000539 740C                    	jz .errC
  1588 0000053B 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1589 0000053F 7506                    	jne .errC                    ; no match?
  1590 00000541 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1591 00000545 74D2                    	je .found
  1592                                  
  1593 00000547 B40C                    .errC: mov ah, ERR_media_type_not_found
  1594 00000549 C3                      	ret
  1595                                  
  1596                                  
  1597                                  
  1598                                  
  1599                                  
  1600                                  	check cpu_xtal - 0FFh
  1601                                  
  1602                                  
  1603                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1604                                  	; check_DL - - check for valid disk #
  1605                                  	;
  1606                                  	; Return:
  1607                                  	; DI = 0 or 1 if DL is valid floppy
  1608                                  	; Carry clear
  1609                                  	;
  1610                                  	; DI not valid if DL is invalid
  1611                                  	; Carry set
  1612                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1613                                  check_DL:
  1614 0000054A BFFFFF                  	mov di, - 1                  ; invalid DI
  1615 0000054D 80FA02                  	cmp dl, FLOPPY_MAX
  1616 00000550 730D                    	jnb .err
  1617 00000552 89D7                    	mov di, dx
  1618 00000554 83E701                  	and di, FLOPPY_MAX - 1       ; clear the carry
  1619 00000557 F685F8000F              	test byte [fdc_type + di], 0Fh ; drive present?
  1620 0000055C 7401                    	jz .err
  1621 0000055E C3                      	ret                          ; carry is clear
  1622                                  
  1623 0000055F F9                      .err: stc
  1624 00000560 C3                      	ret
  1625                                  
  1626                                  
  1627                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1628                                  	; get_disk_type
  1629                                  	;
  1630                                  	; Enter with:
  1631                                  	; DI = drive no.
  1632                                  	;
  1633                                  	; Return with:
  1634                                  	; AL = drive type (0..4)
  1635                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1636                                  get_disk_type:
  1637 00000561 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1638 00000565 240F                    	and al, 0Fh                  ; mask low nibble
  1639 00000567 C3                      	ret
  1640                                  
  1641                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1642                                  	; get_disk_alt_type
  1643                                  	;
  1644                                  	; Enter with:
  1645                                  	; DI = drive no.
  1646                                  	;
  1647                                  	; Return with:
  1648                                  	; AL = drive type (0..4)
  1649                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1650                                  get_disk_alt_type:
  1651 00000568 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1652 0000056C C0E804                  	shr al, 4
  1653 0000056F C3                      	ret
  1654                                  
  1655                                  
  1656                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1657                                  	; get_media
  1658                                  	;
  1659                                  	; Call with:
  1660                                  	; AL = disk type
  1661                                  	;
  1662                                  	; Return with:
  1663                                  	; CS:BX pointer to 13 - byte disk media table
  1664                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1665                                  get_media:
  1666 00000570 88C3                    	mov bl, al
  1667 00000572 30FF                    	xor bh, bh
  1668 00000574 D1E3                    	shl bx, 1
  1669 00000576 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1670 0000057B C3                      	ret
  1671                                  
  1672                                  
  1673                                  
  1674                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1675                                  	; set_media_pointer
  1676                                  	;
  1677                                  	; Call with:
  1678                                  	; CS:BX pointer to 13 - byte disk media table
  1679                                  	; DS BIOS data area pointer
  1680                                  	;
  1681                                  	; Return with:
  1682                                  	; CS:BX pointer to 13 - byte disk media table
  1683                                  	; Int 1Eh floppy media pointer set
  1684                                  	;
  1685                                  	; Carry Set = new media pointer (needed Specify command)
  1686                                  	; Carry Clear = same media pointer (Specify not needed)
  1687                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1688                                  set_media_pointer:
  1689 0000057C 0651                    	pushm cx, es                 ; save for later
  1690 0000057E 6A00                    	push 0                       ; address interrupt vectors
  1691 00000580 07                      	pop es                       ; * *
  1692 00000581 8CC9                    	mov cx, cs
  1693 00000583 26391E7800              	es cmp word [1Eh * 4], bx
  1694 00000588 7508                    	jne .diff
  1695 0000058A 26390E7A00              	es cmp word [1Eh * 4 + 2], cx ; segment
  1696 0000058F F8                      	clc
  1697 00000590 7411                    	jz .same
  1698                                  .diff:
  1699 00000592 26891E7800              	es mov word [1Eh * 4], bx    ; offset
  1700 00000597 26890E7A00              	es mov word [1Eh * 4 + 2], cx ; segment
  1701 0000059C 8EC1                    	mov es, cx
  1702 0000059E 90                      	cnop
  1703 0000059F E80500                  	call Specify                 ; ES:BX is table pointer
  1704 000005A2 F9                      	stc
  1705                                  .same:
  1706 000005A3 590790                  	popm cx, es                  ; restore DS
  1707 000005A6 C3                      	ret
  1708                                  
  1709                                  
  1710                                  
  1711                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1712                                  	; Specify issue specify command to FDC
  1713                                  	;
  1714                                  	; Call with:
  1715                                  	; ES:BX pointer to 13 - byte disk table
  1716                                  	; DS BIOS data area pointer
  1717                                  	;
  1718                                  	; Return with:
  1719                                  	; Nothing
  1720                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1721                                  Specify:
  1722 000005A7 56525350                	pushm ax, bx, dx, si
  1723 000005AB 83EC04                  	sub sp, 4                    ; allocate 4 bytes for command
  1724 000005AE 89E6                    	mov si, sp
  1725                                  
  1726 000005B0 268A470C                	es mov al, [DTAB_control + bx] ; clock bits
  1727 000005B4 C0C002                  	rol al, 2
  1728 000005B7 BA8504                  	mov dx, FDC_LDCR             ; Control Register
  1729 000005BA EE                      	out dx, al
  1730                                  
  1731 000005BB B20C                    	mov dl, 12                   ; 12 usec delay = T time
  1732 000005BD 08C0                    	or al, al                    ; test for hi (00) or lo (80) data rate
  1733 000005BF 7502                    	jnz .3
  1734 000005C1 D0EA                    	shr dl, 1                    ; crystal has factor of 2 already
  1735                                  .3:
  1736 000005C3 A0FF00                  	mov al, [cpu_xtal]           ; 2x clock frequency
  1737 000005C6 F6E2                    	mul dl                       ; AX = 2xClock * T or 2xclock * T / 2 (80 or 00)
  1738 000005C8 83E82C                  	sub ax, 44                   ; overhead CPU clocks
  1739 000005CB B214                    	mov dl, 20                   ; loop clock count
  1740 000005CD F6F2                    	div dl
  1741 000005CF FEC0                    	inc al                       ; for good measure
  1742 000005D1 A2AD00                  	mov [wait12_count], al       ; save count
  1743                                  
  1744 000005D4 36C60403                	ss mov byte [si], CMD_SPECIFY
  1745 000005D8 268B07                  	es mov ax, [DTAB_specify + bx] ; get two specify bytes
  1746 000005DB 36894401                	ss mov word [si + 1], ax
  1747 000005DF 8CD2                    	mov dx, ss
  1748 000005E1 B90300                  	mov cx, 3                    ; length of command = 3
  1749 000005E4 E8F3FB                  	call output_cmd_to_fdc
  1750 000005E7 83C404                  	add sp, 4
  1751 000005EA 585B5A5E                	popm ax, bx, dx, si
  1752 000005EE C3                      	ret
  1753                                  
  1754                                  
  1755                                  
  1756                                  
  1757                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1758                                  	; motor_on Start the drive motor & wait
  1759                                  	;
  1760                                  	; Call with:
  1761                                  	; DI = drive to start (0, 1)
  1762                                  	; CS:BX = drive parameter table pointer
  1763                                  	;
  1764                                  	; Return with:
  1765                                  	; motor is running and startup delay has been taken
  1766                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1767                                  	global motor_on
  1768                                  motor_on:
  1769 000005EF 525150                  	pushm ax, cx, dx
  1770 000005F2 89F8                    	mov ax, di                   ; drive # to AL
  1771 000005F4 0401                    	add al, MOEN1>>4             ; form MOENx >> 4
  1772 000005F6 C0E004                  	shl al, 4                    ; form MOENx bitmask
  1773 000005F9 88C4                    	mov ah, al                   ; MOENx - > AH
  1774 000005FB 01F8                    	add ax, di                   ; MOENx + DSELx - > AL
  1775                                  
  1776 000005FD B1B6                    	mov cl, 182                  ;10 seconds
  1777 000005FF 880E4000                	mov byte [fdc_motor_ticks], cl ; set long timer = 10 seconds
  1778                                  
  1779 00000603 84263F00                	test byte [fdc_motor_LDOR], ah ; motor already on?
  1780 00000607 88C5                    	mov ch, al
  1781 00000609 750F                    	jnz .its_on
  1782                                  
  1783                                  	; motor is not running
  1784 0000060B 2E8B470A                	cs mov ax, [DTAB_startup + bx] ; get startup delay in 1 / 8 seconds
  1785 0000060F 98                      	cbw
  1786 00000610 6BC07D                  	imul ax, 125                 ; * 125 ms
  1787 00000613 B236                    	mov dl, 54
  1788 00000615 F6F2                    	div dl                       ; divided by 54ms / tick
  1789 00000617 40                      	inc ax                       ; one more tick for good measure
  1790 00000618 28C1                    	sub cl, al                   ; CL is tick to wait for
  1791                                  
  1792                                  	; if motor was already running, then CL has not been changed
  1793                                  	; Do the select
  1794                                  .its_on:
  1795 0000061A 322E3F00                	xor ch, [fdc_motor_LDOR]     ; set selected bits
  1796 0000061E 80E531                  	and ch, (MOEN_MASK | DSEL_MASK)
  1797 00000621 302E3F00                	xor [fdc_motor_LDOR], ch
  1798 00000625 E875FC                  	call out_LDOR_mem            ; Motor Starts here, or continues
  1799 00000628 EB01                    	jmp .wait
  1800                                  
  1801 0000062A F4                      	hlt
  1802 0000062B 380E4000                .wait: cmp [fdc_motor_ticks], cl ; has tick counter expired?
  1803 0000062F 77F9                    	ja .wait - 1
  1804                                  
  1805                                  	; reduce timer to turn - off delay time
  1806 00000631 2E8A4F02                	cs mov cl, [DTAB_turnoff_ticks + bx] ; 2 seconds
  1807 00000635 880E4000                	mov [fdc_motor_ticks], cl
  1808                                  
  1809 00000639 58595A                  	popm ax, cx, dx
  1810 0000063C C3                      	ret
  1811                                  
  1812                                  
  1813                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1814                                  	; make_head_unit
  1815                                  	;
  1816                                  	; Enter with:
  1817                                  	; DH = head number
  1818                                  	; DI = unit number
  1819                                  	;
  1820                                  	; Return with:
  1821                                  	; AL = 0000 0huu
  1822                                  	; Carry clear
  1823                                  	;
  1824                                  	; Carry is set on error
  1825                                  	;
  1826                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1827                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1828                                  make_head_unit:
  1829 0000063D 88F0                    	mov al, dh                   ; head number to AL
  1830 0000063F A8FE                    	test al, ~1                  ; check for head 0 or 1
  1831 00000641 F9                      	stc                          ; set to signal error
  1832 00000642 7507                    	jnz .err
  1833 00000644 2401                    	and al, 1                    ; defensive programming
  1834 00000646 C0E002                  	shl al, 2                    ; shift H to position
  1835 00000649 09F8                    	or ax, di                    ; clear the carry
  1836 0000064B C3                      .err: ret
  1837                                  
  1838                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1839                                  	; dma_outd output a double word to a DMA double word register
  1840                                  	;
  1841                                  	; Call with:
  1842                                  	; BX:AX double word to put out
  1843                                  	; DX low port address in the DMA controller
  1844                                  
  1845                                  	; Exit with:
  1846                                  	; DX incremented by 4
  1847                                  	;
  1848                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1849                                  dma_outd:
  1850 0000064C EF                      	out dx, ax
  1851 0000064D 42                      	inc dx
  1852 0000064E 42                      	inc dx
  1853 0000064F 93                      	xchg ax, bx
  1854 00000650 EF                      	out dx, ax
  1855 00000651 42                      	inc dx
  1856 00000652 42                      	inc dx
  1857 00000653 C3                      	ret
  1858                                  
  1859                                  
  1860                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1861                                  	; xfer_read_sector
  1862                                  	;
  1863                                  	; Call with:
  1864                                  	; BX:AX transfer address in memory
  1865                                  	; CX transfer byte count
  1866                                  	; DX:SI pointer to 9 - byte FDC command
  1867                                  	;
  1868                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1869                                  xfer_read_sector:
  1870 00000654 52                      	push dx
  1871                                  
  1872                                  	;;; and byte [fdc_drv_calib], 00h ;POST no interrupts
  1873                                  	; operation is not complete
  1874                                  
  1875                                  	; BX:AX is the transfer destination address
  1876 00000655 BAC4FF                  	mov dx, DMA0 + DMADPL        ; set low destination
  1877 00000658 E8F1FF                  	call dma_outd
  1878                                  
  1879 0000065B 89C8                    	mov ax, cx                   ; total byte count
  1880 0000065D EF                      	out dx, ax                   ; set terminal count
  1881                                  
  1882 0000065E 31DB                    	xor bx, bx
  1883 00000660 B88604                  	mov ax, FDC_DACK
  1884                                  	; BX:AX is the transfer source port
  1885 00000663 BAC0FF                  	mov dx, DMA0 + DMASPL        ; set low source pointer
  1886 00000666 E8E3FF                  	call dma_outd
  1887                                  
  1888 00000669 8B46FC                  	mov ax, [rwv_dma + bp]       ; get Control register
  1889 0000066C BACAFF                  	mov dx, DMA0 + DMACW
  1890 0000066F EF                      	out dx, ax                   ; starts the DMA
  1891                                  
  1892 00000670 5A                      	pop dx                       ; reset DX:SI command pointer
  1893                                  
  1894 00000671 B90900                  	mov cx, 9                    ; 9 - byte FDC command
  1895 00000674 E863FB                  	call output_cmd_to_fdc
  1896                                  
  1897                                  
  1898 00000677 BBC0FF                  	mov bx, DMA0 + DMASPL
  1899 0000067A B98704                  	mov cx, FDC_DACK_TC
  1900                                  
  1901                                  xfer_common_wait:
  1902 0000067D BAC8FF                  	mov dx, DMA0 + DMATC
  1903                                  .loop1:
  1904 00000680 803E400000              	cmp byte [fdc_motor_ticks], 0
  1905                                  	;;; cmp byte [fdc_motor_ticks], 20h ; 2Fh - 0Fh in DTABx entries
  1906 00000685 7625                    	jbe .timeout
  1907                                  
  1908 00000687 E8CAFA                  	call wait12
  1909 0000068A ED                      	in ax, dx
  1910 0000068B 83F80C                  	cmp ax, THRESHHOLD
  1911 0000068E 73F0                    	jae .loop1
  1912                                  
  1913 00000690 E85002                  	call @disable
  1914                                  .loop2:
  1915 00000693 90                      	nop
  1916 00000694 90                      	nop
  1917 00000695 ED                      	in ax, dx
  1918 00000696 83F801                  	cmp ax, 1
  1919 00000699 77F8                    	ja .loop2
  1920                                  
  1921 0000069B 89DA                    	mov dx, bx                   ; Source low
  1922 0000069D 89C8                    	mov ax, cx                   ; FDC_DACK_TC
  1923 0000069F EF                      	out dx, ax
  1924                                  
  1925 000006A0 E85102                  	call @enable
  1926                                  
  1927                                  	;;; mov ax, 100b ; stop the channel
  1928                                  	;;; mov dx, DMA0 + DMACW ; DMA control word
  1929                                  	;;; out dx, ax
  1930                                  
  1931 000006A3 E81100                  	call wait_operation_complete
  1932 000006A6 720E                    	jc .99
  1933                                  
  1934                                  	;;; mov ax, 100b ; stop the channel
  1935                                  	;;; mov dx, DMA0 + DMACW ; DMA control word
  1936                                  	;;; out dx, ax
  1937                                  
  1938 000006A8 30E4                    	Okay
  1939 000006AA EB0A                    	jmp .99
  1940                                  
  1941                                  .timeout:
  1942                                  	;;; call @enable
  1943                                  	; add the following:
  1944 000006AC B80400                  	mov ax, 100b                 ; stop the channel
  1945 000006AF BACAFF                  	mov dx, DMA0 + DMACW         ; DMA control word
  1946 000006B2 EF                      	out dx, ax
  1947                                  
  1948 000006B3 B485                    	mov ah, ERR_85
  1949 000006B5 F9                      	Error
  1950 000006B6 C3                      .99: ret
  1951                                  
  1952                                  
  1953                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1954                                  	; wait_operation_complete ; wait for disk operation
  1955                                  	; ; to post a "complete" status
  1956                                  	; Call with:
  1957                                  	; DS = BIOS data area segment
  1958                                  	;
  1959                                  	; Return with:
  1960                                  	; CY = 0 success
  1961                                  	; CY = 1 timed out, AH=error code
  1962                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1963                                  wait_operation_complete:
  1964 000006B7 F6063E0001              .1: test byte [fdc_drv_calib], 01h ; FDC interrupt posted "complete"?
  1965 000006BC 7509                    	jnz .okay
  1966 000006BE 803E400000              	cmp byte [fdc_motor_ticks], 0
  1967 000006C3 75F2                    	jne .1
  1968 000006C5 EB04                    	jmp .timeout
  1969                                  
  1970 000006C7 30E4                    .okay: Okay
  1971 000006C9 EB03                    	jmp .99
  1972                                  
  1973                                  .timeout:
  1974 000006CB B488                    	mov ah, ERR_88               ; mark timeout
  1975 000006CD F9                      	Error
  1976 000006CE C3                      .99: ret
  1977                                  
  1978                                  
  1979                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1980                                  	; xfer_write_sector
  1981                                  	; xfer_format_track (only command count is different)
  1982                                  	;
  1983                                  	; Call with:
  1984                                  	; BX:AX transfer address in memory
  1985                                  	; CX transfer byte count
  1986                                  	; DX:SI pointer to 9 - byte FDC command
  1987                                  	;
  1988                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1989                                  xfer_format_track:
  1990                                  xfer_write_sector:
  1991 000006CF 52                      	push dx
  1992                                  
  1993                                  	; BX:AX is the transfer source address
  1994 000006D0 BAC0FF                  	mov dx, DMA0 + DMASPL        ; set low source address
  1995 000006D3 E876FF                  	call dma_outd
  1996                                  
  1997 000006D6 31DB                    	xor bx, bx
  1998 000006D8 B88604                  	mov ax, FDC_DACK
  1999                                  
  2000                                  	; BX:AX is the transfer destination port
  2001 000006DB BAC4FF                  	mov dx, DMA0 + DMADPL        ; set low destination port
  2002 000006DE E86BFF                  	call dma_outd
  2003                                  
  2004 000006E1 89C8                    	mov ax, cx                   ; total byte count
  2005 000006E3 EF                      	out dx, ax                   ; set terminal count
  2006                                  
  2007 000006E4 8B46FC                  	mov ax, [rwv_dma + bp]       ; get Control register
  2008 000006E7 BACAFF                  	mov dx, DMA0 + DMACW
  2009 000006EA EF                      	out dx, ax                   ; starts the DMA
  2010                                  
  2011 000006EB 5A                      	pop dx                       ; reset DX:SI command pointer
  2012                                  
  2013 000006EC B90900                  	mov cx, 9                    ; 9 - byte FDC command
  2014 000006EF 36F60408                	ss test byte [si], 01000b    ; test for FORMAT command
  2015 000006F3 7403                    	jz .4
  2016 000006F5 B90600                  	mov cx, 6                    ; it is FORMAT
  2017                                  .4:
  2018 000006F8 E8DFFA                  	call output_cmd_to_fdc
  2019                                  
  2020                                  
  2021 000006FB BBC4FF                  	mov bx, DMA0 + DMADPL        ; Destination to be updated
  2022 000006FE B98704                  	mov cx, FDC_DACK_TC
  2023                                  
  2024 00000701 E979FF                  	jmp xfer_common_wait
  2025                                  
  2026                                  
  2027                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2028                                  	; xfer_verify_sector
  2029                                  	;
  2030                                  	; Call with:
  2031                                  	; BX:AX transfer address in memory
  2032                                  	; CX transfer byte count
  2033                                  	; DX:SI pointer to 9 - byte FDC command
  2034                                  	;
  2035                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2036                                  xfer_verify_sector:
  2037 00000704 52                      	push dx
  2038                                  
  2039 00000705 31DB                    	xor bx, bx                   ; BX:AX is transfer address
  2040 00000707 B84204                  	mov ax, (bios_data_seg<<4) + fdc_ctrl_status
  2041                                  
  2042                                  	; BX:AX is the transfer destination address
  2043 0000070A BAC4FF                  	mov dx, DMA0 + DMADPL        ; set low destination
  2044 0000070D E83CFF                  	call dma_outd
  2045                                  
  2046 00000710 89C8                    	mov ax, cx                   ; total byte count
  2047 00000712 EF                      	out dx, ax                   ; set terminal count
  2048                                  
  2049 00000713 31DB                    	xor bx, bx
  2050 00000715 B88604                  	mov ax, FDC_DACK
  2051                                  	; BX:AX is the transfer source port
  2052 00000718 BAC0FF                  	mov dx, DMA0 + DMASPL        ; set low source pointer
  2053 0000071B E82EFF                  	call dma_outd
  2054                                  
  2055 0000071E 8B46FC                  	mov ax, [rwv_dma + bp]       ; get Control register
  2056 00000721 BACAFF                  	mov dx, DMA0 + DMACW
  2057 00000724 EF                      	out dx, ax                   ; starts the DMA
  2058                                  
  2059 00000725 5A                      	pop dx                       ; reset DX:SI command pointer
  2060                                  
  2061 00000726 B90900                  	mov cx, 9                    ; 9 - byte FDC command
  2062 00000729 E8AEFA                  	call output_cmd_to_fdc
  2063                                  
  2064                                  
  2065 0000072C BBC0FF                  	mov bx, DMA0 + DMASPL
  2066 0000072F B98704                  	mov cx, FDC_DACK_TC
  2067                                  
  2068 00000732 E948FF                  	jmp xfer_common_wait
  2069                                  
  2070                                  
  2071                                  
  2072                                  
  2073                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2074                                  	; recalibrate
  2075                                  	;
  2076                                  	; Enter with:
  2077                                  	; DI = drive number
  2078                                  	; CS:BX = parameter area pointer
  2079                                  	; DS = BIOS data area pointer
  2080                                  	;
  2081                                  	; Return with:
  2082                                  	; Carry = 0 - - okay
  2083                                  	;
  2084                                  	; Carry = 1 - - error
  2085                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2086                                  recalibrate:
  2087 00000735 565251                  	pushm cx, dx, si
  2088                                  
  2089                                  	;;; call motor_on
  2090                                  
  2091 00000738 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts
  2092                                  
  2093 0000073D B001                    	mov al, ST0_US               ; mask to 2 drives
  2094 0000073F 21F8                    	and ax, di                   ; unit number to AL
  2095 00000741 86C4                    	xchg al, ah                  ; AH is second byte of command
  2096 00000743 B007                    	mov al, CMD_RECALIBRATE
  2097 00000745 50                      	push ax                      ; push 2 byte command
  2098 00000746 89E6                    	mov si, sp                   ; form command pointer
  2099 00000748 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2100 0000074A B90200                  	mov cx, 2
  2101 0000074D E88AFA                  	call output_cmd_to_fdc       ; output the command
  2102 00000750 7231                    	jc .7
  2103                                  
  2104 00000752 E862FF                  	call wait_operation_complete
  2105 00000755 722C                    	jc .7
  2106                                  
  2107 00000757 E84BFB                  	call fdc_wait_seek_done
  2108 0000075A 7227                    	jc .7
  2109                                  
  2110 0000075C 58                      	pop ax                       ; get unit # to AH
  2111 0000075D B004                    	mov al, CMD_SENSE_DRIVE_STATUS
  2112 0000075F 50                      	push ax                      ; push 2 byte command again
  2113 00000760 B90200                  	mov cx, 2
  2114 00000763 89E6                    	mov si, sp
  2115 00000765 8CD2                    	mov dx, ss                   ; DX:SI points at the 2 byte command
  2116 00000767 E870FA                  	call output_cmd_to_fdc
  2117 0000076A 7217                    	jc .7
  2118                                  
  2119 0000076C E85BFA                  	call input_byte_from_fdc     ; get ST3
  2120 0000076F 7212                    	jc .7
  2121 00000771 88859000                	mov [fdc_disk_state + di], al ; save ST3 for drive
  2122 00000775 B487                    	mov ah, ERR_87               ; not on track 0
  2123 00000777 A810                    	test al, ST3_TR00
  2124 00000779 F9                      	Error                        ; signal error
  2125 0000077A 7407                    	jz .7                        ; Not on Track 00, C=1 error
  2126                                  
  2127 0000077C C685940000              	mov byte [fdc_cylinder + di], 0 ; set present cylinder
  2128                                  
  2129                                  	%if SOFT_DEBUG > 1
  2130                                  	push - 1
  2131                                  	call lites
  2132                                  	%endif
  2133 00000781 30E4                    	Okay                         ;
  2134                                  
  2135 00000783 5E                      .7: pop si                    ; Command is still in the stack
  2136 00000784 595A5E                  	popm cx, dx, si              ; restore
  2137 00000787 C3                      	ret
  2138                                  
  2139                                  
  2140                                  
  2141                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2142                                  	; Seek seek to proper cylinder
  2143                                  	;
  2144                                  	; Call with:
  2145                                  	; CH = cylinder to which to position heads
  2146                                  	; CS:BX = disk parameter area
  2147                                  	; DI = unit number
  2148                                  	; DS = BIOS data area pointer
  2149                                  	;
  2150                                  	; Return with:
  2151                                  	; Carry = 0 success
  2152                                  	;
  2153                                  	; Carry = 1 error
  2154                                  	;
  2155                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2156                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2157                                  Seek:
  2158 00000788 565251                  	pushm cx, dx, si
  2159                                  
  2160                                  	; check for a recalibration needed
  2161 0000078B 8A859400                	mov al, [fdc_cylinder + di]  ; get present cylinder (0FFh forces recalibrate)
  2162 0000078F 2E3A470B                	cs cmp al, [DTAB_max_cylinder + bx] ; compare to maximum
  2163 00000793 760E                    	jbe .no_recal
  2164                                  
  2165 00000795 BE0200                  	mov si, 2                    ; two recalibrates max.
  2166                                  .rerecal:
  2167 00000798 E89AFF                  	call recalibrate
  2168 0000079B 7306                    	jnc .no_recal
  2169 0000079D 4E                      	dec si
  2170 0000079E F9                      	Error
  2171 0000079F 7442                    	jz .exit                     ; two have failed
  2172 000007A1 EBF5                    	jmp .rerecal                 ; try again
  2173                                  
  2174                                  .no_recal:
  2175 000007A3 3AAD9400                	cmp ch, [fdc_cylinder + di]  ; sought : present cylinder
  2176 000007A7 7438                    	je .okay
  2177                                  
  2178                                  	; we are not on the cylinder we want
  2179                                  
  2180 000007A9 2E3A6F0B                	cs cmp ch, [DTAB_max_cylinder + bx] ; validate cylinder number
  2181 000007AD 7738                    	ja .invalid
  2182                                  
  2183                                  .valid:
  2184 000007AF 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts
  2185                                  
  2186 000007B4 86CD                    	xchg cl, ch                  ; cylinder to CL
  2187 000007B6 51                      	push cx                      ; CL = sought cylinder
  2188 000007B7 E883FE                  	call make_head_unit
  2189 000007BA B40F                    	mov ah, CMD_SEEK             ; command byte
  2190 000007BC 86C4                    	xchg al, ah                  ; command byte must be first in stack
  2191 000007BE 50                      	push ax                      ; push 3 byte command
  2192 000007BF 89E6                    	mov si, sp
  2193 000007C1 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2194 000007C3 B90300                  	mov cx, 3                    ; 3 byte command
  2195 000007C6 E811FA                  	call output_cmd_to_fdc
  2196 000007C9 5E59                    	popm si, cx                  ; fix stack; get CL=seek to cylinder
  2197 000007CB 86CD                    	xchg cl, ch                  ; CH=seek to cylinder
  2198 000007CD 7214                    	jc .exit
  2199                                  
  2200 000007CF E8E5FE                  	call wait_operation_complete
  2201 000007D2 720F                    	jc .exit
  2202                                  
  2203                                  	;;; mov [fdc_cylinder + di], ch ; set new cylinder number
  2204                                  
  2205 000007D4 E8CEFA                  	call fdc_wait_seek_done      ; AH=error code if C=1
  2206 000007D7 720A                    	jc .exit
  2207                                  
  2208                                  	%if 0
  2209                                  	; probably have to skip the following during Format
  2210                                  	call read_track_id           ; just to be sure
  2211                                  	jc .exit
  2212                                  	%endif
  2213                                  
  2214 000007D9 B440                    	mov ah, ERR_seek_failed
  2215 000007DB 3AAD9400                	cmp ch, [fdc_cylinder + di]  ; PCN filled in
  2216 000007DF 7508                    	jne .err
  2217                                  	;;; mov ah, ERR_8A
  2218                                  	;;; cmp ch, [fdc_ctrl_status + 3] ; read cylinder number
  2219                                  	;;; jne .err
  2220                                  
  2221                                  
  2222                                  .okay:
  2223 000007E1 30E4                    	Okay
  2224                                  .exit:
  2225 000007E3 595A5E                  	popm cx, dx, si
  2226 000007E6 C3                      	ret
  2227                                  
  2228                                  .invalid:
  2229                                  	; error - - the cylinder requested is invalid for this drive
  2230 000007E7 B486                    	mov ah, ERR_86
  2231 000007E9 F9                      .err: Error
  2232 000007EA EBF7                    	jmp .exit                    ; jump WAY out
  2233                                  
  2234                                  
  2235                                  
  2236                                  
  2237                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2238                                  	; Check_RW_Status check ST0 & ST1 error bits
  2239                                  	;
  2240                                  	; Call with:
  2241                                  	; CY = 0, 1 needs to be examined
  2242                                  	;
  2243                                  	; Return with:
  2244                                  	; CY = 0, AH = 0 no error detected
  2245                                  	;
  2246                                  	; CY = 1, AH = final error code error in status bits
  2247                                  	;
  2248                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2249                                  	global Check_RW_Status
  2250                                  Check_RW_Status:
  2251 000007EC 061E56525153            	pushm bx, cx, dx, si, ds, es
  2252                                  
  2253                                  	%if SOFT_DEBUG & DUMP
  2254 000007F2 86C4                    	xchg al, ah                  ; error code to AL
  2255 000007F4 9F                      	lahf                         ; flags to AH
  2256 000007F5 50                      	push ax
  2257                                  
  2258 000007F6 30E4                    	xor ah, ah                   ; zero hi - byte
  2259 000007F8 B90700                  	mov cx, 7
  2260 000007FB BE4800                  	mov si, fdc_ctrl_status + 6  ; byte to start
  2261 000007FE FD                      	.1 std
  2262 000007FF AC                      	lodsb
  2263 00000800 50                      	push ax                      ; push argument
  2264 00000801 E2FB                    	loop .1
  2265 00000803 FC                      	cld
  2266 00000804 0E                      	push cs
  2267 00000805 68[5508]                	push fcrw
  2268 00000808 E8(0000)                	call _cprintf
  2269 0000080B 83C412                  	add sp, 18
  2270                                  
  2271 0000080E 58                      	pop ax
  2272 0000080F 9E                      	sahf                         ; restore flags
  2273 00000810 86C4                    	xchg al, ah                  ; restore error code to AH
  2274                                  	%endif
  2275                                  
  2276                                  	%if 1
  2277 00000812 7309                    	jnc .no_err
  2278                                  
  2279 00000814 C6460E00                	mov byte [offset_AL + bp], 0 ; say nothing transferred
  2280                                  
  2281                                  	; Carry is set, what happened?
  2282 00000818 80FC81                  	cmp ah, ERR_81               ; first of our new error codes
  2283                                  	;;;
  2284 0000081B EB2E                    	jmp .error                   ; for now
  2285                                  	%endif
  2286                                  
  2287                                  
  2288                                  .no_err:
  2289 0000081D 8A264200                	mov ah, [fdc_ctrl_status]    ; get ST0 to AH
  2290 00000821 88E0                    	mov al, ah                   ; retain copy in AL
  2291 00000823 80E4C0                  	and ah, ST0_IC               ; check interrupt code
  2292 00000826 7424                    	jz .exit                     ; Okay is set
  2293                                  
  2294 00000828 B420                    	mov ah, ERR_controller_failure
  2295 0000082A A810                    	test al, ST0_EC
  2296 0000082C 751D                    	jnz .error
  2297                                  
  2298 0000082E A04300                  	mov al, [fdc_ctrl_status + 1] ; get ST1 to AL
  2299 00000831 B402                    	mov ah, ERR_address_mark_not_found
  2300 00000833 A801                    	test al, ST1_MA              ; test Missing Address mark
  2301 00000835 7514                    	jnz .error
  2302                                  
  2303 00000837 FEC4                    	inc ah                       ; Write Protect
  2304 00000839 A802                    	test al, ST1_NW              ;
  2305 0000083B 750E                    	jnz .error
  2306                                  
  2307 0000083D FEC4                    	inc ah                       ; Sector not Found
  2308 0000083F A804                    	test al, ST1_ND              ; No Data
  2309 00000841 7508                    	jnz .error
  2310                                  
  2311 00000843 B410                    	mov ah, ERR_uncorrectable_CRC_error
  2312 00000845 A820                    	test al, ST1_DE
  2313 00000847 7502                    	jnz .error
  2314                                  
  2315 00000849 B48F                    	mov ah, ERR_unknown          ; may be in ST2
  2316                                  
  2317 0000084B F9                      .error: Error                 ; code is in AH
  2318                                  .exit:
  2319 0000084C 5B595A5E1F900790        	popm bx, cx, dx, si, ds, es
  2320 00000854 C3                      	ret
  2321                                  
  2322                                  
  2323                                  	%if SOFT_DEBUG & DUMP
  2324 00000855 0A5354302025303278-     	fcrw db NL, "ST0 %02x ST1 %02x ST2 %02x C + %02x H + %02x S + %02x N %x", 0
  2324 0000085E 205354312025303278-
  2324 00000867 205354322025303278-
  2324 00000870 2043202B2025303278-
  2324 00000879 2048202B2025303278-
  2324 00000882 2053202B2025303278-
  2324 0000088B 204E20257800       
  2325 00000891 0A4158202530347820-     rwvc db NL, "AX %04x CHS %02x:%02x:%02x DL %02x ES:BX %04x:%04x", 0
  2325 0000089A 43485320253032783A-
  2325 000008A3 253032783A25303278-
  2325 000008AC 20444C202530327820-
  2325 000008B5 45533A425820253034-
  2325 000008BE 783A2530347800     
  2326 000008C5 0A4148202530327820-     	fnret db NL, "AH %02x CY %d CMD %02x %02x", NL, 0
  2326 000008CE 435920256420434D44-
  2326 000008D7 202530327820253032-
  2326 000008E0 780A00             
  2327                                  	%endif
  2328                                  
  2329                                  
  2330                                  
  2331                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2332                                  	; @enable / @disable Interrupt enable / disable
  2333                                  	;
  2334                                  	; On a @disable, increment the lock counter and CLI
  2335                                  	; On an @enable, decrement the lock counter and if it goes to zero, STI
  2336                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2337                                  	global @enable, @disable
  2338                                  @disable:
  2339 000008E3 1E50                    	pushm ax, ds
  2340 000008E5 9F                      	lahf                         ; save user flags
  2341 000008E6 6A40                    	push bios_data_seg           ; universal addressing
  2342 000008E8 1F90                    	popm ds
  2343 000008EA FA                      	cli                          ; guarantee locked operation
  2344 000008EB FE06AE00                	inc byte [lock_count]
  2345 000008EF 9E                      	sahf                         ; restore user flags
  2346 000008F0 581F90                  	popm ax, ds
  2347 000008F3 C3                      	ret
  2348                                  
  2349                                  @enable:
  2350 000008F4 1E50                    	pushm ax, ds
  2351 000008F6 9F                      	lahf                         ; save user flags
  2352 000008F7 6A40                    	push bios_data_seg
  2353 000008F9 1F90                    	popm ds
  2354 000008FB FE0EAE00                	dec byte [lock_count]        ; test the lock count
  2355 000008FF 7501                    	jnz .5
  2356 00000901 FB                      	sti                          ; lock count went to zero, re - enable
  2357                                  .5:
  2358 00000902 9E                      	sahf                         ; restore user flags
  2359 00000903 581F90                  	popm ax, ds
  2360 00000906 C3                      	ret
  2361                                  
  2362                                  
  2363                                  
  2364                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2365                                  	; read_track_id ; read address mark information
  2366                                  	;
  2367                                  	; Call with:
  2368                                  	; DS = BIOS data segment
  2369                                  	; DI = unit number
  2370                                  	; DH = head number
  2371                                  	;
  2372                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2373                                  read_track_id:
  2374 00000907 525156                  	pushm si, cx, dx
  2375                                  
  2376 0000090A C6063E0000              	mov byte [fdc_drv_calib], 0  ; clear interrupt flags
  2377                                  
  2378 0000090F E82BFD                  	call make_head_unit          ; head / un
  2379 00000912 88C4                    	mov ah, al                   ; move to AH (second byte of command)
  2380 00000914 B04A                    	mov al, CMD_READ_ID | CMD_MF
  2381 00000916 50                      	push ax                      ; push the 2 - byte command
  2382 00000917 89E6                    	mov si, sp
  2383 00000919 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2384 0000091B B90200                  	mov cx, 2                    ; 2 bytes to READ_ID
  2385 0000091E E8B9F8                  	call output_cmd_to_fdc       ; issue the command
  2386 00000921 58                      	pop ax                       ; discard word in stack
  2387                                  
  2388 00000922 E892FD                  	call wait_operation_complete
  2389                                  
  2390 00000925 5E595A                  	popm si, cx, dx
  2391 00000928 C3                      	ret
