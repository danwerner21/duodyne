     1                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  	; floppy.asm - - WD37C65B floppy disk controller driver
     3                                  	; Version 2.0 - - Apr 2013, JRC
     4                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  	;
     6                                  	; This version is for assembly by NASM 0.98.39 or later
     7                                  	;
     8                                  	; Copyright (C) 2010 - 2013 John R. Coffman. All rights reserved.
     9                                  	; Provided for hobbyist use on the N8VEM SBC - 188 board.
    10                                  	;
    11                                  	; This program is free software: you can redistribute it and / or modify
    12                                  	; it under the terms of the GNU General Public License as published by
    13                                  	; the Free Software Foundation, either version 3 of the License, or
    14                                  	; (at your option) any later version.
    15                                  	;
    16                                  	; This program is distributed in the hope that it will be useful,
    17                                  	; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    19                                  	; GNU General Public License for more details.
    20                                  	;
    21                                  	; You should have received a copy of the GNU General Public License
    22                                  	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
    23                                  	;
    24                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  	%include "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    51                              <1> ;UART_RATE	equ	0		; 1200
    52                              <1> ;UART_RATE	equ	1		; 2400
    53                              <1> ;UART_RATE	equ	2		; 4800
    54                              <1> UART_RATE	equ	3		; 9600
    55                              <1> ;UART_RATE	equ	4		; 19200
    56                              <1> ;UART_RATE	equ	5		; 38400
    57                              <1> ;UART_RATE	equ	6		; 57600
    58                              <1> ;UART_RATE	equ	7		; 115200
    59                              <1> 
    60                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    61                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    62                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    63                              <1> 						; but not ANSI
    64                              <1> ; Define the size of the ROM image on the system in Kilobytes
    65                              <1> ; It may be smaller than the actual EPROM in use.
    66                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    67                              <1> %ifndef ROM
    68                              <1> ROM             equ     32              ; 64 is the default
    69                              <1> %endif
    70                              <1> 
    71                              <1> ; Define the number of Wait States at which the ROM operates
    72                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    73                              <1> 
    74                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    75                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    76                              <1> RAM_DOS         equ     640
    77                              <1> 
    78                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    79                              <1> ; the default is 512 kilobytes
    80                              <1> RAM             equ     512             ; (512 is the default)
    81                              <1> 
    82                              <1> ; Define the number of Wait States at which the RAM operates
    83                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    84                              <1> 
    85                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    86                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    87                              <1> 
    88                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    89                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    90                              <1> 
    91                              <1> ; Define the time zone in which we build the Relocatable BIOS
    92                              <1> %ifndef TIMEZONE
    93                              <1> %define TIMEZONE "CST"
    94                              <1> %endif
    95                              <1> 
    96                              <1> ; Has the REDBUG debugger been loaded?
    97                              <1> %ifndef SOFT_DEBUG
    98                              <1> %define SOFT_DEBUG 0
    99                              <1> %endif
   100                              <1> 
   101                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   102                              <1> %ifndef TBASIC
   103                              <1> TBASIC          equ     1		; default is 1
   104                              <1> %endif
   105                              <1> 
   106                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   107                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   108                              <1> %ifndef FPEM
   109                              <1> FPEM            equ     1               ; default is 1
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   113                              <1> ; or at locations 0280h..3FFh in low memory?
   114                              <1> %if SOFT_DEBUG
   115                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   116                              <1> %else
   117                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   118                              <1> %endif
   119                              <1> 
   120                              <1> ; Define the size of the EPROM that is to be installed on the system
   121                              <1> ; It may be larger than the actual ROM image to be generated.
   122                              <1> %ifndef CHIP
   123                              <1> CHIP            equ     64
   124                              <1> %endif
   125                              <1> 
   126                              <1> ; Define the UART oscillator speed
   127                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   128                              <1> 
   129                              <1> 
   130                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   131                              <1> ; end of the User configuration
   132                              <1> ;       Do Not modify anything below this point
   133                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   134                              <1> 
   135                              <1> ; Define existence of any uart chip
   136                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   137                              <1> startuplength   equ     512                     ; may be up to 1024
   138                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   139                              <1> highrom         equ     (ROM*400h)&0FFFFh
   140                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   141                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   142                              <1> 
   143                              <1> 
   144                              <1> %define ARG(n) [bp+2+(n)*2]
   145                              <1> 
   146                              <1> %macro  check   1.nolist
   147                              <1>  %if (%1)
   148                              <1>    %error Check Failure: %1
   149                              <1>  %endif
   150                              <1> %endm
   151                              <1> %macro  range   3.nolist
   152                              <1>  %if (%1)<(%2)
   153                              <1>    %error Out of Range: %1
   154                              <1>  %elif (%1)>(%3)
   155                              <1>    %error Out of Range: %1
   156                              <1>  %endif
   157                              <1> %endm
   158                              <1> _terminal equ UART
   159                              <1>  check   RAM_DOS&15
   160                              <1>  check   RAM&(RAM-1)
   161                              <1>  check   ROM&(ROM-1)
   162                              <1>  range   RAM,32,512
   163                              <1>  range   ROM,32,256
   164                              <1>  range   RAM_WS,0,3
   165                              <1>  range   ROM_WS,0,3
   166                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   167                              <1>  range   LCL_IO_WS,0,3
   168                              <1>  range   BUS_IO_WS,0,3
   169                              <1>  range   UART_OSC,500000,16000000
   170                              <1>  range   UART_RATE,0,7
   171                              <1>  range	 UART,0,1
   172                              <1>  range	 _terminal,1,2
   173                              <1> 
   174                              <1> %ifndef SOFT_DEBUG
   175                              <1> %define SOFT_DEBUG 0
   176                              <1> %endif
   177                              <1> 
   178                              <1> %ifndef TRACE
   179                              <1> %define TRACE 0
   180                              <1> %endif
   181                              <1> 
   182                              <1> %ifdef MAKE_OBJECT_FILE
   183                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   184                              <1>         export _ROMsize
   185                              <1>         export _CHIPsize
   186                              <1> _ROMsize        dw      ROM
   187                              <1> _CHIPsize       dw      CHIP
   188                              <1> %endif
   189                              <1> ; end of the Hardware configuration file
   190                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   191                              <1> ;*/
    26                                  	%include "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ; Updated for the Duodyne 80c188 SBC
    50                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    51                              <1> %include	"macros.inc"
    52                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <2> ; MACROS.INC  
    54                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <2> ;
    56                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    57                              <2> ;
    58                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    59                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    60                              <2> ;
    61                              <2> ; This program is free software: you can redistribute it and/or modify
    62                              <2> ; it under the terms of the GNU General Public License as published by
    63                              <2> ; the Free Software Foundation, either version 3 of the License, or
    64                              <2> ; (at your option) any later version.
    65                              <2> ;
    66                              <2> ; This program is distributed in the hope that it will be useful,
    67                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    68                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    69                              <2> ; GNU General Public License for more details.
    70                              <2> ;
    71                              <2> ; You should have received a copy of the GNU General Public License
    72                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    73                              <2> ;
    74                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                              <2> 
    76                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    77                              <2> ;
    78                              <2> ;
    79                              <2> %ifndef __MACROS_DEFINED_
    80                              <2> %define __MACROS_DEFINED_ 1
    81                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                              <2> ;
    83                              <2> ; some useful macros:
    84                              <2> ;
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> 	cpu	186
    88                              <2> 
    89                              <2> %imacro setloc  1.nolist
    90                              <2>  times   (%1-($-$$)) db 0FFh
    91                              <2> %endm
    92                              <2> 
    93                              <2> %imacro db_lo   1
    94                              <2>  db (%1)&255
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro cnop    0.nolist
    98                              <2> %if SOFT_DEBUG
    99                              <2>         nop
   100                              <2> %endif
   101                              <2> %endm
   102                              <2> 
   103                              <2> %imacro popm 1-*.nolist
   104                              <2> %rep %0
   105                              <2> %ifidni %1,ALL
   106                              <2>  popa
   107                              <2> %elifidni %1,F
   108                              <2>  popf
   109                              <2> %else
   110                              <2>  pop %1
   111                              <2> %ifidni %1,DS
   112                              <2>  cnop
   113                              <2> %elifidni %1,ES
   114                              <2>  cnop
   115                              <2> %endif
   116                              <2> %endif
   117                              <2> %rotate 1
   118                              <2> %endrep
   119                              <2> %endm
   120                              <2> 
   121                              <2> %imacro pushm 1-*.nolist
   122                              <2> %rep %0
   123                              <2> %rotate -1
   124                              <2> %ifidni %1,ALL
   125                              <2>  pusha
   126                              <2> %elifidni %1,F
   127                              <2>  pushf
   128                              <2> %else
   129                              <2>  push %1
   130                              <2> %endif
   131                              <2> %endrep
   132                              <2> %endm
   133                              <2> 
   134                              <2> ;
   135                              <2> ; added from the 386EX project
   136                              <2> ;
   137                              <2> 
   138                              <2> ; call arguments
   139                              <2> %define ARG(n) [bp+2+(n)*2]
   140                              <2> 
   141                              <2> ;
   142                              <2> ; format of the BYTE initialization table:  address, byte
   143                              <2> ;
   144                              <2> %imacro  binit 2
   145                              <2>         dw      %1
   146                              <2>         db      %2
   147                              <2> %endmacro
   148                              <2> ; end with DW -1
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the WORD initialization table:  address, word
   152                              <2> ;
   153                              <2> %imacro  winit 2
   154                              <2>         dw      %1
   155                              <2>         dw      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> 
   160                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   161                              <2> %imacro get_bda	1.nolist
   162                              <2> 	push	0x0040
   163                              <2> 	pop	%1
   164                              <2> 	cnop
   165                              <2> %endm
   166                              <2> 
   167                              <2> 
   168                              <2> %endif
    52                              <1> 
    53                              <1> 	cpu     186
    54                              <1> ;
    55                              <1> ;
    56                              <1> ; IBM model byte -- must be less than a 286
    57                              <1> ;
    58                              <1> 
    59                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    60                              <1> SUBMODEL_BYTE		equ	00h	;  "
    61                              <1> 
    62                              <1> 
    63                              <1> ; 80188 peripheral control register block address
    64                              <1> CPU_CSCR	        equ	0FF00h
    65                              <1> 
    66                              <1> ; Compatible Mode registers
    67                              <1> 
    68                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    69                              <1> 
    70                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    71                              <1> 
    72                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    73                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    74                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    75                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    76                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    77                              <1> 
    78                              <1> ; Enhanced Mode registers
    79                              <1> 
    80                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    81                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    82                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    83                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    84                              <1> 
    85                              <1> 
    86                              <1> ; On-board internal peripheral equates
    87                              <1> ; Programmable Interrupt Controller
    88                              <1> PIC	        equ	CPU_CSCR+020H
    89                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    90                              <1> PIC_POLLR	equ	PIC+4
    91                              <1> PIC_POLLSR	equ	PIC+6
    92                              <1> PIC_IMASK	equ	PIC+8
    93                              <1> PIC_PMREG	equ	PIC+0AH
    94                              <1> PIC_SRVR	equ	PIC+0CH
    95                              <1> PIC_IRQR	equ	PIC+0EH
    96                              <1> PIC_IRQSR	equ	PIC+10H
    97                              <1> PIC_TCR	        equ	PIC+12H
    98                              <1> PIC_DMA0CR	equ	PIC+14H
    99                              <1> PIC_DMA1CR	equ	PIC+16H
   100                              <1> PIC_I0CON	equ	PIC+18H
   101                              <1> PIC_I1CON	equ	PIC+1AH
   102                              <1> PIC_I2CON	equ	PIC+1CH
   103                              <1> PIC_I3CON	equ	PIC+1EH
   104                              <1> 
   105                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   106                              <1> 
   107                              <1> ; Interrupt masks (Master Mode)
   108                              <1> ;
   109                              <1> mask_timer_all          equ     0001h
   110                              <1> mask_dma0               equ     0004h
   111                              <1> mask_dma1               equ     0008h
   112                              <1> mask_int0               equ     0010h
   113                              <1> mask_int1               equ     0020h
   114                              <1> mask_int2               equ     0040h
   115                              <1> mask_int3               equ     0080h
   116                              <1> 
   117                              <1> 
   118                              <1> 
   119                              <1> ; Timers
   120                              <1> TIM0	        equ	CPU_CSCR+050H
   121                              <1> TIM1	        equ	CPU_CSCR+058H
   122                              <1> TIM2	        equ	CPU_CSCR+060H
   123                              <1> 
   124                              <1> TCNT	        equ	0	; count register
   125                              <1> CMPA	        equ	2	; max count A
   126                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   127                              <1> TCON	        equ	6	; mode/control word
   128                              <1> 
   129                              <1> ; Timer control bits:
   130                              <1> tc_EN           equ     8000h   ; Enable bit
   131                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   132                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   133                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   134                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   135                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   136                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   137                              <1> tc_EXT          equ     0004h   ; External clock
   138                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   139                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   140                              <1> 
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> ; DMA
   145                              <1> DMA0	        equ	CPU_CSCR+0C0H
   146                              <1> DMA1	        equ	CPU_CSCR+0D0H
   147                              <1> DMASPL	        equ	0	; source pointer low
   148                              <1> DMASPU	        equ	2	; source pointer high
   149                              <1> DMADPL	        equ	4	; destination pointer low
   150                              <1> DMADPU	        equ	6	; destination pointer high
   151                              <1> DMATC	        equ	8	; terminal count
   152                              <1> DMACW	        equ	0AH	; control word
   153                              <1> 
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   159                              <1> ;
   160                              <1> ;       SBC-188 external devices
   161                              <1> ;
   162                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   163                              <1> 
   164                              <1> IO_BASE			equ	0400h
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> 
   172                              <1> uart_base               equ     IO_BASE+0280h
   173                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   174                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   175                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   176                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   177                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   178                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   179                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   180                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   181                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   182                              <1> uart_sr			equ	uart_base+7	;Scratch
   183                              <1> 
   184                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   185                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   186                              <1> 
   187                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   188                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> CTRL259		equ	IO_BASE+0238H
   191                              <1> ; LEDS are at addresses 0..3
   192                              <1> ; other control ports on 4..7
   193                              <1> LED0		equ	CTRL259+0
   194                              <1> LED1		equ	LED0+1
   195                              <1> LED2		equ	LED0+2
   196                              <1> LED3		equ	LED0+3
   197                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   198                              <1> ;unused		equ	CTRL259+5
   199                              <1> ;unused		equ	CTRL259+6
   200                              <1> ;unused		equ	CTRL259+7
   201                              <1> 
   202                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   206                              <1> 
   207                              <1> 
   208                              <1> 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; Floppy controller (Duodyne Disk IO)
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> FDC	        equ	IO_BASE+0080H
   213                              <1> FDC_MSR         equ     FDC
   214                              <1> FDC_DATA        equ     FDC+1
   215                              <1> FDC_TC	        equ	FDC+2
   216                              <1> FDC_RES	        equ	FDC+3
   217                              <1> FDC_LDCR	equ	FDC+5
   218                              <1> FDC_LDOR	equ	FDC+6
   219                              <1> FDC_DACK        equ	FDC+6
   220                              <1> FDC_DACK_TC     equ     FDC+7
   221                              <1> 
   222                              <1> 
   223                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> RTC	equ	IO_BASE+0094H
   227                              <1> 
   228                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231                              <1> PPI	        equ	IO_BASE+0088H
   232                              <1> 
   233                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   234                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   235                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   236                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   237                              <1> 
   238                              <1> portA           equ     PPI+0   ;
   239                              <1> portB           equ     PPI+1   ;
   240                              <1> portC           equ     PPI+2   ;
   241                              <1> 
   242                              <1> ; end CPUREGS.ASM
    27                                  	%include "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define DIDE_driver 0		/*
   261                              <2> %else
   262                              <2> %define DIDE_driver 0
   263                              <2> %endif
   264                              <2> %if 0				;*/
   265                              <2> #define DISKIO_driver 1		/*
   266                              <2> %else
   267                              <2> %define DISKIO_driver 1
   268                              <2> %endif
   269                              <2> %if 0				;*/
   270                              <2> #define MFPIC_driver 1		/*
   271                              <2> %else
   272                              <2> %define MFPIC_driver 1
   273                              <2> %endif
   274                              <2> %if 0				;*/
   275                              <2> #define DSD_driver 1		/*
   276                              <2> %else
   277                              <2> %define DSD_driver 1
   278                              <2> %endif
   279                              <2> %if 0				;*/
   280                              <2> #define V3IDE8_driver (SBC188==3)		/*
   281                              <2> %else
   282                              <2> %define V3IDE8_driver (SBC188==3)
   283                              <2> %endif
   284                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                  	%define DUMP 1
    30                                  	%define DEBUG 1
    31                                  	%define SOFT_DEBUG 1
    32                                  	; sterilize SOFT_DEBUG for now
    33                                  	%if SOFT_DEBUG > 1
    34                                  	%undef SOFT_DEBUG
    35                                  	%define SOFT_DEBUG 1
    36                                  	%endif
    37                                  
    38                                  	global BIOS_call_13h
    39                                  	;; global Floppy_BIOS_call_13h_entry
    40                                  	global wait12
    41                                  	global @enable, @disable
    42                                  	%if SOFT_DEBUG
    43                                  	extern _cprintf
    44                                  	global undefined
    45                                  	global fn00, fn02, fn03, fn04
    46                                  	global get_msr
    47                                  	global get_data
    48                                  	global check_DL
    49                                  	global get_disk_type
    50                                  	global get_media
    51                                  	global set_media_pointer
    52                                  	global rwv_common
    53                                  	global Seek, recalibrate, Specify
    54                                  	global rwv_common.marker
    55                                  	global end_rwv
    56                                  	global xfer_read_sector, xfer_write_sector, xfer_verify_sector
    57                                  	global xfer_format_track
    58                                  	global Check_RW_Status
    59                                  	%endif
    60                                  
    61                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    62                                  	; Error, Okay, Complete status conditions
    63                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    64                                  
    65                                  	%define Error stc
    66                                  	; test with:
    67                                  	; JC xxx (jump on error)
    68                                  	; JNC xxx (jump on no error)
    69                                  
    70                                  	%define Okay xor ah, ah
    71                                  	; test with:
    72                                  	; JZ xxx (jump okay)
    73                                  	; JNZ xxx (jump not okay)
    74                                  
    75                                  	%define Complete or ah, 3
    76                                  	; test with:
    77                                  	; JA xxx (jump complete AND no error)
    78                                  	; JNZ xxx (jump complete)
    79                                  	; JZ xxx (jump not complete)
    80                                  
    81                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                                  
    83                                  
    84                                  	; at most we use 2 floppies
    85                                  	%define FLOPPY_MAX 2
    86                                  
    87                                  	; there is some disagreement about whether ES:DI gets set
    88                                  	; for Floppy calls to "int 13h, function 8"
    89                                  	FN08_SET_ES_DI equ 1
    90                                  	;FN08_SET_ES_DI equ 0
    91                                  
    92                                  	; Define the three modes of operation of the WD37C65B floppy controller
    93                                  	%define BASE 0FFh
    94                                  	%define SPECIAL 80h
    95                                  	%define PC_AT 00h
    96                                  
    97                                  	; DMA watch threshhold
    98                                  	%define THRESHHOLD 12
    99                                  
   100                                  	; Define the mode in which the WD37C65B is operated
   101                                  	%define MODE PC_AT           ; This MUST NOT be changed
   102                                  
   103                                  	; specify bits in the Operations Register
   104                                  	%define DSEL1 00h
   105                                  	%define DSEL2 01h
   106                                  	%define DSEL_MASK (DSEL1|DSEL2)
   107                                  	%define NO_RESET 04h
   108                                  	%define RESET 00h
   109                                  	%define DMAEN 08h
   110                                  	%define MOEN1 10h
   111                                  	%define MOEN2 20h
   112                                  	%define MOEN_MASK (MOEN1|MOEN2)
   113                                  
   114                                  	%define TurnOn 8             ; used by all DSEL's
   115                                  
   116                                  	; the Motor turn - on delay in milliseconds
   117                                  	%define MOTOR_DELAY (TurnOn * 125)
   118                                  
   119                                  	; define the disk density clock rate selects
   120                                  	%define FDC_HD 00h
   121                                  	%define FDC_DD 02h
   122                                  
   123                                  	; The individual floppy disk status bits
   124                                  	%define FDC_DRIVE_PRESENT 1
   125                                  	%define FDC_DRIVE_READY 2
   126                                  
   127                                  
   128                                  	; define the MSR bits:
   129                                  	RQM equ 80h                  ; request for master
   130                                  	DIO equ 40h                  ; data IN=1, out=0
   131                                  	EXM equ 20h                  ; Execution phase in non - DMA mode
   132                                  	; this should NEVER be set
   133                                  	BUSY equ 10h                 ; Controller Busy
   134                                  	FD3 equ 08h                  ; DS3 is seeking
   135                                  	FD2 equ 04h                  ; DS2 is seeking
   136                                  	FD1 equ 02h                  ; DS1 is seeking
   137                                  	FD0 equ 01h                  ; DS0 is seeking
   138                                  
   139                                  	; MSR I / O status (in / out from CPU)
   140                                  	MSR_IN equ RQM | DIO
   141                                  	MSR_OUT equ RQM
   142                                  	MSR_MASK equ RQM | DIO
   143                                  
   144                                  	; This is the list of controller commands that we use
   145                                  
   146                                  	CMD_RECALIBRATE equ 7        ; 1 param byte (unit #)
   147                                  	; No result bytes
   148                                  	CMD_SENSE_INT_STATUS equ 8   ; No paramter bytes
   149                                  	; 2 result bytes
   150                                  	CMD_SENSE_DRIVE_STATUS equ 4 ; 1 param byte
   151                                  	; 1 result byte
   152                                  	CMD_SPECIFY equ 3            ; 2 parameter bytes
   153                                  	; No result bytes
   154                                  	CMD_SEEK equ 15              ; 2 parameter bytes
   155                                  	; No result bytes
   156                                  	CMD_READ_ID equ 10           ; param in cmd; 1 param byte
   157                                  	; 7 result bytes
   158                                  	CMD_READ_DATA equ 6          ; params in cmd; 8 param bytes
   159                                  	; 7 result bytes
   160                                  	CMD_WRITE_DATA equ 5         ; params in cmd; 8 param bytes
   161                                  	; 7 result bytes
   162                                  	CMD_READ_A_TRACK equ 2       ; params in cmd; 8 param bytes
   163                                  	; 7 result bytes
   164                                  	CMD_FORMAT_A_TRACK equ 13    ; params in cmd; 5 param bytes
   165                                  	; 7 result bytes
   166                                  	CMD_SCAN_EQUAL equ 11h       ; params in cmd; 8 param bytes
   167                                  	; 7 result bytes
   168                                  	CMD_SCAN_LOW_OR_EQUAL equ 19h ; params in cmd; 8 param bytes
   169                                  	; 7 result bytes
   170                                  	CMD_SCAN_HIGH_OR_EQUAL equ 1Dh ; params in cmd; 8 param bytes
   171                                  	; 7 result bytes
   172                                  
   173                                  
   174                                  	; define the extra bits in some command codes
   175                                  
   176                                  	CMD_MT equ 80h               ; Multi - track operation
   177                                  	CMD_MF equ 40h               ; MFM recording mode
   178                                  	CMD_SK equ 20h               ; skip deleted data mark
   179                                  
   180                                  
   181                                  
   182                                  	; define the ST3 status bits
   183                                  
   184                                  	ST3_WP equ 40h               ; NOT Write Protected
   185                                  	ST3_TR00 equ 10h             ; Track 0 signal
   186                                  	ST3_WP2 equ 08h              ; duplicate of ST3_WP; ST3_2S for 8" floppies
   187                                  	ST3_HS equ 04h               ; head 0 or 1
   188                                  	ST3_US equ 03h               ; Unit mask (0..3)
   189                                  
   190                                  
   191                                  	; define the ST2 status bits
   192                                  
   193                                  	ST2_CM equ 40h               ; Control Mark (deleted data mark)
   194                                  	ST2_DD equ 20h               ; Data Error (data field)
   195                                  	ST2_WC equ 10h               ; Wrong Cylinder
   196                                  	ST2_SH equ 08h               ; Scan Hit (not used here)
   197                                  	ST2_SN equ 04h               ; Scan Not Satisfied (not used here)
   198                                  	ST2_BC equ 02h               ; Bad Cylinder
   199                                  	ST2_MD equ 01h               ; Missing address mark
   200                                  
   201                                  	ST2_ANY equ ST2_CM + ST2_DD + ST2_WC + ST2_BC + ST2_MD
   202                                  
   203                                  
   204                                  	; define the ST1 status bits
   205                                  
   206                                  	ST1_EN equ 80h               ; End of cylinder
   207                                  	ST1_DE equ 20h               ; Data error (CRC err in address or data field)
   208                                  	ST1_OR equ 10h               ; Overrun (we will always see this flag)
   209                                  	ST1_ND equ 04h               ; No Data
   210                                  	ST1_NW equ 02h               ; Not writeable (WP is set)
   211                                  	ST1_MA equ 01h               ; Missing address mark
   212                                  
   213                                  	; define the ST0 status bits
   214                                  
   215                                  	ST0_IC equ 0C0h              ; Interrupt code mask
   216                                  	; 00 = normal termination
   217                                  	; 01 = abnormal termination
   218                                  	; 10 = invalid command
   219                                  	; 11 = abnormal termination - - change in ready status
   220                                  
   221                                  	ST0_SE equ 20h               ; Seek end
   222                                  	ST0_EC equ 10h               ; Equipment check
   223                                  	ST0_NR equ 08h               ; Not Ready (always 0 on WD37C65B)
   224                                  	ST0_HS equ 04h               ; Head Select
   225                                  	;ST0_US equ 03h ; Unit select mask
   226                                  	ST0_US equ 01h               ; Unit select mask
   227                                  
   228                                  	ST0_ANY equ ST0_EC + ST0_NR  ; Any ST0 error
   229                                  
   230                                  
   231                                  
   232                                  	; The FDC interrupt control register
   233                                  	fdc_int_control equ PIC_I1CON
   234                                  
   235                                  
   236                                  	; Standard int 13h stack frame layout is
   237                                  	; created by: PUSHM ALL, DS, ES
   238                                  	; MOV BP, SP
   239                                  	;
   240                                  	offset_DI equ 0
   241                                  	offset_SI equ offset_DI + 2
   242                                  	offset_BP equ offset_SI + 2
   243                                  	offset_SP equ offset_BP + 2
   244                                  	offset_BX equ offset_SP + 2
   245                                  	offset_DX equ offset_BX + 2
   246                                  	offset_CX equ offset_DX + 2
   247                                  	offset_AX equ offset_CX + 2
   248                                  	offset_DS equ offset_AX + 2
   249                                  	offset_ES equ offset_DS + 2
   250                                  	offset_IP equ offset_ES + 2
   251                                  	offset_CS equ offset_IP + 2
   252                                  	offset_FLAGS equ offset_CS + 2
   253                                  
   254                                  	; The byte registers in the stack
   255                                  	offset_AL equ offset_AX
   256                                  	offset_AH equ offset_AX + 1
   257                                  	offset_BL equ offset_BX
   258                                  	offset_BH equ offset_BX + 1
   259                                  	offset_CL equ offset_CX
   260                                  	offset_CH equ offset_CX + 1
   261                                  	offset_DL equ offset_DX
   262                                  	offset_DH equ offset_DX + 1
   263                                  
   264                                  
   265                                  	; FDC error codes (returned in AH)
   266                                  	;
   267                                  	ERR_no_error equ 0           ; no error (return Carry clear)
   268                                  	; everything below returns with the Carry set to indicate an error
   269                                  	ERR_invalid_command equ 1
   270                                  	ERR_address_mark_not_found equ 2
   271                                  	ERR_write_protect equ 3
   272                                  	ERR_sector_not_found equ 4
   273                                  	ERR_disk_removed equ 6
   274                                  	ERR_dma_overrun equ 8
   275                                  	ERR_dma_crossed_64k equ 9
   276                                  
   277                                  
   278                                  	ERR_media_type_not_found equ 12 ; 0Ch
   279                                  	ERR_uncorrectable_CRC_error equ 10h
   280                                  	ERR_controller_failure equ 20h
   281                                  	ERR_seek_failed equ 40h
   282                                  	ERR_disk_timeout equ 80h
   283                                  
   284                                  	ERR_81 equ 81h               ; fdc_ready_for_cmd, not rdy for input
   285                                  	ERR_82 equ 82h               ; fdc_ready_for_result, not rdy for output
   286                                  	ERR_83 equ 83h               ; input_result_from_fdc, after input, still busy
   287                                  	ERR_84 equ 84h               ; fdc_wait_seek_done, abnormal ST0_IC code
   288                                  	ERR_85 equ 85h               ; xfer_read_sector timeout
   289                                  	ERR_86 equ 86h               ; cylinder requested is invalid for drive
   290                                  	ERR_87 equ 87h               ; not on track 0 after recalibrate
   291                                  	ERR_88 equ 88h               ; wait for operation complete to be posted
   292                                  	ERR_89 equ 89h               ; fdc_ready_for_cmd, unexpectedly BUSY
   293                                  	ERR_8A equ 8Ah               ; second "seek failed" error (ignore during Format)
   294                                  
   295                                  	ERR_unknown equ 8Fh          ; ADDED - - JRC (may need to change)
   296                                  
   297                                  
   298                                  	SEGMENT _TEXT
   299                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   300                                  	; BIOS call entry for Floppy Disk driver
   301                                  	; int 13h
   302                                  	;
   303                                  	; The Fixed Disk driver will move the vector from 13h to 40h
   304                                  	; At the moment there is no Fixed Disk Driver
   305                                  	;
   306                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   307                                  	global BIOS_call_13h
   308                                  BIOS_call_13h:                ; Floppy driver entry
   309 00000000 FB                      	sti                          ; Enable interrupts
   310 00000001 061E60                  	pushm all, ds, es            ; Standard register save
   311 00000004 89E5                    	mov bp, sp                   ; establish stack addressing
   312                                  
   313 00000006 FC                      	cld                          ; may NOT assume direction flag is clear
   314 00000007 6A40                    	push bios_data_seg
   315 00000009 1F90                    	popm ds                      ; establish addressability for all functions
   316 0000000B C606AE0000              	mov byte [lock_count], 0     ; clear the lock counter
   317                                  
   318                                  	%if SOFT_DEBUG & DUMP
   319 00000010 06525150                	pushm ax, cx, dx, es
   320                                  
   321 00000014 53                      	push bx
   322 00000015 06                      	push es
   323 00000016 30FF                    	xor bh, bh
   324 00000018 88D3                    	mov bl, dl
   325 0000001A 53                      	push bx
   326 0000001B 88CB                    	mov bl, cl
   327 0000001D 53                      	push bx
   328 0000001E 88F3                    	mov bl, dh
   329 00000020 53                      	push bx
   330 00000021 88EB                    	mov bl, ch
   331 00000023 53                      	push bx
   332 00000024 89C3                    	mov bx, ax
   333 00000026 53                      	push bx
   334 00000027 0E                      	push cs
   335 00000028 68[4F09]                	push rwvc
   336 0000002B E8(0000)                	call _cprintf
   337 0000002E 83C412                  	add sp, 18
   338                                  
   339 00000031 58595A0790              	popm ax, cx, dx, es
   340 00000036 30FF                    	xor bh, bh
   341                                  	%endif
   342 00000038 88E3                    	mov bl, ah                   ; set to index into dispatch table
   343 0000003A 80FC19                  	cmp ah, max / 2
   344 0000003D 7202                    	jb .1
   345 0000003F B314                    	mov bl, 14h                  ; fn not defined for Floppy diskette
   346 00000041 30FF                    .1: xor bh, bh
   347 00000043 D1E3                    	shl bx, 1                    ; index words
   348 00000045 2EFF97[8300]            	cs call near [dispatch + bx]
   349                                  
   350                                  	; returns come here with AH set
   351                                  
   352 0000004A 08E4                    	or ah, ah                    ; is return code 0? sets carry=0, too
   353 0000004C 7401                    	jz exit_pops
   354                                  error_exit:
   355 0000004E F9                      	stc
   356                                  exit_pops:
   357 0000004F 88660F                  	mov [bp + offset_AH], ah     ; store for return
   358 00000052 89EC                    	mov sp, bp                   ; remove any allocated variables
   359                                  	%if SOFT_DEBUG & DUMP
   360 00000054 9C                      	pushm f                      ;, ax, bx, cx, dx, es
   361 00000055 88E0                    	mov al, ah                   ; save AH in AL
   362 00000057 9F                      	lahf                         ; get flags
   363 00000058 30FF                    	xor bh, bh                   ; Zap BH
   364 0000005A 8A1E9300                	mov bl, [fdc_op_start + 1]
   365 0000005E 53                      	push bx
   366 0000005F 8A1E9200                	mov bl, [fdc_op_start]
   367 00000063 53                      	push bx
   368 00000064 88E3                    	mov bl, ah
   369 00000066 83E301                  	and bx, 1                    ; mask Carry
   370 00000069 53                      	push bx
   371 0000006A 88C3                    	mov bl, al                   ; former AH
   372 0000006C 53                      	push bx
   373 0000006D 0E                      	push cs                      ; far pointer to ...
   374 0000006E 68[8609]                	push fnret                   ; format
   375 00000071 E8(0000)                	call _cprintf
   376 00000074 83C40C                  	add sp, 12
   377 00000077 9D                      	popm f                       ;, ax, bx, cx, dx, es
   378                                  	%endif
   379 00000078 611F900790              	popm all, ds, es
   380 0000007D CA0200                  	retf 2                       ; return the carry
   381                                  
   382                                  
   383                                  
   384                                  	;fn00 ; Reset Disk System
   385                                  fn01:                         ; Get Disk System Status
   386                                  	;fn02 ; Read Sector
   387                                  	;fn03 ; Write Sector
   388                                  	;fn04 ; Verify Sector
   389                                  	;fn05: ; Format Track
   390                                  fn06:                         ; Format Bad Track (fixed disk) [PC]
   391                                  fn07:                         ; Format Drive (fixed disk) [PC]
   392                                  	;fn08 ; Get Drive Parameters
   393                                  fn09:
   394                                  fn0A:
   395                                  fn0B:
   396                                  fn0C:
   397                                  fn0D:
   398                                  fn0E:
   399                                  fn0F:
   400                                  fn10:
   401                                  fn11:
   402                                  fn12:
   403                                  fn13:
   404                                  fn14:                         ; * * * fixed disk only * * *
   405                                  	;fn15: ; Get Disk Type [AT]
   406                                  	;fn16: ; Get Disk Change Status (floppy)
   407                                  fn17:                         ; Set Disk Type (floppy)
   408                                  	;fn18: ; Set Media Type for Format (floppy)
   409                                  undefined:
   410 00000080 B401                    	mov ah, ERR_invalid_command  ; equ 1
   411 00000082 C3                      	ret
   412                                  
   413                                  
   414                                  dispatch:
   415 00000083 [A503]                  	dw fn00                      ; Reset Disk System
   416 00000085 [8000]                  	dw fn01                      ;
   417 00000087 [3B04]                  	dw fn02
   418 00000089 [4204]                  	dw fn03
   419 0000008B [4904]                  	dw fn04
   420 0000008D [D004]                  	dw fn05
   421 0000008F [8000]                  	dw fn06
   422 00000091 [8000]                  	dw fn07
   423 00000093 [FF03]                  	dw fn08
   424 00000095 [8000]                  	dw fn09
   425 00000097 [8000]                  	dw fn0A
   426 00000099 [8000]                  	dw fn0B
   427 0000009B [8000]                  	dw fn0C
   428 0000009D [8000]                  	dw fn0D
   429 0000009F [8000]                  	dw fn0E
   430 000000A1 [8000]                  	dw fn0F
   431 000000A3 [8000]                  	dw fn10
   432 000000A5 [8000]                  	dw fn11
   433 000000A7 [8000]                  	dw fn12
   434 000000A9 [8000]                  	dw fn13
   435 000000AB [8000]                  	dw fn14
   436 000000AD [6305]                  	dw fn15
   437 000000AF [7905]                  	dw fn16
   438 000000B1 [8000]                  	dw fn17
   439 000000B3 [9105]                  	dw fn18
   440                                  	max equ $ - dispatch
   441                                  
   442                                  
   443                                  	;
   444                                  	; Floppy Drive Types (fn08)
   445                                  	;
   446                                  	; We support:
   447                                  	; 1 = 5.25" 360K 40track yes
   448                                  	; 2 = 5.25" 1.2M 80track yes
   449                                  	; 3 = 3.5" 720K 80track yes
   450                                  	; 4 = 3.5" 1.44M 80track yes
   451                                  	; 6 = 3.5" 2.88M 80track no (WD37C65CJM & 32Mhz osc)
   452                                  	; 7 = 3.5" 1.28M 1024sect no (Japan)
   453                                  	;
   454                                  	; Floppy Combos
   455                                  	; 5 = 5.25" 360K 40track in Drive Type 2 no
   456                                  	; 8 = 5.25" 512k 77track / 128sector in Drv 2 (future) CP / M
   457                                  	; 9 = 3.5" 256k 77track / 128sector in Drv 3 (future) CP / M
   458                                  	; 10 = 3.5" 512k 77track / 128sector in Drv 4 (future) CP / M
   459                                  	;;
   460                                  
   461                                  D_table:
   462 000000B5 0000                    	dw 0
   463 000000B7 [CB00]                  	dw DTAB1                     ; 360K (MFM)
   464 000000B9 [D800]                  	dw DTAB2                     ; 1.2M
   465 000000BB [E500]                  	dw DTAB3                     ; 720K
   466 000000BD [F200]                  	dw DTAB4                     ; 1.44M
   467 000000BF 0000                    	dw 0                         ; DTAB5
   468 000000C1 0000                    	dw 0                         ; DTAB6
   469 000000C3 [1901]                  	dw DTAB7                     ; 1024 byte sectors (Japan)
   470 000000C5 [2601]                  	dw DTAB8                     ; CP / M 26 / 77 in 1.2M drive (128 byte FM sectors)
   471 000000C7 [3301]                  	dw DTAB9                     ; CP / M 13 / 77 in 720K drive
   472 000000C9 [4001]                  	dw DTAB10                    ; CP / M 26 / 77 in 1.44M drive
   473                                  	L_table equ ($ - D_table) / 2
   474                                  
   475                                  
   476                                  	; Disk Information
   477                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   478                                  	;;; The DOS MFM floppies
   479                                  	; 360K 5.25" DD floppy
   480 000000CB DF022502092AFF50F6-     DTAB1: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   480 000000D4 0F082780           
   481                                  
   482                                  	; 1.2M 5.25" HD floppy
   483 000000D8 DF0225020F1BFF54F6-     DTAB2: db 0DFh, 2, 25h, 2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   483 000000E1 0F084F00           
   484                                  
   485                                  	; 720K 3.5" or 5.25" DD floppy
   486 000000E5 DF022502092AFF50F6-     DTAB3: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   486 000000EE 0F084F80           
   487                                  
   488                                  	; 1.44M 3.5" HD floppy
   489 000000F2 AF022502121BFF6CF6-     DTAB4: db 0AFh, 2, 25h, 2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   489 000000FB 0F084F00           
   490                                  
   491                                  	; 360K 5.25" DD floppy in 1.2M HD drive
   492 000000FF DF022502092AFF50F6-     DTAB5: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   492 00000108 0F082740           
   493                                  
   494                                  	; 2.88M 3.5" XD floppy
   495 0000010C AF022502241BFF50F6-     DTAB6: db 0AFh, 2, 25h, 2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   495 00000115 0F084FC0           
   496                                  
   497                                  	; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   498 00000119 AF0225030835FF74F6-     DTAB7: db 0AFh, 2, 25h, 3, 8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   498 00000122 0F084F00           
   499                                  
   500                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   501                                  	;;; The CP / M FM floppies
   502                                  	; 500K 5.25" CP / M (FM) floppy in 1.2M drive
   503 00000126 DF0225001A098023E5-     DTAB8: db 0DFh, 2, 25h, 0, 26, 9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   503 0000012F 0F084C00           
   504                                  	;;; 7h 1Bh
   505                                  
   506                                  	; 250K 3.5" CP / M (FM) floppy in 720K drive
   507 00000133 DF0225000D138046E5-     DTAB9: db 0DFh, 2, 25h, 0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   507 0000013C 0F084C80           
   508                                  
   509                                  	; 500K 3.5" CP / M (FM) floppy in 1.44M drive
   510 00000140 AF0225001A15804BE5-     DTAB10: db 0AFh, 2, 25h, 0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   510 00000149 0F084C00           
   511                                  
   512                                  
   513                                  	; DTAB table offsets
   514                                  	DTAB_specify equ 0
   515                                  	DTAB_specify2 equ DTAB_specify + 1
   516                                  	DTAB_turnoff_ticks equ DTAB_specify2 + 1
   517                                  	DTAB_N_param equ DTAB_turnoff_ticks + 1
   518                                  	DTAB_EOT_nsect equ DTAB_N_param + 1
   519                                  	DTAB_rw_gap equ DTAB_EOT_nsect + 1
   520                                  	DTAB_data_len equ DTAB_rw_gap + 1
   521                                  	DTAB_fmt_gap3 equ DTAB_data_len + 1
   522                                  	DTAB_fmt_fill equ DTAB_fmt_gap3 + 1
   523                                  	DTAB_unknown equ DTAB_fmt_fill + 1
   524                                  	DTAB_startup equ DTAB_unknown + 1 ; in 1 / 8 seconds
   525                                  	DTAB_max_cylinder equ DTAB_startup + 1
   526                                  	DTAB_control equ DTAB_max_cylinder + 1
   527                                  
   528                                  
   529                                  	;
   530                                  	; Returns:
   531                                  	; AL = contents of FDC_DATA (Data Register)
   532                                  	;
   533                                  get_data:
   534 0000014D 52                      	push dx
   535 0000014E BA8104                  	mov dx, FDC_DATA
   536 00000151 EC                      	in al, dx
   537 00000152 5A                      	pop dx
   538 00000153 C3                      	ret
   539                                  
   540                                  
   541                                  	;
   542                                  	; Returns:
   543                                  	; AL = contents of FDC_MSR (Main Status Register)
   544                                  	;
   545                                  get_msr:
   546 00000154 52                      	push dx
   547 00000155 BA8004                  	mov dx, FDC_MSR
   548 00000158 EC                      	in al, dx
   549 00000159 5A                      	pop dx
   550 0000015A C3                      	ret
   551                                  
   552                                  	; delay for about 12 microseconds for MSR to be set
   553                                  	extern microsecond
   554                                  	global wait12
   555                                  wait12:
   556 0000015B 51                      	push cx
   557                                  	%if 1
   558                                  	; mov cx, 12 ; 12 microseconds
   559 0000015C 30ED                    	xor ch, ch
   560 0000015E 8A0EFF00                	mov cl, [cpu_xtal]           ; 2x clock (32usec on 16Mhz CPU)
   561 00000162 D0E9                    	shr cl, 1
   562 00000164 83E905                  	sub cx, 5                    ; fudge factor for overhead
   563                                  	%else
   564                                  	xor ch, ch
   565                                  	mov cl, [wait12_count]
   566                                  	%endif
   567 00000167 E8(0000)                	call microsecond
   568 0000016A 59                      	pop cx
   569 0000016B C3                      	ret
   570                                  
   571                                  
   572                                  wait1000:
   573 0000016C 51                      	push cx
   574 0000016D B9E803                  	mov cx, 1000                 ; 1 ms delay
   575 00000170 E8(0000)                	call microsecond
   576 00000173 59                      	pop cx
   577 00000174 C3                      	ret
   578                                  
   579                                  	;
   580                                  	; Convention used below
   581                                  	; Flags: Meaning:
   582                                  	; C=1 error
   583                                  	; C=0, AH=0 okay
   584                                  	; C=0, AH=3 + complete
   585                                  	;
   586                                  	global fdc_ready_for_command
   587                                  fdc_ready_for_command:
   588 00000175 51                      	push cx
   589                                  
   590                                  .0:
   591 00000176 B9E803                  	mov cx, 1000
   592 00000179 E8DFFF                  .1: call wait12
   593 0000017C E8D5FF                  	call get_msr
   594 0000017F A880                    	test al, RQM
   595 00000181 E1F6                    	loopz .1
   596                                  	; try to compensate for MSDOS anomaly with a BUSY test
   597 00000183 7508                    	jnz .req
   598 00000185 A810                    	test al, BUSY                ; How does MSDOS manage this???
   599 00000187 74ED                    	jz .0
   600 00000189 B489                    	mov ah, ERR_89
   601 0000018B EB21                    	jmp .err
   602                                  
   603                                  .req:
   604 0000018D A840                    	test al, DIO                 ; C=0, clear the carry
   605 0000018F 7420                    	jz .2                        ; ready for input?
   606 00000191 E8B9FF                  	call get_data
   607                                  	%if SOFT_DEBUG & DUMP
   608 00000194 FA                      	cli
   609 00000195 06525150                	pushm ax, cx, dx, es
   610 00000199 B4F0                    	mov ah, 0f0h
   611 0000019B 50                      	push ax
   612 0000019C 0E                      	push cs                      ; far pointer to ...
   613 0000019D 68[D409]                	push fndio                   ; format
   614 000001A0 E8(0000)                	call _cprintf
   615 000001A3 83C406                  	add sp, 6
   616 000001A6 58595A0790              	popm ax, cx, dx, es
   617 000001AB FB                      	sti                          ; Enable interrupts
   618                                  	%endif
   619 000001AC EBCB                    	jmp .1
   620                                  	;;mov ah, ERR_81 ; not ready for input
   621 000001AE F9                      .err: Error                   ; C=1, signal error
   622 000001AF EB02                    	jmp .99
   623                                  
   624                                  .2:
   625 000001B1 30E4                    	Okay                         ; AH=0, C=0
   626 000001B3 59                      .99: pop cx
   627 000001B4 C3                      	ret
   628                                  	; returns Error or Okay
   629                                  
   630                                  
   631                                  	global fdc_ready_for_result
   632                                  fdc_ready_for_result:
   633 000001B5 E8A3FF                  	call wait12
   634 000001B8 E899FF                  	call get_msr
   635 000001BB A810                    	test al, BUSY                ; controller busy?
   636 000001BD 7505                    	jnz .0                       ; jump if busy
   637 000001BF 80CC03                  	Complete                     ; not busy, return Complete
   638 000001C2 EB15                    	jmp .99
   639                                  .0:
   640 000001C4 E894FF                  	call wait12
   641 000001C7 E88AFF                  .1: call get_msr
   642 000001CA A880                    	test al, RQM                 ; wait for RQM
   643 000001CC 74F9                    	jz .1
   644                                  
   645 000001CE A840                    	test al, DIO                 ; set C=0, Z - flag
   646 000001D0 7505                    	jnz .5                       ; DIO==1 means output
   647 000001D2 B482                    	mov ah, ERR_82
   648 000001D4 F9                      	Error
   649 000001D5 EB02                    	jmp .99
   650                                  
   651 000001D7 30E4                    .5: Okay
   652 000001D9 C3                      .99: ret
   653                                  	; returns Error, Okay, or Complete
   654                                  
   655                                  
   656                                  
   657                                  	; byte to output is in AL
   658                                  	; AH=0 and Carry=0 if all Okay
   659                                  	; Carry=1, AH=code if FDC not ready
   660                                  	global output_byte_to_fdc
   661                                  output_byte_to_fdc:
   662 000001DA 52                      	pushm dx
   663                                  
   664 000001DB 88C2                    	mov dl, al
   665 000001DD E895FF                  	call fdc_ready_for_command
   666 000001E0 88D0                    	mov al, dl
   667 000001E2 7206                    	jc .8                        ; propagate error
   668                                  
   669 000001E4 BA8104                  	mov dx, FDC_DATA
   670 000001E7 EE                      	out dx, al
   671 000001E8 30E4                    	Okay                         ; C=0, AH=okay
   672                                  .8:
   673 000001EA 5A                      	popm dx
   674 000001EB C3                      	ret                          ; C=0, AH=okay
   675                                  	; returns Error or Okay
   676                                  
   677                                  
   678                                  	global input_byte_from_fdc
   679                                  input_byte_from_fdc:
   680 000001EC 52                      	push dx
   681 000001ED E8C5FF                  	call fdc_ready_for_result
   682 000001F0 7208                    	jc .9                        ; propagate error
   683 000001F2 7506                    	jnz .9                       ; if (Complete) return Complete;
   684                                  
   685 000001F4 BA8104                  	mov dx, FDC_DATA
   686 000001F7 EC                      	in al, dx
   687 000001F8 30E4                    	Okay                         ; return Okay
   688                                  .9:
   689 000001FA 5A                      	pop dx
   690 000001FB C3                      	ret                          ;
   691                                  	; returns Error, Okay, or Complete
   692                                  
   693                                  
   694                                  	; CX = length of command
   695                                  	; DX:SI = pointer to command (not DS:SI, we'll set this up)
   696                                  	;
   697                                  	global output_cmd_to_fdc
   698                                  output_cmd_to_fdc:
   699 000001FC 0656                    	pushm si, es
   700 000001FE 8EC2                    	mov es, dx                   ; DS:SI is now the source
   701 00000200 90                      	cnop
   702                                  
   703                                  	%if SOFT_DEBUG & DUMP
   704 00000201 268A04                  	es mov al, [si]              ; record two bytes of command
   705 00000204 A29200                  	mov [fdc_op_start], al
   706 00000207 268A4401                	es mov al, [si + 1]          ; first & second
   707 0000020B A29300                  	mov [fdc_op_start + 1], al
   708                                  	%endif
   709                                  
   710 0000020E E8E407                  	call @disable
   711                                  .1:
   712 00000211 26AC                    	es lodsb                     ; note segment override
   713 00000213 E8C4FF                  	call output_byte_to_fdc      ; returns error or okay
   714 00000216 7206                    	jc .7                        ; propagate any error
   715 00000218 E2F7                    	loop .1
   716                                  
   717 0000021A 30E4                    	Okay                         ; return ok
   718 0000021C EB01                    	jmp .9
   719                                  
   720 0000021E F9                      .7: Error                     ; propagate error
   721                                  
   722 0000021F E8E407                  .9: call @enable
   723 00000222 5E0790                  	popm si, es
   724 00000225 C3                      	ret
   725                                  	; returns Error or Okay
   726                                  
   727                                  
   728                                  
   729                                  	; assumes DS points at BIOS Data Area
   730                                  	; preserves DI
   731                                  	global input_result_from_fdc
   732                                  input_result_from_fdc:
   733 00000226 5157                    	pushm di, cx
   734 00000228 E8CA07                  	call @disable                ; lock the operation
   735                                  
   736 0000022B BF4200                  	mov di, fdc_ctrl_status      ; in BIOS Data Area
   737 0000022E B90800                  	mov cx, 8                    ; 7 bytes input, then 'complete'
   738                                  
   739 00000231 E8B8FF                  .0: call input_byte_from_fdc
   740 00000234 7217                    	jc .9                        ; propagate error
   741 00000236 7511                    	jnz .8                       ; if complete, return okay
   742                                  
   743 00000238 8805                    	mov byte [di], al            ; store the result
   744 0000023A 47                      	inc di
   745 0000023B E2F4                    	loop .0
   746                                  
   747 0000023D E81BFF                  	call wait12                  ;
   748 00000240 E811FF                  	call get_msr                 ; check for busy
   749 00000243 A810                    	test al, BUSY
   750                                  
   751 00000245 B483                    	mov ah, ERR_83
   752 00000247 7504                    	jnz .95                      ; return error if busy
   753                                  
   754                                  .8:
   755 00000249 30E4                    	Okay                         ; return okay
   756 0000024B EB01                    	jmp .99                      ; single return point
   757                                  
   758                                  .9:
   759 0000024D F9                      .95: Error                    ; return error;
   760                                  
   761 0000024E E8B507                  .99: call @enable             ; unlock the operation
   762 00000251 5F59                    	popm di, cx
   763 00000253 C3                      	ret
   764                                  	; returns Error, Okay, or Complete
   765                                  
   766                                  
   767                                  	;__CHECKINT__________________________________________________________________________________________________________________________
   768                                  	;
   769                                  	; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
   770                                  	; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
   771                                  	; SENSE INTERRUPT COMMAND. IF IT RTSURNS WITH NON ZERO
   772                                  	; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
   773                                  	;________________________________________________________________________________________________________________________________
   774                                  	;
   775                                  CHECKINT:
   776                                  
   777                                  	%if SOFT_DEBUG & DUMP
   778 00000254 9C                      	pushm f                      ;, ax, bx, cx, dx, es
   779 00000255 88E0                    	mov al, ah                   ; save AH in AL
   780 00000257 9F                      	lahf                         ; get flags
   781 00000258 BBFFFF                  	mov bx, 0ffffh
   782 0000025B 53                      	push bx
   783 0000025C 0E                      	push cs                      ; far pointer to ...
   784 0000025D 68[E209]                	push fncheckint              ; format
   785 00000260 E8(0000)                	call _cprintf
   786 00000263 83C406                  	add sp, 6
   787 00000266 9D                      	popm f                       ;, ax, bx, cx, dx, es
   788                                  	%endif
   789                                  
   790                                  
   791 00000267 B96400                  	mov cx, 100                  ; setup to allow timeout
   792                                  .1:
   793 0000026A E8E7FE                  	call get_msr
   794 0000026D A880                    	test al, RQM
   795 0000026F 7507                    	jnz .2                       ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
   796 00000271 E8E7FE                  	call wait12
   797 00000274 E2F4                    	loop .1
   798 00000276 EB1E                    	JMP ERRCLR
   799                                  .2:
   800 00000278 E8D9FE                  	call get_msr
   801 0000027B A840                    	test al, 040h                ; WAITING FOR INPUT?
   802 0000027D 7540                    	jnz SENDINT
   803 0000027F B000                    	mov al, 00
   804                                  
   805                                  	%if SOFT_DEBUG & DUMP
   806 00000281 9C                      	pushm f                      ;, ax, bx, cx, dx, es
   807 00000282 88E0                    	mov al, ah                   ; save AH in AL
   808 00000284 9F                      	lahf                         ; get flags
   809 00000285 BB0000                  	mov bx, 0h
   810 00000288 53                      	push bx
   811 00000289 0E                      	push cs                      ; far pointer to ...
   812 0000028A 68[E209]                	push fncheckint              ; format
   813 0000028D E8(0000)                	call _cprintf
   814 00000290 83C406                  	add sp, 6
   815 00000293 9D                      	popm f                       ;, ax, bx, cx, dx, es
   816                                  	%endif
   817                                  
   818                                  
   819 00000294 59                      	pop cx
   820 00000295 C3                      	ret
   821                                  
   822                                  ERRCLR:
   823 00000296 B90001                  	mov cx, 100h                 ; setup to allow timeout
   824                                  .1:
   825 00000299 E8B1FE                  	call get_data
   826 0000029C E8B5FE                  	call get_msr
   827 0000029F A880                    	test al, RQM
   828 000002A1 7505                    	jnz .2                       ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
   829 000002A3 E8B5FE                  	call wait12
   830 000002A6 E2F1                    	loop .1
   831                                  .2:
   832 000002A8 B0FF                    	mov al, 0FFh
   833                                  
   834                                  	%if SOFT_DEBUG & DUMP
   835 000002AA 9C                      	pushm f                      ;, ax, bx, cx, dx, es
   836 000002AB 88E0                    	mov al, ah                   ; save AH in AL
   837 000002AD 9F                      	lahf                         ; get flags
   838 000002AE BBFF00                  	mov bx, 00ffh
   839 000002B1 53                      	push bx
   840 000002B2 0E                      	push cs                      ; far pointer to ...
   841 000002B3 68[E209]                	push fncheckint              ; format
   842 000002B6 E8(0000)                	call _cprintf
   843 000002B9 83C406                  	add sp, 6
   844 000002BC 9D                      	popm f                       ;, ax, bx, cx, dx, es
   845                                  	%endif
   846                                  
   847 000002BD 59                      	pop cx
   848 000002BE C3                      	ret
   849                                  
   850                                  	;__SENDINT__________________________________________________________________________________________________________________________
   851                                  	;
   852                                  	; SENSE INTERRUPT COMMAND
   853                                  	;________________________________________________________________________________________________________________________________
   854                                  	;
   855                                  SENDINT:
   856 000002BF B008                    	mov al, CMD_SENSE_INT_STATUS
   857 000002C1 E816FF                  	call output_byte_to_fdc
   858 000002C4 7218                    	jc .9                        ; quit if error
   859                                  
   860 000002C6 E85DFF                  	call input_result_from_fdc
   861 000002C9 7213                    	jc .9
   862                                  
   863 000002CB A04200                  	mov al, [fdc_ctrl_status]    ; get ST0
   864 000002CE 24C0                    	and al, 0C0h                 ; MASK OFF INTERRUPT STATUS BITS
   865 000002D0 3C80                    	cmp al, 080h                 ; CHECK IF INVALID COMMAND
   866 000002D2 740A                    	jz .9
   867 000002D4 E84FFF                  	call input_result_from_fdc
   868 000002D7 7205                    	jc .9
   869 000002D9 A04200                  	mov al, [fdc_ctrl_status]    ; get ST0
   870 000002DC 24C0                    	and al, 0C0h                 ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
   871                                  .9:
   872                                  ENDSENDINT:
   873 000002DE C3                      	ret                          ; ANYTHING ELSE IS AN ERROR
   874                                  
   875                                  
   876                                  	;__GFDATA__________________________________________________________________________________________________________________________
   877                                  	;
   878                                  	; GET DATA FROM FLOPPY CONTROLLER
   879                                  	;
   880                                  	; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
   881                                  	; RQM DIO
   882                                  	; 0 0 BUSY
   883                                  	; 1 0 WRITE TO DATA REGISTER PERMITTED
   884                                  	; 1 1 BYTE FOR READ BY HOST PENDING
   885                                  	; 0 1 BUSY
   886                                  	;
   887                                  	;________________________________________________________________________________________________________________________________
   888                                  	;
   889                                  	;GFDATA:
   890                                  	; LDY #$00
   891                                  	;!
   892                                  	; LDA FDC_MSR ; GET STATUS
   893                                  	; STA TMPSTORAGE ;
   894                                  	; ANDA #%10000000 ; NOT READY, WAIT
   895                                  	; BNE > ;
   896                                  	; INY
   897                                  	; BNE <
   898                                  	; LDA #$00
   899                                  	; RTS
   900                                  	;!
   901                                  	; LDA TMPSTORAGE
   902                                  	; ANDA #%01000000 ; ANY DATA FOR US?
   903                                  	; BEQ GFDATA1 ; NO, SKIP IT
   904                                  	; LDA FDC_DATA ; GET FDC DATA
   905                                  	;GFDATA1:
   906                                  	; RTS
   907                                  
   908                                  
   909                                  
   910                                  	%define INT_ENABLE 1
   911                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   912                                  	;
   913                                  	; Floppy Disk Controller
   914                                  	; Interrupt Handler
   915                                  	;
   916                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   917                                  	global fdc_interrupt_level
   918                                  fdc_interrupt_level:
   919                                  	; %if INT_ENABLE
   920                                  	; sti
   921                                  	; %endif
   922 000002DF 1E60                    	 pushm all, ds
   923 000002E1 FC                      	 cld ; just be sure
   924                                  
   925 000002E2 6A40                    	 push bios_data_seg
   926 000002E4 1F90                    	 popm ds
   927                                  	 %if INT_ENABLE==0
   928                                  	 inc byte [lock_count] ; so we don't re - enable
   929                                  	 %endif
   930 000002E6 E86BFE                  	 call get_msr
   931 000002E9 A810                    	 test al, BUSY ; test for controller busy
   932 000002EB 740A                    	 jz .4
   933                                  	 ; BUSY is set
   934 000002ED E836FF                  	 call input_result_from_fdc
   935 000002F0 18C0                    	 sbb al, al ; carry to AL
   936 000002F2 A24100                  	 mov byte [fdc_status], al ; FF=error, 0=okay
   937 000002F5 EB2C                    	 jmp .9 ; we got the results
   938                                  
   939                                  	 ;FDC not busy:
   940                                  	.4:
   941                                  	; xor bh, bh ; BH = false
   942 000002F7 B008                    	.5: mov al, CMD_SENSE_INT_STATUS
   943 000002F9 E8DEFE                  	 call output_byte_to_fdc
   944 000002FC 7225                    	 jc .9 ; quit if error
   945                                  
   946 000002FE E825FF                  	 call input_result_from_fdc
   947 00000301 7220                    	 jc .9
   948                                  
   949 00000303 A04200                  	 mov al, [fdc_ctrl_status] ; get ST0
   950 00000306 3480                    	 xor al, 80h ; IC= 10xxxxxxb (invalid)
   951 00000308 24C0                    	 and al, ST0_IC ; isolate IC
   952 0000030A 7417                    	 je .9 ; invalid command
   953                                  
   954 0000030C A14200                  	 mov ax, [fdc_ctrl_status] ; get ST0 + PCN (present cylinder)
   955 0000030F A820                    	 test al, ST0_SE ; test Seek End condition
   956 00000311 74E4                    	 jz .5
   957                                  
   958 00000313 89C7                    	 mov di, ax ;
   959 00000315 83E701                  	 and di, ST0_US ; isolate unit number
   960 00000318 88A59400                	 mov [fdc_cylinder + di], ah ; set PCN from controller
   961 0000031C 800E3E0004              	 or byte [fdc_drv_calib], 04h ;POST Seek End seen
   962 00000321 EBD4                    	 jmp .5
   963                                  	.9:
   964 00000323 800E3E0001              	 or byte [fdc_drv_calib], 01h ;POST end of FDC interrupt
   965                                  	 %if INT_ENABLE==0
   966                                  	 dec byte [lock_count] ; restore the lock count
   967                                  	 %endif
   968                                  	 ; signal EOI (End of Interrupt)
   969 00000328 BA22FF                  	 mov dx, PIC_EOI ; EOI register
   970 0000032B B80080                  	 mov ax, EOI_NSPEC ; non - specific
   971 0000032E EF                      	 out dx, ax ; signal it
   972                                  
   973 0000032F 611F90                  	 popm all, ds
   974 00000332 CF                      	 iret
   975                                  
   976                                  
   977                                  
   978                                  	global fdc_timer_hook
   979                                  	; called from Timer Tick code with DS - >BIOS data area
   980                                  	; Destroys AX and DX
   981                                  	global fdc_timer_hook
   982                                  fdc_timer_hook:
   983 00000333 803E400000              	cmp byte [fdc_motor_ticks], 0
   984 00000338 740E                    	je .9
   985 0000033A FE0E4000                	dec byte [fdc_motor_ticks]
   986 0000033E 7508                    	jnz .9
   987                                  	; timer expired, stop the motors
   988 00000340 80263F00CF              	and byte [fdc_motor_LDOR], ~( MOEN_MASK )
   989 00000345 E80100                  	call out_LDOR_mem
   990 00000348 C3                      .9: ret
   991                                  
   992                                  
   993                                  
   994                                  	; FDC Operations Register operations
   995                                  	; put out the LDOR write - only register
   996                                  	; Assumes DS is BIOS data segment
   997                                  	; Destroys AX and DX
   998                                  out_LDOR_mem:
   999                                  
  1000                                  	%if SOFT_DEBUG & DUMP
  1001 00000349 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  1002 0000034A 88E0                    	mov al, ah                   ; save AH in AL
  1003 0000034C 9F                      	lahf                         ; get flags
  1004 0000034D 30FF                    	xor bh, bh                   ; Zap BH
  1005 0000034F 8A1E3F00                	mov bl, [fdc_motor_LDOR]
  1006 00000353 53                      	push bx
  1007 00000354 0E                      	push cs                      ; far pointer to ...
  1008 00000355 68[A809]                	push fnldor                  ; format
  1009 00000358 E8(0000)                	call _cprintf
  1010 0000035B 83C406                  	add sp, 6
  1011 0000035E 9D                      	popm f                       ;, ax, bx, cx, dx, es
  1012                                  	%endif
  1013                                  
  1014                                  
  1015 0000035F A03F00                  	mov al, [fdc_motor_LDOR]
  1016 00000362 BA8604                  	mov dx, FDC_LDOR
  1017 00000365 EE                      	out dx, al
  1018 00000366 C3                      	ret
  1019                                  
  1020                                  
  1021                                  	; wait until all seeking is done
  1022                                  	; assumes DS is set to BIOS data area
  1023                                  	;
  1024                                  	global fdc_wait_seek_done
  1025                                  fdc_wait_seek_done:
  1026                                  .1:
  1027 00000367 E8F1FD                  	call wait12
  1028 0000036A E8E7FD                  	call get_msr
  1029 0000036D A80F                    	test al, 0Fh                 ; test all the seek bits
  1030 0000036F 740C                    	jz .8
  1031 00000371 803E400000              	cmp byte [fdc_motor_ticks], 0
  1032 00000376 75EF                    	jnz .1
  1033 00000378 B480                    	mov ah, ERR_disk_timeout
  1034 0000037A F9                      .7: Error                     ; signal error
  1035 0000037B EB22                    	jmp .9
  1036                                  
  1037                                  .8:                           ; seek is done, check ST0 bits
  1038 0000037D F6063E0004              	test byte [fdc_drv_calib], 04h ; Seek End seen?
  1039 00000382 7512                    	jnz .okay
  1040                                  
  1041 00000384 F6064200C0              	test byte [fdc_ctrl_status], ST0_IC ; interrupt code
  1042 00000389 B484                    	mov ah, ERR_84
  1043 0000038B 75ED                    	jnz .7
  1044 0000038D F606420020              	test byte [fdc_ctrl_status], ST0_SE ; Seek End
  1045 00000392 B440                    	mov ah, ERR_seek_failed
  1046 00000394 74E4                    	jz .7
  1047                                  .okay:
  1048                                  
  1049                                  	%if 0
  1050                                  	; add settle time - - may not really be needed
  1051                                  	mov al, [fdc_motor_ticks]
  1052                                  	add al, 450 / 54
  1053                                  	xchg al, [fdc_motor_ticks]
  1054                                  .settle:
  1055                                  	cmp [fdc_motor_ticks], al
  1056                                  	ja .settle
  1057                                  	%else
  1058                                  	; add time for more revolutions if a seek occurs
  1059 00000396 2E8A4702                	cs mov al, [DTAB_turnoff_ticks + bx]
  1060 0000039A A24000                  	mov [fdc_motor_ticks], al
  1061                                  	%endif
  1062                                  
  1063 0000039D 30E4                    	Okay                         ; IC==00 and SE=1
  1064 0000039F C3                      	.9 ret
  1065                                  
  1066                                  	;
  1067                                  	; power on init
  1068                                  	;
  1069                                  	global @floppy_init
  1070                                  @floppy_init:
  1071 000003A0 B400                    	mov ah, 0                    ; fn00
  1072 000003A2 CD13                    	int 13h
  1073 000003A4 C3                      	ret
  1074                                  
  1075                                  
  1076                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1077                                  	; Function 00h Reset the Disk System
  1078                                  	; Used both at power on and after a serious error
  1079                                  	;
  1080                                  	; Enter with:
  1081                                  	; AH = 00h
  1082                                  	; DL = drive 0 or 1
  1083                                  	;
  1084                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1085                                  fn00:
  1086                                  
  1087 000003A5 B81700                  	mov ax, 0017h                ; LTM=1, MSK=0, PRI=7 (07h for LTM=0)
  1088 000003A8 BA3AFF                  	mov dx, fdc_int_control
  1089 000003AB EF                      	out dx, ax                   ; enable interrupt controller
  1090                                  
  1091 000003AC C606AD0020              	mov byte [wait12_count], 32  ; this is about the max.
  1092 000003B1 E8A7FD                  	call wait12                  ; wait 12 microseconds
  1093 000003B4 E89DFD                  	call get_msr                 ; set BASE mode
  1094 000003B7 E8A1FD                  	call wait12                  ; wait 12 microseconds
  1095                                  
  1096 000003BA C6063F0008              	mov byte [fdc_motor_LDOR], (MODE + RESET + DMAEN) ; set PC_AT mode
  1097 000003BF E887FF                  	call out_LDOR_mem
  1098 000003C2 E896FD                  	call wait12
  1099                                  
  1100                                  	%if 1
  1101                                  	;;; This read may not be necessary, unless Special Mode is set
  1102 000003C5 BA8504                  	mov dx, FDC_LDCR
  1103 000003C8 EC                      	in al, dx                    ; read a write - only register to latch Mode
  1104                                  	;;;;;
  1105                                  	%endif
  1106 000003C9 E8A0FD                  	call wait1000
  1107                                  
  1108 000003CC 800E3F000C              	or byte [fdc_motor_LDOR], (MODE + NO_RESET + DMAEN) ; remove the RESET
  1109 000003D1 E875FF                  	call out_LDOR_mem
  1110 000003D4 E884FD                  	call wait12
  1111                                  
  1112                                  	%if 0
  1113                                  	mov dx, FDC_LDCR
  1114                                  	mov al, FDC_HD               ; set for HD disks
  1115                                  	out dx, al
  1116                                  	%endif
  1117                                  
  1118                                  	; mov dx, DMA0 + DMACW
  1119                                  	; %if 1
  1120                                  	; mov ax, 4 ; set change bit
  1121                                  	; %else
  1122                                  	; in ax, dx
  1123                                  	; and ax, ~2 ; clear the stop bit
  1124                                  	; or ax, 4 ; set the change bit
  1125                                  	; %endif
  1126                                  	; out dx, ax
  1127                                  
  1128 000003D7 31C0                    	xor ax, ax
  1129 000003D9 A24000                  	mov [fdc_motor_ticks], al    ; Zero the timer tick counter
  1130 000003DC A28B00                  	mov [fdc_last_rate], al      ; force a specify command
  1131                                  
  1132 000003DF 8EC0                    	mov es, ax
  1133 000003E1 90                      	cnop
  1134 000003E2 26A37800                	es mov [1Eh * 4], ax
  1135 000003E6 26A37A00                	es mov [1Eh * 4 + 2], ax     ; Zap the parameter pointer
  1136                                  
  1137 000003EA C7069400FFFF            	mov word [fdc_cylinder], - 1 ; Specify & Recalibration needed
  1138                                  
  1139                                  	; now allow time for the polling interrupts
  1140 000003F0 B90100                  	mov cx, 102400>>16           ; 0.1 seconds
  1141 000003F3 31D2                    	xor dx, dx                   ; CX:DX is delay in usec
  1142 000003F5 B486                    	mov ah, 86h                  ; delay in microseconds
  1143 000003F7 CD15                    	int 15h
  1144                                  
  1145 000003F9 E82AFE                  	call input_result_from_fdc
  1146                                  
  1147 000003FC 30E4                    	Okay                         ; signal good execution
  1148 000003FE C3                      	ret                          ; end of FN00
  1149                                  
  1150                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1151                                  	; Function 08h Get Drive Parameters
  1152                                  	;
  1153                                  	; Enter with:
  1154                                  	; AH = 08h
  1155                                  	; DL = drive 0 or 1
  1156                                  	;
  1157                                  	; Return with:
  1158                                  	; Carry clear if no error
  1159                                  	; BL = drive type (2 or 4 for us)
  1160                                  	; CH = max cylinder number
  1161                                  	; CL = max sector number
  1162                                  	; DH = max head number
  1163                                  	; DL = number of drives
  1164                                  	; ES:DI = address of disk parameter table
  1165                                  	;
  1166                                  	; Carry set on error
  1167                                  	; AH = error code
  1168                                  	;
  1169                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1170                                  fn08:                         ; Get Drive Parameters
  1171 000003FF A01000                  	mov al, [equipment_flag]
  1172 00000402 B401                    	mov ah, 1
  1173 00000404 20C4                    	and ah, al                   ; any floppies at all?
  1174 00000406 7407                    	jz .2
  1175 00000408 C0C002                  	rol al, 2                    ; at least one
  1176 0000040B 2403                    	and al, 3
  1177 0000040D 00C4                    	add ah, al                   ; 1..4
  1178                                  .2:
  1179 0000040F 88660A                  	mov [offset_DL + bp], ah     ; return # of drives
  1180 00000412 E8D701                  	call check_DL
  1181 00000415 7221                    	jc .err_no_drive
  1182 00000417 E8E901                  	call get_disk_type
  1183 0000041A 884608                  	mov [offset_BL + bp], al     ; return BL = disk type
  1184 0000041D E8F201                  	call get_media
  1185 00000420 2E8A670B                	cs mov ah, [DTAB_max_cylinder + bx]
  1186 00000424 2E8A4704                	cs mov al, [DTAB_EOT_nsect + bx]
  1187 00000428 89460C                  	mov [offset_CX + bp], ax     ; return CYL | SECT in CX
  1188 0000042B C6460B01                	mov byte [offset_DH + bp], 1 ; head max. always 1
  1189 0000042F 8C4E12                  	mov [offset_ES + bp], cs     ; return ES param table
  1190 00000432 895E00                  	mov [offset_DI + bp], bx     ; return DI param table
  1191                                  
  1192 00000435 30E4                    	xor ah, ah                   ; no error
  1193 00000437 C3                      	ret
  1194                                  
  1195                                  .err_no_drive:
  1196 00000438 B401                    	mov ah, ERR_invalid_command  ; error if no floppies
  1197 0000043A C3                      	ret                          ; DL is still zero !!!
  1198                                  
  1199                                  
  1200                                  
  1201                                  
  1202                                  
  1203                                  
  1204                                  	%if 0
  1205                                  	; validate the READ / WRITE CHS, SC parameters
  1206                                  	; Enter with DI pointing at the type table
  1207                                  	;
  1208                                  	; Carry clear if okay
  1209                                  	; Carry set if invalid
  1210                                  	; AX & all other registers are preserved
  1211                                  validate_call:
  1212                                  	push ax
  1213                                  
  1214                                  	cs cmp ch, [DTAB_max_cyl + di]
  1215                                  	jnbe .7
  1216                                  	cs mov ah, [DI_heads + di]
  1217                                  	sub ah, dh
  1218                                  	jbe .7
  1219                                  	cs mov al, [DTAB_EOT_nsect + di]
  1220                                  	dec cl                       ; base sectors at 0
  1221                                  	cmp cl, al
  1222                                  	jnc .6                       ; JNC = JNB = JAE
  1223                                  	mul ah
  1224                                  	; AX is 1 or 2 * sectors
  1225                                  	sub al, cl
  1226                                  	; AL is the maximum number of sectors we can transfer
  1227                                  	cmp al, [offset_AX + bp]     ; compare to sector count
  1228                                  .6: inc cl                    ; back to sectors from 1
  1229                                  	jnc .8                       ; JAE = JNB = JNC
  1230                                  .7: stc
  1231                                  .8: pop ax                    ;
  1232                                  	ret
  1233                                  	%endif
  1234                                  
  1235                                  
  1236                                  
  1237                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1238                                  	; Function 02h Read Sectors
  1239                                  	; Function 03h Write Sectors
  1240                                  	; Function 04h Verify Sectors
  1241                                  	;
  1242                                  	; Enter with:
  1243                                  	; AH = 02h (read)
  1244                                  	; AH = 03h (write)
  1245                                  	; AH = 04h (verify)
  1246                                  	; AL = number of sectors to transfer
  1247                                  	; CH = cylinder number
  1248                                  	; CL = sector number
  1249                                  	; DH = head number
  1250                                  	; DL = drive 0 or 1
  1251                                  	; ES:BX = buffer to read into or write from
  1252                                  	;
  1253                                  	; Return with:
  1254                                  	; Carry clear if no error
  1255                                  	; AH = 0
  1256                                  	; AL = number of sectors transferred
  1257                                  	;
  1258                                  	; Carry set on error
  1259                                  	; AH = error code
  1260                                  	;
  1261                                  	; All other registers are preserved.
  1262                                  	;
  1263                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1264                                  	;
  1265                                  	; Stack variables
  1266                                  	;
  1267                                  	rwv_return equ - 2           ; offset from BP
  1268                                  	rwv_dma equ rwv_return - 2
  1269                                  	rwv_xfer equ rwv_dma - 2
  1270                                  	rwv_cmd equ rwv_xfer - 9
  1271                                  	rwv_AL equ rwv_cmd - 1
  1272                                  	rwv_stack equ - rwv_AL
  1273                                  
  1274                                  fn02:                         ; READ
  1275 0000043B B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1276 0000043D BB[EB06]                	mov bx, xfer_read_sector
  1277 00000440 EB0C                    	jmp rwv_common
  1278                                  
  1279                                  	%define EXTRA 0
  1280                                  fn03:                         ; WRITE
  1281                                  	%if EXTRA
  1282                                  	cmp al, 1
  1283                                  	jbe .10
  1284                                  
  1285                                  	mov bx, [offset_BX + bp]     ; restore BX
  1286                                  	mov [offset_AH + bp], al     ; use return code as counter
  1287                                  
  1288                                  .1: mov ax, 0301h             ; write 1 sector
  1289                                  	int 13h
  1290                                  	jc .5
  1291                                  
  1292                                  	inc cl                       ; increment sector number
  1293                                  	add bx, 200h                 ; increment transfer address
  1294                                  	dec byte [offset_AH + bp]
  1295                                  	jnz .1
  1296                                  
  1297                                  	Okay                         ; all went Okay
  1298                                  	ret
  1299                                  
  1300                                  	; process error return
  1301                                  	; AH = error code
  1302                                  .5: mov al, [offset_AL + bp]  ; sectors requested
  1303                                  	sub al, [offset_AH + bp]     ; sectors remaining
  1304                                  	mov [offset_AL + bp], al     ; set sectors transferred
  1305                                  	Error
  1306                                  	ret
  1307                                  
  1308                                  .10:
  1309                                  	%endif
  1310 00000442 B4C5                    	mov ah, (CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1311 00000444 BB[3D07]                	mov bx, xfer_write_sector
  1312 00000447 EB05                    	jmp rwv_common
  1313                                  
  1314                                  fn04:                         ; VERIFY
  1315 00000449 B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1316 0000044B BB[3D07]                	mov bx, xfer_verify_sector
  1317                                  	;;; jmp rwv_common
  1318                                  
  1319                                  	; Common code to READ, WRITE, and VERIFY
  1320                                  rwv_common:
  1321 0000044E 57                      	push di                      ; dma control register
  1322 0000044F 53                      	push bx                      ; transfer function
  1323 00000450 83EC08                  	sub sp, rwv_stack - 8        ; 4 words in stack by pushes or Call
  1324 00000453 50                      	push ax                      ; including this push
  1325                                  
  1326 00000454 E89501                  	call check_DL                ; sets DI
  1327 00000457 B401                    	mov ah, ERR_invalid_command
  1328 00000459 7271                    	jc .exit
  1329                                  
  1330 0000045B E8A501                  	call get_disk_type
  1331 0000045E E8B101                  	call get_media               ; get media pointer to CS:BX
  1332 00000461 E8BA01                  	call set_media_pointer       ; set up Int 1Eh
  1333 00000464 E82A02                  	call motor_on                ; use DI to start motor
  1334 00000467 E83603                  	call Seek                    ; use CH to seek to track
  1335                                  	; recalibrate is possible
  1336 0000046A 7260                    	jc .exit                     ; AH is error code
  1337                                  
  1338 0000046C E86D02                  	call make_head_unit          ; AL is next byte
  1339                                  
  1340 0000046F 571E06                  	pushm es, ds, di
  1341 00000472 8D7EF2                  	lea di, [rwv_cmd + 1 + bp]   ; SS override not needed
  1342 00000475 8D7703                  	lea si, [DTAB_N_param + bx]
  1343 00000478 160E                    	pushm cs, ss
  1344 0000047A 1F900790                	popm ds, es
  1345 0000047E AA                      	stosb                        ; store head unit in cmd stream
  1346 0000047F 88E8                    	mov al, ch                   ; cylinder
  1347 00000481 AA                      	stosb
  1348 00000482 88F0                    	mov al, dh                   ; head
  1349 00000484 AA                      	stosb
  1350 00000485 88C8                    	mov al, cl                   ; sector (R)
  1351 00000487 AA                      	stosb
  1352 00000488 AC                      	lodsb                        ; get N
  1353 00000489 88C1                    	mov cl, al
  1354 0000048B AA                      	stosb                        ; store N
  1355 0000048C A4                      	movsb                        ; EOT
  1356 0000048D A4                      	movsb                        ; GPL
  1357 0000048E A4                      	movsb                        ; DTL = FF
  1358 0000048F 8D76F1                  	lea si, [rwv_cmd + bp]       ; get command start
  1359 00000492 07901F905F              	popm es, ds, di
  1360                                  
  1361 00000497 B88000                  	mov ax, 128                  ; minimum sector size
  1362 0000049A F666F0                  	mul byte [rwv_AL + bp]       ; times number of sectors to transfer
  1363 0000049D D3E0                    	shl ax, cl                   ; shift by N_param
  1364 0000049F 89C1                    	mov cx, ax                   ; CX is byte count of transfer
  1365                                  
  1366 000004A1 53                      	pushm bx                     ; save DTAB pointer
  1367                                  
  1368 000004A2 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1369 000004A5 8CC3                    	mov bx, es                   ; segment to AX
  1370 000004A7 89DA                    	mov dx, bx                   ; and to DX
  1371 000004A9 C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1372 000004AC C1E204                  	shl dx, 4                    ; high part of offset from segment
  1373 000004AF 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1374 000004B1 83D300                  	adc bx, 0                    ; and carry into the high bits
  1375                                  
  1376 000004B4 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1377                                  
  1378                                  .marker:
  1379                                  	; BX:AX transfer 20 - bit address in memory
  1380                                  	; CX transfer byte count
  1381                                  	; DX:SI pointer to 9 - byte FDC command
  1382                                  	;
  1383 000004B6 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1384                                  
  1385 000004BB FF56FA                  	call near [rwv_xfer + bp]    ;call specific transfer function
  1386                                  
  1387                                  
  1388                                  	%if SOFT_DEBUG
  1389 000004BE 5250                    	pushm ax, dx
  1390 000004C0 BA3006                  	mov dx, FRONT_PANEL_LED
  1391 000004C3 B009                    	mov al, 09h
  1392 000004C5 EE                      	out dx, al
  1393 000004C6 585A                    	popm ax, dx
  1394                                  	%endif
  1395                                  
  1396                                  
  1397 000004C8 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1398                                  	;;; jc .exit ; AH is set to error code
  1399                                  
  1400 000004C9 E8DB03                  	call Check_RW_Status         ; get final return code
  1401                                  
  1402                                  .exit:
  1403 000004CC 8D66FE                  	lea sp, [rwv_return + bp]
  1404 000004CF C3                      	ret
  1405                                  
  1406                                  	%if SOFT_DEBUG
  1407                                  	end_rwv equ $
  1408                                  	%endif
  1409                                  
  1410                                  
  1411                                  
  1412                                  	; Format stack layout
  1413                                  	fmt_return equ - 2           ; return from fn05 call
  1414                                  	fmt_dma equ fmt_return - 2
  1415                                  	fmt_cmd equ fmt_dma - 6
  1416                                  	fmt_stack equ - fmt_cmd      ; stack size
  1417                                  
  1418                                  	%if fmt_dma != rwv_dma
  1419                                  	%error "fmt_dma != rwv_dma"
  1420                                  	%endif
  1421                                  
  1422                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1423                                  	; Function 05h Format a Track
  1424                                  	;
  1425                                  	; Precede with call to Function 18h (or 17h) to set the disk type
  1426                                  	;
  1427                                  	; Enter with:
  1428                                  	; AH = 05h
  1429                                  	; CH = cylinder number
  1430                                  	; DH = head number
  1431                                  	; DL = drive 0 or 1
  1432                                  	; ES:BX = segment / offset of address field list (C / H / R / N)
  1433                                  	;
  1434                                  	; Return with:
  1435                                  	; Carry clear if no error
  1436                                  	; AH = 0
  1437                                  	;
  1438                                  	; Carry set on error
  1439                                  	; AH = error code
  1440                                  	;
  1441                                  	; All other registers are preserved.
  1442                                  	;
  1443                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1444                                  fn05:
  1445 000004D0 83EC0A                  	sub sp, fmt_stack            ; allocate stack space
  1446                                  
  1447 000004D3 E81601                  	call check_DL                ; sets DI
  1448 000004D6 B401                    	mov ah, ERR_invalid_command
  1449 000004D8 7272                    	jc .exit
  1450                                  
  1451 000004DA 06                      	pushm es                     ; save ES
  1452 000004DB 6A00                    	push 0
  1453 000004DD 0790                    	popm es
  1454 000004DF 8CCB                    	mov bx, cs                   ; get CS segment
  1455 000004E1 263B1E7A00              	es cmp bx, [1Eh * 4 + 2]     ; check segment is CS
  1456 000004E6 7564                    	jne .exit                    ; (will restore stack)
  1457                                  
  1458 000004E8 268B1E7800              	es mov bx, [1Eh * 4]         ; get CS:BX as disk param table pointer
  1459 000004ED 0790                    	popm es                      ; restore Stack
  1460                                  
  1461 000004EF E89F01                  	call motor_on                ; use DI to start motor
  1462                                  
  1463 000004F2 E8AB02                  	call Seek                    ; use CH to seek to track
  1464                                  	; recalibrate is possible
  1465 000004F5 7255                    	jc .exit                     ; AH is error code
  1466                                  
  1467 000004F7 E8E201                  	call make_head_unit          ; AL is next byte
  1468 000004FA 88C4                    	mov ah, al                   ; save head / unit in AH
  1469                                  
  1470 000004FC 571E06                  	pushm es, ds, di
  1471                                  
  1472 000004FF 160E                    	pushm cs, ss
  1473 00000501 1F900790                	popm ds, es
  1474 00000505 8D7EF6                  	lea di, [bp + fmt_cmd]
  1475 00000508 8D7703                  	lea si, [bx + DTAB_N_param]
  1476                                  
  1477 0000050B B00D                    	mov al, CMD_FORMAT_A_TRACK
  1478 0000050D 803C00                  	cmp byte [si], 0             ; is N==0
  1479 00000510 7402                    	je .2
  1480 00000512 0C40                    	or al, CMD_MF                ; MFM recording
  1481                                  .2:
  1482 00000514 AB                      	stosw                        ; AH=head / unit, AL=format cmd
  1483 00000515 A4                      	movsb                        ; set N
  1484 00000516 AC                      	lodsb                        ; get SC
  1485 00000517 88C1                    	mov cl, al                   ; save SC in AL
  1486 00000519 AA                      	stosb                        ; set SC
  1487 0000051A 83C602                  	add si, 2                    ; advance to GPL3
  1488 0000051D A5                      	movsw                        ; set GPL3 and Fill
  1489                                  
  1490 0000051E 8D76F6                  	lea si, [bp + fmt_cmd]
  1491 00000521 07901F905F              	popm es, ds, di              ; restore regs
  1492                                  
  1493 00000526 30ED                    	xor ch, ch                   ; CX = sector count
  1494 00000528 C1E102                  	shl cx, 2                    ; CX = byte count of param table
  1495                                  
  1496 0000052B 53                      	pushm bx                     ; save DTAB pointer
  1497                                  
  1498 0000052C 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1499 0000052F 8CC3                    	mov bx, es                   ; segment to AX
  1500 00000531 89DA                    	mov dx, bx                   ; and to DX
  1501 00000533 C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1502 00000536 C1E204                  	shl dx, 4                    ; high part of offset from segment
  1503 00000539 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1504 0000053B 83D300                  	adc bx, 0                    ; and carry into the high bits
  1505                                  
  1506 0000053E 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1507                                  
  1508                                  	;.marker:
  1509                                  	; BX:AX transfer 20 - bit address in memory
  1510                                  	; CX transfer byte count
  1511                                  	; DX:SI pointer to 9 - byte FDC command
  1512                                  	;
  1513 00000540 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1514                                  
  1515 00000545 E8F501                  	call xfer_format_track       ; format the track
  1516                                  
  1517 00000548 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1518                                  	;;; jc .exit ; AH is set to error code
  1519                                  
  1520 00000549 E85B03                  	call Check_RW_Status         ; get final return code
  1521                                  
  1522                                  
  1523                                  .exit:
  1524 0000054C 8D66FE                  	lea sp, [rwv_return + bp]    ; restore stack location
  1525 0000054F C3                      	ret
  1526                                  
  1527                                  
  1528                                  
  1529                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1530                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1531                                  	global dma0_interrupt
  1532                                  dma0_interrupt:
  1533 00000550 1E5250                  	pushm ax, dx, ds
  1534                                  
  1535 00000553 6A40                    	push bios_data_seg
  1536 00000555 1F90                    	popm ds
  1537                                  
  1538                                  	;%if SOFT_DEBUG
  1539                                  	;or byte [fdc_drv_calib], 02h ;POST dma interrupt
  1540                                  	;%endif
  1541                                  
  1542                                  	;%if 0
  1543                                  	;mov dx, FDC_TC ; Terminal Count
  1544                                  	;in al, dx ; pulse the line
  1545                                  	;%endif
  1546                                  
  1547                                  	;%if 0
  1548                                  	;mov dx, DMA0 + DMACW ; DMA0 control word
  1549                                  	;in ax, dx
  1550                                  	;mov [dma0_cw], ax ; post the resulting CW
  1551                                  	;%endif
  1552                                  
  1553                                  	; signal EOI (End of Interrupt)
  1554 00000557 BA22FF                  	mov dx, PIC_EOI              ; EOI register
  1555 0000055A B80080                  	mov ax, EOI_NSPEC            ; non - specific
  1556 0000055D EF                      	out dx, ax                   ; signal it
  1557                                  
  1558 0000055E 585A1F90                	popm ax, dx, ds
  1559 00000562 CF                      	iret
  1560                                  
  1561                                  
  1562                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1563                                  	; Function 15h Get Disk Type
  1564                                  	;
  1565                                  	; Enter with:
  1566                                  	; AH = 15h
  1567                                  	; DL = drive 0 or 1
  1568                                  	;
  1569                                  	; Return with:
  1570                                  	; Carry clear if no error
  1571                                  	; AH = drive type code
  1572                                  	; 0 = no drive present
  1573                                  	; 1 = floppy without change line support
  1574                                  	; 2 = floppy with change line support
  1575                                  	; 3 = fixed disk
  1576                                  	;
  1577                                  	; Carry set on error
  1578                                  	; AH = error code
  1579                                  	;
  1580                                  	; All other registers are preserved.
  1581                                  	;
  1582                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1583                                  fn15:
  1584 00000563 30E4                    	xor ah, ah                   ; No drive present
  1585 00000565 E88400                  	call check_DL
  1586 00000568 7309                    	jnc .ok
  1587 0000056A 83FFFF                  	cmp di, - 1
  1588 0000056D 7503E90EFB              	je undefined                 ; DL is really bad
  1589 00000572 C3                      	ret                          ; AH=0, no drive present
  1590                                  	; carry will be cleared
  1591                                  .ok:
  1592 00000573 FEC4                    	inc ah                       ; drive ok, no change line support
  1593 00000575 F8                      	clc
  1594 00000576 E9D6FA                  	jmp exit_pops                ;
  1595                                  
  1596                                  
  1597                                  
  1598                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1599                                  	; Function 16h Get Disk Change Status
  1600                                  	;
  1601                                  	; Enter with:
  1602                                  	; AH = 16h
  1603                                  	; DL = drive 0 or 1
  1604                                  	;
  1605                                  	; Return with:
  1606                                  	; Carry clear
  1607                                  	; AH = 0 disk not changed
  1608                                  	;
  1609                                  	; Carry set
  1610                                  	; AH = 6 disk has been changed
  1611                                  	; 0 error
  1612                                  	;
  1613                                  	; All other registers are preserved.
  1614                                  	;
  1615                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1616                                  fn16:
  1617 00000579 E87000                  	call check_DL
  1618 0000057C 7303E9FFFA              	jc undefined
  1619                                  
  1620 00000581 89F8                    	mov ax, di                   ; AL = 0, 1 AH = 0
  1621                                  	; AH is now 0
  1622 00000583 FEC0                    	inc al                       ; AL = 1, 2
  1623 00000585 C0C004                  	rol al, 4                    ; AL = MOEN1 or MOEN2
  1624 00000588 84063F00                	test [fdc_motor_LDOR], al    ; test if motor running
  1625 0000058C 7502                    	jnz .on
  1626                                  
  1627 0000058E B406                    	mov ah, ERR_disk_removed     ; signal disk changed
  1628                                  .on:
  1629 00000590 C3                      	ret                          ; AH=6, Carry will be set
  1630                                  
  1631                                  
  1632                                  
  1633                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1634                                  	; Function 17h Set Disk Type for Format (PC - AT)
  1635                                  	;
  1636                                  	; Enter with:
  1637                                  	; AH = 17h
  1638                                  	; AL = 00h not used
  1639                                  	; 01h 160, 180, 320, or 360Kb diskette in 360kb drive
  1640                                  	; 02h 360Kb diskette in 1.2Mb drive
  1641                                  	; 03h 1.2Mb diskette in 1.2Mb drive
  1642                                  	; 04h 720Kb diskette in 720Kb drive
  1643                                  	; DL = drive number
  1644                                  	;
  1645                                  	; Return with:
  1646                                  	; AH = 0 success
  1647                                  	; Carry clear
  1648                                  	;
  1649                                  	; Carry set error
  1650                                  	; AH = error code
  1651                                  	;
  1652                                  	; note 1) This function is probably enhanced for the PS / 2 series to detect
  1653                                  	; 1.44 in 1.44 and 720k in 1.44.
  1654                                  	; 2) This function is not supported for floppy disks on the PC or XT.
  1655                                  	; 3) If the change line is active for the specified drive, it is reset.
  1656                                  	; 4) The BIOS sets the data rate for the specified drive and media type.
  1657                                  	; The rate is 250k / sec for double - density media and 500k / sec for high
  1658                                  	; density media. The proper hardware is required.
  1659                                  	; 5) This function is used by DOS <= 3.1
  1660                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1661                                  	;fn17:
  1662                                  	;;; ret
  1663                                  
  1664                                  
  1665                                  
  1666                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1667                                  	; Function 18h Set Media Type For Format (diskette) (AT, XT2, XT / 286, PS / 2)
  1668                                  	;
  1669                                  	; Enter with:
  1670                                  	; AH = 18h
  1671                                  	; CH = max. cylinder number (80 or 40 minus 1)
  1672                                  	; CL = number of sectors (9, 15, 18)
  1673                                  	; DL = drive number
  1674                                  	;
  1675                                  	; Return with:
  1676                                  	; Carry clear - - no errors
  1677                                  	; AH = 00h if requested combination supported
  1678                                  	; ES:DI pointer to 13 - byte parameter table
  1679                                  	;
  1680                                  	; Carry set - - error
  1681                                  	; AH = 01h if function not available
  1682                                  	; 0Ch if not suppported or drive type unknown
  1683                                  	; 80h if there is no media in the drive
  1684                                  	;
  1685                                  	; note 1) A floppy disk must be present in the drive.
  1686                                  	; 2) This function should be called prior to formatting a disk with Int 13h
  1687                                  	; Fn 05h so the BIOS can set the correct data rate for the media.
  1688                                  	; 3) If the change line is active for the specified drive, it is reset.
  1689                                  	; 4) This function is used by DOS >= 3.2
  1690                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1691                                  fn18:
  1692 00000591 E85800                  	call check_DL                ; check validity of drive no.
  1693 00000594 7303E9E7FA              	jc undefined
  1694                                  
  1695 00000599 E86700                  	call get_disk_type           ; get disk type to AL
  1696 0000059C 3C0B                    	cmp al, L_table
  1697 0000059E 7327                    	jnb .alt
  1698 000005A0 88C3                    	mov bl, al
  1699 000005A2 30FF                    	xor bh, bh
  1700 000005A4 D1E3                    	shl bx, 1
  1701 000005A6 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1702 000005AB 85DB                    	test bx, bx
  1703 000005AD 743A                    	jz .errC
  1704 000005AF 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1705 000005B3 7512                    	jne .alt                     ; try alternate
  1706 000005B5 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1707 000005B9 750C                    	jne .alt
  1708                                  .found:
  1709 000005BB E86000                  	call set_media_pointer
  1710 000005BE 895E00                  	mov [offset_DI + bp], bx
  1711 000005C1 8C4E12                  	mov [offset_ES + bp], cs     ; return in ES:DI
  1712 000005C4 30E4                    	xor ah, ah
  1713 000005C6 C3                      	ret
  1714                                  
  1715                                  .alt:
  1716 000005C7 E84000                  	call get_disk_alt_type       ; get disk type to AL
  1717 000005CA 3C0B                    	cmp al, L_table
  1718 000005CC 731B                    	jnb .errC
  1719 000005CE 88C3                    	mov bl, al
  1720 000005D0 30FF                    	xor bh, bh
  1721 000005D2 D1E3                    	shl bx, 1
  1722 000005D4 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1723 000005D9 85DB                    	test bx, bx
  1724 000005DB 740C                    	jz .errC
  1725 000005DD 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1726 000005E1 7506                    	jne .errC                    ; no match?
  1727 000005E3 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1728 000005E7 74D2                    	je .found
  1729                                  
  1730 000005E9 B40C                    .errC: mov ah, ERR_media_type_not_found
  1731 000005EB C3                      	ret
  1732                                  
  1733                                  
  1734                                  
  1735                                  
  1736                                  
  1737                                  	check cpu_xtal - 0FFh
  1738                                  
  1739                                  
  1740                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1741                                  	; check_DL - - check for valid disk #
  1742                                  	;
  1743                                  	; Return:
  1744                                  	; DI = 0 or 1 if DL is valid floppy
  1745                                  	; Carry clear
  1746                                  	;
  1747                                  	; DI not valid if DL is invalid
  1748                                  	; Carry set
  1749                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1750                                  check_DL:
  1751 000005EC BFFFFF                  	mov di, - 1                  ; invalid DI
  1752 000005EF 80FA02                  	cmp dl, FLOPPY_MAX
  1753 000005F2 730D                    	jnb .err
  1754 000005F4 89D7                    	mov di, dx
  1755 000005F6 83E701                  	and di, FLOPPY_MAX - 1       ; clear the carry
  1756 000005F9 F685F8000F              	test byte [fdc_type + di], 0Fh ; drive present?
  1757 000005FE 7401                    	jz .err
  1758 00000600 C3                      	ret                          ; carry is clear
  1759                                  
  1760 00000601 F9                      .err: stc
  1761 00000602 C3                      	ret
  1762                                  
  1763                                  
  1764                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1765                                  	; get_disk_type
  1766                                  	;
  1767                                  	; Enter with:
  1768                                  	; DI = drive no.
  1769                                  	;
  1770                                  	; Return with:
  1771                                  	; AL = drive type (0..4)
  1772                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1773                                  get_disk_type:
  1774 00000603 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1775 00000607 240F                    	and al, 0Fh                  ; mask low nibble
  1776 00000609 C3                      	ret
  1777                                  
  1778                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1779                                  	; get_disk_alt_type
  1780                                  	;
  1781                                  	; Enter with:
  1782                                  	; DI = drive no.
  1783                                  	;
  1784                                  	; Return with:
  1785                                  	; AL = drive type (0..4)
  1786                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1787                                  get_disk_alt_type:
  1788 0000060A 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1789 0000060E C0E804                  	shr al, 4
  1790 00000611 C3                      	ret
  1791                                  
  1792                                  
  1793                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1794                                  	; get_media
  1795                                  	;
  1796                                  	; Call with:
  1797                                  	; AL = disk type
  1798                                  	;
  1799                                  	; Return with:
  1800                                  	; CS:BX pointer to 13 - byte disk media table
  1801                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1802                                  get_media:
  1803 00000612 88C3                    	mov bl, al
  1804 00000614 30FF                    	xor bh, bh
  1805 00000616 D1E3                    	shl bx, 1
  1806 00000618 2E8B9F[B500]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1807 0000061D C3                      	ret
  1808                                  
  1809                                  
  1810                                  
  1811                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1812                                  	; set_media_pointer
  1813                                  	;
  1814                                  	; Call with:
  1815                                  	; CS:BX pointer to 13 - byte disk media table
  1816                                  	; DS BIOS data area pointer
  1817                                  	;
  1818                                  	; Return with:
  1819                                  	; CS:BX pointer to 13 - byte disk media table
  1820                                  	; Int 1Eh floppy media pointer set
  1821                                  	;
  1822                                  	; Carry Set = new media pointer (needed Specify command)
  1823                                  	; Carry Clear = same media pointer (Specify not needed)
  1824                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1825                                  set_media_pointer:
  1826 0000061E 0651                    	pushm cx, es                 ; save for later
  1827 00000620 6A00                    	push 0                       ; address interrupt vectors
  1828 00000622 07                      	pop es                       ; * *
  1829 00000623 8CC9                    	mov cx, cs
  1830 00000625 26391E7800              	es cmp word [1Eh * 4], bx
  1831 0000062A 7508                    	jne .diff
  1832 0000062C 26390E7A00              	es cmp word [1Eh * 4 + 2], cx ; segment
  1833 00000631 F8                      	clc
  1834 00000632 7411                    	jz .same
  1835                                  .diff:
  1836 00000634 26891E7800              	es mov word [1Eh * 4], bx    ; offset
  1837 00000639 26890E7A00              	es mov word [1Eh * 4 + 2], cx ; segment
  1838 0000063E 8EC1                    	mov es, cx
  1839 00000640 90                      	cnop
  1840 00000641 E80500                  	call Specify                 ; ES:BX is table pointer
  1841 00000644 F9                      	stc
  1842                                  .same:
  1843 00000645 590790                  	popm cx, es                  ; restore DS
  1844 00000648 C3                      	ret
  1845                                  
  1846                                  
  1847                                  
  1848                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1849                                  	; Specify issue specify command to FDC
  1850                                  	;
  1851                                  	; Call with:
  1852                                  	; ES:BX pointer to 13 - byte disk table
  1853                                  	; DS BIOS data area pointer
  1854                                  	;
  1855                                  	; Return with:
  1856                                  	; Nothing
  1857                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1858                                  Specify:
  1859 00000649 56525350                	pushm ax, bx, dx, si
  1860 0000064D 83EC04                  	sub sp, 4                    ; allocate 4 bytes for command
  1861 00000650 89E6                    	mov si, sp
  1862                                  
  1863 00000652 268A470C                	es mov al, [DTAB_control + bx] ; clock bits
  1864 00000656 C0C002                  	rol al, 2
  1865 00000659 BA8504                  	mov dx, FDC_LDCR             ; Control Register
  1866 0000065C EE                      	out dx, al
  1867                                  
  1868 0000065D B20C                    	mov dl, 12                   ; 12 usec delay = T time
  1869 0000065F 08C0                    	or al, al                    ; test for hi (00) or lo (80) data rate
  1870 00000661 7502                    	jnz .3
  1871 00000663 D0EA                    	shr dl, 1                    ; crystal has factor of 2 already
  1872                                  .3:
  1873 00000665 A0FF00                  	mov al, [cpu_xtal]           ; 2x clock frequency
  1874 00000668 F6E2                    	mul dl                       ; AX = 2xClock * T or 2xclock * T / 2 (80 or 00)
  1875 0000066A 83E82C                  	sub ax, 44                   ; overhead CPU clocks
  1876 0000066D B214                    	mov dl, 20                   ; loop clock count
  1877 0000066F F6F2                    	div dl
  1878 00000671 FEC0                    	inc al                       ; for good measure
  1879 00000673 A2AD00                  	mov [wait12_count], al       ; save count
  1880                                  
  1881 00000676 36C60403                	ss mov byte [si], CMD_SPECIFY
  1882 0000067A 268B07                  	es mov ax, [DTAB_specify + bx] ; get two specify bytes
  1883 0000067D 36894401                	ss mov word [si + 1], ax
  1884 00000681 8CD2                    	mov dx, ss
  1885 00000683 B90300                  	mov cx, 3                    ; length of command = 3
  1886 00000686 E873FB                  	call output_cmd_to_fdc
  1887 00000689 83C404                  	add sp, 4
  1888 0000068C 585B5A5E                	popm ax, bx, dx, si
  1889 00000690 C3                      	ret
  1890                                  
  1891                                  
  1892                                  
  1893                                  
  1894                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1895                                  	; motor_on Start the drive motor & wait
  1896                                  	;
  1897                                  	; Call with:
  1898                                  	; DI = drive to start (0, 1)
  1899                                  	; CS:BX = drive parameter table pointer
  1900                                  	;
  1901                                  	; Return with:
  1902                                  	; motor is running and startup delay has been taken
  1903                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1904                                  	global motor_on
  1905                                  motor_on:
  1906 00000691 525150                  	pushm ax, cx, dx
  1907 00000694 89F8                    	mov ax, di                   ; drive # to AL
  1908 00000696 0401                    	add al, MOEN1>>4             ; form MOENx >> 4
  1909 00000698 C0E004                  	shl al, 4                    ; form MOENx bitmask
  1910 0000069B 88C4                    	mov ah, al                   ; MOENx - > AH
  1911 0000069D 01F8                    	add ax, di                   ; MOENx + DSELx - > AL
  1912                                  
  1913 0000069F B1B6                    	mov cl, 182                  ;10 seconds
  1914 000006A1 880E4000                	mov byte [fdc_motor_ticks], cl ; set long timer = 10 seconds
  1915                                  
  1916 000006A5 84263F00                	test byte [fdc_motor_LDOR], ah ; motor already on?
  1917 000006A9 88C5                    	mov ch, al
  1918 000006AB 750F                    	jnz .its_on
  1919                                  
  1920                                  	; motor is not running
  1921 000006AD 2E8B470A                	cs mov ax, [DTAB_startup + bx] ; get startup delay in 1 / 8 seconds
  1922 000006B1 98                      	cbw
  1923 000006B2 6BC07D                  	imul ax, 125                 ; * 125 ms
  1924 000006B5 B236                    	mov dl, 54
  1925 000006B7 F6F2                    	div dl                       ; divided by 54ms / tick
  1926 000006B9 40                      	inc ax                       ; one more tick for good measure
  1927 000006BA 28C1                    	sub cl, al                   ; CL is tick to wait for
  1928                                  
  1929                                  	; if motor was already running, then CL has not been changed
  1930                                  	; Do the select
  1931                                  .its_on:
  1932 000006BC 322E3F00                	xor ch, [fdc_motor_LDOR]     ; set selected bits
  1933 000006C0 80E531                  	and ch, (MOEN_MASK | DSEL_MASK)
  1934 000006C3 302E3F00                	xor [fdc_motor_LDOR], ch
  1935 000006C7 E87FFC                  	call out_LDOR_mem            ; Motor Starts here, or continues
  1936                                  
  1937 000006CA 380E4000                .wait: cmp [fdc_motor_ticks], cl ; has tick counter expired?
  1938 000006CE 77F9                    	ja .wait - 1
  1939                                  
  1940                                  	; reduce timer to turn - off delay time
  1941 000006D0 2E8A4F02                	cs mov cl, [DTAB_turnoff_ticks + bx] ; 2 seconds
  1942 000006D4 880E4000                	mov [fdc_motor_ticks], cl
  1943                                  
  1944 000006D8 58595A                  	popm ax, cx, dx
  1945 000006DB C3                      	ret
  1946                                  
  1947                                  
  1948                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1949                                  	; make_head_unit
  1950                                  	;
  1951                                  	; Enter with:
  1952                                  	; DH = head number
  1953                                  	; DI = unit number
  1954                                  	;
  1955                                  	; Return with:
  1956                                  	; AL = 0000 0huu
  1957                                  	; Carry clear
  1958                                  	;
  1959                                  	; Carry is set on error
  1960                                  	;
  1961                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1962                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1963                                  make_head_unit:
  1964 000006DC 88F0                    	mov al, dh                   ; head number to AL
  1965 000006DE A8FE                    	test al, ~1                  ; check for head 0 or 1
  1966 000006E0 F9                      	stc                          ; set to signal error
  1967 000006E1 7507                    	jnz .err
  1968 000006E3 2401                    	and al, 1                    ; defensive programming
  1969 000006E5 C0E002                  	shl al, 2                    ; shift H to position
  1970 000006E8 09F8                    	or ax, di                    ; clear the carry
  1971 000006EA C3                      .err: ret
  1972                                  
  1973                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1974                                  	; xfer_read_sector
  1975                                  	;
  1976                                  	; Call with:
  1977                                  	; BX:AX transfer address in memory
  1978                                  	; CX transfer byte count
  1979                                  	; DX:SI pointer to 9 - byte FDC command
  1980                                  	;
  1981                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1982                                  xfer_read_sector:
  1983 000006EB 061E56525153            	pushm bx, cx, dx, si, ds, es
  1984                                  
  1985 000006F1 51                      	push cx
  1986 000006F2 B90900                  	mov cx, 9                    ; 9 - byte FDC command
  1987 000006F5 E804FB                  	call output_cmd_to_fdc
  1988 000006F8 59                      	pop cx
  1989                                  
  1990 000006F9 89C6                    	mov si, ax
  1991 000006FB 8EC3                    	mov es, bx                   ; DS:SI is now the destination
  1992                                  
  1993                                  .1:
  1994 000006FD E854FA                  	call get_msr                 ; get status
  1995                                  
  1996 00000700 A880                    	test al, 0b10000000
  1997 00000702 75F9                    	jnz .1                       ; FDC IS NOT READY, WAIT FOR IT
  1998                                  
  1999 00000704 A820                    	test al, 0b00100000
  2000 00000706 7411                    	jz .timeout                  ; EXECUTION MODE? NO, ERROR
  2001                                  
  2002 00000708 E842FA                  	call get_data
  2003 0000070B 268A4401                	es mov al, [si + 1]          ; record byte of data
  2004 0000070F E2EC                    	loop .1
  2005                                  
  2006 00000711 BA8204                  	mov dx, FDC_TC
  2007 00000714 EC                      	in al, dx
  2008 00000715 30E4                    	Okay
  2009 00000717 EB03                    	jmp .99
  2010                                  
  2011                                  .timeout:
  2012 00000719 B485                    	mov ah, ERR_85
  2013 0000071B F9                      	Error
  2014                                  .99:
  2015 0000071C 5B595A5E1F900790        	popm bx, cx, dx, si, ds, es
  2016 00000724 C3                      	ret
  2017                                  
  2018                                  
  2019                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2020                                  	; wait_operation_complete ; wait for disk operation
  2021                                  	; ; to post a "complete" status
  2022                                  	; Call with:
  2023                                  	; DS = BIOS data area segment
  2024                                  	;
  2025                                  	; Return with:
  2026                                  	; CY = 0 success
  2027                                  	; CY = 1 timed out, AH=error code
  2028                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2029                                  wait_operation_complete:
  2030 00000725 F6063E0001              .1: test byte [fdc_drv_calib], 01h ; FDC interrupt posted "complete"?
  2031 0000072A 7509                    	jnz .okay
  2032 0000072C 803E400000              	cmp byte [fdc_motor_ticks], 0
  2033 00000731 75F2                    	jne .1
  2034 00000733 EB04                    	jmp .timeout
  2035                                  
  2036 00000735 30E4                    .okay: Okay
  2037 00000737 EB03                    	jmp .99
  2038                                  
  2039                                  .timeout:
  2040 00000739 B488                    	mov ah, ERR_88               ; mark timeout
  2041 0000073B F9                      	Error
  2042 0000073C C3                      .99: ret
  2043                                  
  2044                                  
  2045                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2046                                  	; xfer_write_sector
  2047                                  	; xfer_format_track (only command count is different)
  2048                                  	;
  2049                                  	; Call with:
  2050                                  	; BX:AX transfer address in memory
  2051                                  	; CX transfer byte count
  2052                                  	; DX:SI pointer to 9 - byte FDC command
  2053                                  	;
  2054                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2055                                  xfer_format_track:
  2056                                  xfer_write_sector:
  2057                                  	; push dx
  2058                                  
  2059                                  	; ; BX:AX is the transfer source address
  2060                                  	; mov dx, DMA0 + DMASPL ; set low source address
  2061                                  	; call dma_outd
  2062                                  
  2063                                  	; xor bx, bx
  2064                                  	; mov ax, FDC_DACK
  2065                                  
  2066                                  	; ; BX:AX is the transfer destination port
  2067                                  	; mov dx, DMA0 + DMADPL ; set low destination port
  2068                                  	; call dma_outd
  2069                                  
  2070                                  	; mov ax, cx ; total byte count
  2071                                  	; out dx, ax ; set terminal count
  2072                                  
  2073                                  	; mov ax, [rwv_dma + bp] ; get Control register
  2074                                  	; mov dx, DMA0 + DMACW
  2075                                  	; out dx, ax ; starts the DMA
  2076                                  
  2077                                  	; pop dx ; reset DX:SI command pointer
  2078                                  	;
  2079                                  	; mov cx, 9 ; 9 - byte FDC command
  2080                                  	; ss test byte [si], 01000b ; test for FORMAT command
  2081                                  	; jz .4
  2082                                  	; mov cx, 6 ; it is FORMAT
  2083                                  	;.4:
  2084                                  	; call output_cmd_to_fdc
  2085                                  
  2086                                  
  2087                                  	; mov bx, DMA0 + DMADPL ; Destination to be updated
  2088                                  	; mov cx, FDC_DACK_TC
  2089                                  
  2090                                  	; jmp xfer_common_wait
  2091                                  
  2092                                  
  2093                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2094                                  	; xfer_verify_sector
  2095                                  	;
  2096                                  	; Call with:
  2097                                  	; BX:AX transfer address in memory
  2098                                  	; CX transfer byte count
  2099                                  	; DX:SI pointer to 9 - byte FDC command
  2100                                  	;
  2101                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2102                                  xfer_verify_sector:
  2103                                  	; push dx
  2104                                  	;
  2105                                  	; xor bx, bx ; BX:AX is transfer address
  2106                                  	; mov ax, (bios_data_seg<<4) + fdc_ctrl_status
  2107                                  	;
  2108                                  	; ; BX:AX is the transfer destination address
  2109                                  	; mov dx, DMA0 + DMADPL ; set low destination
  2110                                  	; call dma_outd
  2111                                  	;
  2112                                  	; mov ax, cx ; total byte count
  2113                                  	; out dx, ax ; set terminal count
  2114                                  	;
  2115                                  	; xor bx, bx
  2116                                  	; mov ax, FDC_DACK
  2117                                  	; ; BX:AX is the transfer source port
  2118                                  	; mov dx, DMA0 + DMASPL ; set low source pointer
  2119                                  	; call dma_outd
  2120                                  	;
  2121                                  	; mov ax, [rwv_dma + bp] ; get Control register
  2122                                  	; mov dx, DMA0 + DMACW
  2123                                  	; out dx, ax ; starts the DMA
  2124                                  	;
  2125                                  	; pop dx ; reset DX:SI command pointer
  2126                                  	;
  2127                                  	; mov cx, 9 ; 9 - byte FDC command
  2128                                  	; call output_cmd_to_fdc
  2129                                  	;
  2130                                  	;
  2131                                  	; mov bx, DMA0 + DMASPL
  2132                                  	; mov cx, FDC_DACK_TC
  2133                                  	;
  2134                                  	; jmp xfer_common_wait
  2135                                  
  2136                                  
  2137                                  
  2138                                  
  2139                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2140                                  	; recalibrate
  2141                                  	;
  2142                                  	; Enter with:
  2143                                  	; DI = drive number
  2144                                  	; CS:BX = parameter area pointer
  2145                                  	; DS = BIOS data area pointer
  2146                                  	;
  2147                                  	; Return with:
  2148                                  	; Carry = 0 - - okay
  2149                                  	;
  2150                                  	; Carry = 1 - - error
  2151                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2152                                  recalibrate:
  2153 0000073D 565251                  	pushm cx, dx, si
  2154                                  
  2155 00000740 E811FB                  	call CHECKINT
  2156 00000743 3CFF                    	cmp  al, 0FFh
  2157 00000745 7453                    	jz   .9
  2158                                  
  2159                                  
  2160 00000747 E847FF                  	call motor_on
  2161                                  
  2162                                  ;	%if SOFT_DEBUG & DUMP
  2163                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2164                                  ;	mov al, ah                   ; save AH in AL
  2165                                  ;	lahf                         ; get flags
  2166                                  ;	mov bh, 12h
  2167                                  ;	mov bl, [fdc_cylinder + di]
  2168                                  ;	push bx
  2169                                  ;	push cs                      ; far pointer to ...
  2170                                  ;	push fnseek                  ; format
  2171                                  ;	call _cprintf
  2172                                  ;	add sp, 6
  2173                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2174                                  ;	%endif
  2175                                  
  2176 0000074A 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts
  2177                                  
  2178 0000074F B001                    	mov al, ST0_US               ; mask to 2 drives
  2179 00000751 21F8                    	and ax, di                   ; unit number to AL
  2180 00000753 86C4                    	xchg al, ah                  ; AH is second byte of command
  2181 00000755 B007                    	mov al, CMD_RECALIBRATE
  2182 00000757 50                      	push ax                      ; push 2 byte command
  2183 00000758 89E6                    	mov si, sp                   ; form command pointer
  2184 0000075A 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2185 0000075C B90200                  	mov cx, 2
  2186 0000075F E89AFA                  	call output_cmd_to_fdc       ; output the command
  2187 00000762 7231                    	jc .7
  2188                                  
  2189                                  ;	%if SOFT_DEBUG & DUMP
  2190                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2191                                  ;	mov al, ah                   ; save AH in AL
  2192                                  ;	lahf                         ; get flags
  2193                                  ;	mov bh, 13h
  2194                                  ;	mov bl, [fdc_cylinder + di]
  2195                                  ;	push bx
  2196                                  ;	push cs                      ; far pointer to ...
  2197                                  ;	push fnseek                  ; format
  2198                                  ;	call _cprintf
  2199                                  ;	add sp, 6
  2200                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2201                                  ;	%endif
  2202                                  
  2203 00000764 E8BEFF                  	call wait_operation_complete
  2204 00000767 722C                    	jc .7
  2205                                  
  2206                                  ;	%if SOFT_DEBUG & DUMP
  2207                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2208                                  ;	mov al, ah                   ; save AH in AL
  2209                                  ;	lahf                         ; get flags
  2210                                  ;	mov bh, 14h
  2211                                  ;	mov bl, [fdc_cylinder + di]
  2212                                  ;	push bx
  2213                                  ;	push cs                      ; far pointer to ...
  2214                                  ;	push fnseek                  ; format
  2215                                  ;	call _cprintf
  2216                                  ;	add sp, 6
  2217                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2218                                  ;	%endif
  2219                                  ;
  2220 00000769 E8FBFB                  	call fdc_wait_seek_done
  2221 0000076C 7227                    	jc .7
  2222                                  
  2223                                  ;	%if SOFT_DEBUG & DUMP
  2224                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2225                                  ;	mov al, ah                   ; save AH in AL
  2226                                  ;	lahf                         ; get flags
  2227                                  ;	mov bh, 15h
  2228                                  ;	mov bl, [fdc_cylinder + di]
  2229                                  ;	push bx
  2230                                  ;	push cs                      ; far pointer to ...
  2231                                  ;	push fnseek                  ; format
  2232                                  ;	call _cprintf
  2233                                  ;	add sp, 6
  2234                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2235                                  ;	%endif
  2236                                  
  2237 0000076E 58                      	pop ax                       ; get unit # to AH
  2238 0000076F B004                    	mov al, CMD_SENSE_DRIVE_STATUS
  2239 00000771 50                      	push ax                      ; push 2 byte command again
  2240 00000772 B90200                  	mov cx, 2
  2241 00000775 89E6                    	mov si, sp
  2242 00000777 8CD2                    	mov dx, ss                   ; DX:SI points at the 2 byte command
  2243 00000779 E880FA                  	call output_cmd_to_fdc
  2244 0000077C 7217                    	jc .7
  2245                                  
  2246                                  ;	%if SOFT_DEBUG & DUMP
  2247                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2248                                  ;	mov al, ah                   ; save AH in AL
  2249                                  ;	lahf                         ; get flags
  2250                                  ;	mov bh, 16h
  2251                                  ;	mov bl, [fdc_cylinder + di]
  2252                                  ;	push bx
  2253                                  ;	push cs                      ; far pointer to ...
  2254                                  ;	push fnseek                  ; format
  2255                                  ;	call _cprintf
  2256                                  ;	add sp, 6
  2257                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2258                                  ;	%endif
  2259                                  
  2260 0000077E E86BFA                  	call input_byte_from_fdc     ; get ST3
  2261 00000781 7212                    	jc .7
  2262                                  
  2263                                  ;	%if SOFT_DEBUG & DUMP
  2264                                  ;	pushm f                      ;, ax, bx, cx, dx, es
  2265                                  ;	mov al, ah                   ; save AH in AL
  2266                                  ;	lahf                         ; get flags
  2267                                  ;	mov bh, 17h
  2268                                  ;	mov bl, [fdc_cylinder + di]
  2269                                  ;	push bx
  2270                                  ;	push cs                      ; far pointer to ...
  2271                                  ;	push fnseek                  ; format
  2272                                  ;	call _cprintf
  2273                                  ;	add sp, 6
  2274                                  ;	popm f                       ;, ax, bx, cx, dx, es
  2275                                  ;	%endif
  2276                                  
  2277 00000783 88859000                	mov [fdc_disk_state + di], al ; save ST3 for drive
  2278 00000787 B487                    	mov ah, ERR_87               ; not on track 0
  2279 00000789 A810                    	test al, ST3_TR00
  2280 0000078B F9                      	Error                        ; signal error
  2281 0000078C 7407                    	jz .7                        ; Not on Track 00, C=1 error
  2282                                  
  2283 0000078E C685940000              	mov byte [fdc_cylinder + di], 0 ; set present cylinder
  2284                                  
  2285                                  
  2286 00000793 30E4                    	Okay                         ;
  2287                                  
  2288 00000795 5E                      .7: pop si                    ; Command is still in the stack
  2289 00000796 595A5E                  	popm cx, dx, si              ; restore
  2290 00000799 C3                      	ret
  2291                                  .9:
  2292 0000079A F9                      	Error                        ; signal error
  2293 0000079B 5E                      	pop si                    ; Command is still in the stack
  2294 0000079C 595A5E                  	popm cx, dx, si              ; restore
  2295 0000079F C3                      	ret
  2296                                  
  2297                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2298                                  	; Seek seek to proper cylinder
  2299                                  	;
  2300                                  	; Call with:
  2301                                  	; CH = cylinder to which to position heads
  2302                                  	; CS:BX = disk parameter area
  2303                                  	; DI = unit number
  2304                                  	; DS = BIOS data area pointer
  2305                                  	;
  2306                                  	; Return with:
  2307                                  	; Carry = 0 success
  2308                                  	;
  2309                                  	; Carry = 1 error
  2310                                  	;
  2311                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2312                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2313                                  Seek:
  2314 000007A0 565251                  	pushm cx, dx, si
  2315                                  
  2316                                  	; check for a recalibration needed
  2317 000007A3 8A859400                	mov al, [fdc_cylinder + di]  ; get present cylinder (0FFh forces recalibrate)
  2318 000007A7 2E3A470B                	cs cmp al, [DTAB_max_cylinder + bx] ; compare to maximum
  2319 000007AB 7627                    	jbe .no_recal
  2320                                  
  2321 000007AD BE0200                  	mov si, 2                    ; two recalibrates max.
  2322                                  
  2323                                  .rerecal:
  2324                                  	%if SOFT_DEBUG & DUMP
  2325 000007B0 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2326 000007B1 88E0                    	mov al, ah                   ; save AH in AL
  2327 000007B3 9F                      	lahf                         ; get flags
  2328 000007B4 B701                    	mov bh, 01h
  2329 000007B6 8A9D9400                	mov bl, [fdc_cylinder + di]
  2330 000007BA 53                      	push bx
  2331 000007BB 0E                      	push cs                      ; far pointer to ...
  2332 000007BC 68[B709]                	push fnseek                  ; format
  2333 000007BF E8(0000)                	call _cprintf
  2334 000007C2 83C406                  	add sp, 6
  2335 000007C5 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2336                                  	%endif
  2337                                  
  2338 000007C6 E874FF                  	call recalibrate
  2339 000007C9 7309                    	jnc .no_recal
  2340 000007CB 4E                      	dec si
  2341 000007CC F9                      	Error
  2342 000007CD 7503E9CC00              	jz .exit                     ; two have failed
  2343 000007D2 EBDC                    	jmp .rerecal                 ; try again
  2344                                  
  2345                                  .no_recal:
  2346                                  
  2347                                  	%if SOFT_DEBUG & DUMP
  2348 000007D4 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2349 000007D5 88E0                    	mov al, ah                   ; save AH in AL
  2350 000007D7 9F                      	lahf                         ; get flags
  2351 000007D8 B702                    	mov bh, 02h
  2352 000007DA 8A9D9400                	mov bl, [fdc_cylinder + di]
  2353 000007DE 53                      	push bx
  2354 000007DF 0E                      	push cs                      ; far pointer to ...
  2355 000007E0 68[B709]                	push fnseek                  ; format
  2356 000007E3 E8(0000)                	call _cprintf
  2357 000007E6 83C406                  	add sp, 6
  2358 000007E9 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2359                                  	%endif
  2360                                  
  2361 000007EA 3AAD9400                	cmp ch, [fdc_cylinder + di]  ; sought : present cylinder
  2362 000007EE 7503E9A900              	je .okay
  2363                                  
  2364                                  	; we are not on the cylinder we want
  2365                                  
  2366 000007F3 2E3A6F0B                	cs cmp ch, [DTAB_max_cylinder + bx] ; validate cylinder number
  2367 000007F7 7603E9A600              	ja .invalid
  2368                                  
  2369                                  .valid:
  2370                                  
  2371                                  	%if SOFT_DEBUG & DUMP
  2372 000007FC 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2373 000007FD 88E0                    	mov al, ah                   ; save AH in AL
  2374 000007FF 9F                      	lahf                         ; get flags
  2375 00000800 B703                    	mov bh, 03h
  2376 00000802 8A9D9400                	mov bl, [fdc_cylinder + di]
  2377 00000806 53                      	push bx
  2378 00000807 0E                      	push cs                      ; far pointer to ...
  2379 00000808 68[B709]                	push fnseek                  ; format
  2380 0000080B E8(0000)                	call _cprintf
  2381 0000080E 83C406                  	add sp, 6
  2382 00000811 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2383                                  	%endif
  2384                                  
  2385 00000812 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts
  2386                                  
  2387 00000817 86CD                    	xchg cl, ch                  ; cylinder to CL
  2388 00000819 51                      	push cx                      ; CL = sought cylinder
  2389 0000081A E8BFFE                  	call make_head_unit
  2390                                  
  2391                                  	%if SOFT_DEBUG & DUMP
  2392 0000081D 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2393 0000081E 88E0                    	mov al, ah                   ; save AH in AL
  2394 00000820 9F                      	lahf                         ; get flags
  2395 00000821 B704                    	mov bh, 04h
  2396 00000823 8A9D9400                	mov bl, [fdc_cylinder + di]
  2397 00000827 53                      	push bx
  2398 00000828 0E                      	push cs                      ; far pointer to ...
  2399 00000829 68[B709]                	push fnseek                  ; format
  2400 0000082C E8(0000)                	call _cprintf
  2401 0000082F 83C406                  	add sp, 6
  2402 00000832 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2403                                  	%endif
  2404                                  
  2405 00000833 B40F                    	mov ah, CMD_SEEK             ; command byte
  2406 00000835 86C4                    	xchg al, ah                  ; command byte must be first in stack
  2407 00000837 50                      	push ax                      ; push 3 byte command
  2408 00000838 89E6                    	mov si, sp
  2409 0000083A 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2410 0000083C B90300                  	mov cx, 3                    ; 3 byte command
  2411 0000083F E8BAF9                  	call output_cmd_to_fdc
  2412                                  
  2413                                  	%if SOFT_DEBUG & DUMP
  2414 00000842 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2415 00000843 88E0                    	mov al, ah                   ; save AH in AL
  2416 00000845 9F                      	lahf                         ; get flags
  2417 00000846 B705                    	mov bh, 05h
  2418 00000848 8A9D9400                	mov bl, [fdc_cylinder + di]
  2419 0000084C 53                      	push bx
  2420 0000084D 0E                      	push cs                      ; far pointer to ...
  2421 0000084E 68[B709]                	push fnseek                  ; format
  2422 00000851 E8(0000)                	call _cprintf
  2423 00000854 83C406                  	add sp, 6
  2424 00000857 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2425                                  	%endif
  2426                                  
  2427 00000858 5E59                    	popm si, cx                  ; fix stack; get CL=seek to cylinder
  2428 0000085A 86CD                    	xchg cl, ch                  ; CH=seek to cylinder
  2429 0000085C 7240                    	jc .exit
  2430                                  
  2431 0000085E E8C4FE                  	call wait_operation_complete
  2432 00000861 723B                    	jc .exit
  2433                                  
  2434                                  	%if SOFT_DEBUG & DUMP
  2435 00000863 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2436 00000864 88E0                    	mov al, ah                   ; save AH in AL
  2437 00000866 9F                      	lahf                         ; get flags
  2438 00000867 B706                    	mov bh, 06h
  2439 00000869 8A9D9400                	mov bl, [fdc_cylinder + di]
  2440 0000086D 53                      	push bx
  2441 0000086E 0E                      	push cs                      ; far pointer to ...
  2442 0000086F 68[B709]                	push fnseek                  ; format
  2443 00000872 E8(0000)                	call _cprintf
  2444 00000875 83C406                  	add sp, 6
  2445 00000878 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2446                                  	%endif
  2447                                  
  2448                                  
  2449                                  	;;; mov [fdc_cylinder + di], ch ; set new cylinder number
  2450                                  
  2451 00000879 E8EBFA                  	call fdc_wait_seek_done      ; AH=error code if C=1
  2452 0000087C 7220                    	jc .exit
  2453                                  
  2454                                  	%if SOFT_DEBUG & DUMP
  2455 0000087E 9C                      	pushm f                      ;, ax, bx, cx, dx, es
  2456 0000087F 88E0                    	mov al, ah                   ; save AH in AL
  2457 00000881 9F                      	lahf                         ; get flags
  2458 00000882 B707                    	mov bh, 07h
  2459 00000884 8A9D9400                	mov bl, [fdc_cylinder + di]
  2460 00000888 53                      	push bx
  2461 00000889 0E                      	push cs                      ; far pointer to ...
  2462 0000088A 68[B709]                	push fnseek                  ; format
  2463 0000088D E8(0000)                	call _cprintf
  2464 00000890 83C406                  	add sp, 6
  2465 00000893 9D                      	popm f                       ;, ax, bx, cx, dx, es
  2466                                  	%endif
  2467                                  
  2468                                  
  2469                                  	%if 0
  2470                                  	; probably have to skip the following during Format
  2471                                  	call read_track_id           ; just to be sure
  2472                                  	jc .exit
  2473                                  	%endif
  2474                                  
  2475 00000894 B440                    	mov ah, ERR_seek_failed
  2476 00000896 3AAD9400                	cmp ch, [fdc_cylinder + di]  ; PCN filled in
  2477 0000089A 7508                    	jne .err
  2478                                  	;;; mov ah, ERR_8A
  2479                                  	;;; cmp ch, [fdc_ctrl_status + 3] ; read cylinder number
  2480                                  	;;; jne .err
  2481                                  
  2482                                  
  2483                                  .okay:
  2484 0000089C 30E4                    	Okay
  2485                                  .exit:
  2486 0000089E 595A5E                  	popm cx, dx, si
  2487 000008A1 C3                      	ret
  2488                                  
  2489                                  .invalid:
  2490                                  	; error - - the cylinder requested is invalid for this drive
  2491 000008A2 B486                    	mov ah, ERR_86
  2492 000008A4 F9                      .err: Error
  2493 000008A5 EBF7                    	jmp .exit                    ; jump WAY out
  2494                                  
  2495                                  
  2496                                  
  2497                                  
  2498                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2499                                  	; Check_RW_Status check ST0 & ST1 error bits
  2500                                  	;
  2501                                  	; Call with:
  2502                                  	; CY = 0, 1 needs to be examined
  2503                                  	;
  2504                                  	; Return with:
  2505                                  	; CY = 0, AH = 0 no error detected
  2506                                  	;
  2507                                  	; CY = 1, AH = final error code error in status bits
  2508                                  	;
  2509                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2510                                  	global Check_RW_Status
  2511                                  Check_RW_Status:
  2512 000008A7 061E56525153            	pushm bx, cx, dx, si, ds, es
  2513                                  
  2514                                  	%if SOFT_DEBUG & DUMP
  2515 000008AD 86C4                    	xchg al, ah                  ; error code to AL
  2516 000008AF 9F                      	lahf                         ; flags to AH
  2517 000008B0 50                      	push ax
  2518                                  
  2519 000008B1 30E4                    	xor ah, ah                   ; zero hi - byte
  2520 000008B3 B90700                  	mov cx, 7
  2521 000008B6 BE4800                  	mov si, fdc_ctrl_status + 6  ; byte to start
  2522 000008B9 FD                      	.1 std
  2523 000008BA AC                      	lodsb
  2524 000008BB 50                      	push ax                      ; push argument
  2525 000008BC E2FB                    	loop .1
  2526 000008BE FC                      	cld
  2527 000008BF 0E                      	push cs
  2528 000008C0 68[1009]                	push fcrw
  2529 000008C3 E8(0000)                	call _cprintf
  2530 000008C6 83C412                  	add sp, 18
  2531                                  
  2532 000008C9 58                      	pop ax
  2533 000008CA 9E                      	sahf                         ; restore flags
  2534 000008CB 86C4                    	xchg al, ah                  ; restore error code to AH
  2535                                  	%endif
  2536                                  
  2537                                  	%if 1
  2538 000008CD 7309                    	jnc .no_err
  2539                                  
  2540 000008CF C6460E00                	mov byte [offset_AL + bp], 0 ; say nothing transferred
  2541                                  
  2542                                  	; Carry is set, what happened?
  2543 000008D3 80FC81                  	cmp ah, ERR_81               ; first of our new error codes
  2544                                  	;;;
  2545 000008D6 EB2E                    	jmp .error                   ; for now
  2546                                  	%endif
  2547                                  
  2548                                  
  2549                                  .no_err:
  2550 000008D8 8A264200                	mov ah, [fdc_ctrl_status]    ; get ST0 to AH
  2551 000008DC 88E0                    	mov al, ah                   ; retain copy in AL
  2552 000008DE 80E4C0                  	and ah, ST0_IC               ; check interrupt code
  2553 000008E1 7424                    	jz .exit                     ; Okay is set
  2554                                  
  2555 000008E3 B420                    	mov ah, ERR_controller_failure
  2556 000008E5 A810                    	test al, ST0_EC
  2557 000008E7 751D                    	jnz .error
  2558                                  
  2559 000008E9 A04300                  	mov al, [fdc_ctrl_status + 1] ; get ST1 to AL
  2560 000008EC B402                    	mov ah, ERR_address_mark_not_found
  2561 000008EE A801                    	test al, ST1_MA              ; test Missing Address mark
  2562 000008F0 7514                    	jnz .error
  2563                                  
  2564 000008F2 FEC4                    	inc ah                       ; Write Protect
  2565 000008F4 A802                    	test al, ST1_NW              ;
  2566 000008F6 750E                    	jnz .error
  2567                                  
  2568 000008F8 FEC4                    	inc ah                       ; Sector not Found
  2569 000008FA A804                    	test al, ST1_ND              ; No Data
  2570 000008FC 7508                    	jnz .error
  2571                                  
  2572 000008FE B410                    	mov ah, ERR_uncorrectable_CRC_error
  2573 00000900 A820                    	test al, ST1_DE
  2574 00000902 7502                    	jnz .error
  2575                                  
  2576 00000904 B48F                    	mov ah, ERR_unknown          ; may be in ST2
  2577                                  
  2578 00000906 F9                      .error: Error                 ; code is in AH
  2579                                  .exit:
  2580 00000907 5B595A5E1F900790        	popm bx, cx, dx, si, ds, es
  2581 0000090F C3                      	ret
  2582                                  
  2583                                  
  2584                                  	%if SOFT_DEBUG & DUMP
  2585 00000910 0A5257205354302025-     	fcrw db NL, "RW ST0 %02x ST1 %02x ST2 %02x C + %02x H + %02x S + %02x N %x", 0
  2585 00000919 303278205354312025-
  2585 00000922 303278205354322025-
  2585 0000092B 3032782043202B2025-
  2585 00000934 3032782048202B2025-
  2585 0000093D 3032782053202B2025-
  2585 00000946 303278204E20257800 
  2586 0000094F 0A5643204158202530-     	rwvc db NL, "VC AX %04x CHS %02x:%02x:%02x DL %02x ES:BX %04x:%04x", 0
  2586 00000958 347820434853202530-
  2586 00000961 32783A253032783A25-
  2586 0000096A 30327820444C202530-
  2586 00000973 32782045533A425820-
  2586 0000097C 253034783A25303478-
  2586 00000985 00                 
  2587 00000986 0A5245542041482025-     	fnret db NL, "RET AH %02x CY %d CMD %02x %02x", NL, 0
  2587 0000098F 303278204359202564-
  2587 00000998 20434D442025303278-
  2587 000009A1 20253032780A00     
  2588 000009A8 0A4C444F52203D2025-     	fnldor db NL, "LDOR = %02x ", NL, 0
  2588 000009B1 303278200A00       
  2589 000009B7 0A5345454B203D2025-     	fnseek db NL, "SEEK = %04x ", NL, 0
  2589 000009C0 303478200A00       
  2590 000009C6 0A4D5352203D202530-     	fnmsr db NL, "MSR = %04x ", NL, 0
  2590 000009CF 3478200A00         
  2591 000009D4 0A44494F203D202530-     	fndio db NL, "DIO = %04x ", NL, 0
  2591 000009DD 3478200A00         
  2592 000009E2 0A436865636B696E74-     	fncheckint db NL, "Checkint = %04x ", NL, 0
  2592 000009EB 203D2025303478200A-
  2592 000009F4 00                 
  2593                                  	%endif
  2594                                  
  2595                                  
  2596                                  
  2597                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2598                                  	; @enable / @disable Interrupt enable / disable
  2599                                  	;
  2600                                  	; On a @disable, increment the lock counter and CLI
  2601                                  	; On an @enable, decrement the lock counter and if it goes to zero, STI
  2602                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2603                                  	global @enable, @disable
  2604                                  @disable:
  2605 000009F5 1E50                    	pushm ax, ds
  2606 000009F7 9F                      	lahf                         ; save user flags
  2607 000009F8 6A40                    	push bios_data_seg           ; universal addressing
  2608 000009FA 1F90                    	popm ds
  2609 000009FC FA                      	cli                          ; guarantee locked operation
  2610 000009FD FE06AE00                	inc byte [lock_count]
  2611 00000A01 9E                      	sahf                         ; restore user flags
  2612 00000A02 581F90                  	popm ax, ds
  2613 00000A05 C3                      	ret
  2614                                  
  2615                                  @enable:
  2616 00000A06 1E50                    	pushm ax, ds
  2617 00000A08 9F                      	lahf                         ; save user flags
  2618 00000A09 6A40                    	push bios_data_seg
  2619 00000A0B 1F90                    	popm ds
  2620 00000A0D FE0EAE00                	dec byte [lock_count]        ; test the lock count
  2621 00000A11 7501                    	jnz .5
  2622 00000A13 FB                      	sti                          ; lock count went to zero, re - enable
  2623                                  .5:
  2624 00000A14 9E                      	sahf                         ; restore user flags
  2625 00000A15 581F90                  	popm ax, ds
  2626 00000A18 C3                      	ret
  2627                                  
  2628                                  
  2629                                  
  2630                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2631                                  	; read_track_id ; read address mark information
  2632                                  	;
  2633                                  	; Call with:
  2634                                  	; DS = BIOS data segment
  2635                                  	; DI = unit number
  2636                                  	; DH = head number
  2637                                  	;
  2638                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2639                                  read_track_id:
  2640 00000A19 525156                  	pushm si, cx, dx
  2641                                  
  2642 00000A1C C6063E0000              	mov byte [fdc_drv_calib], 0  ; clear interrupt flags
  2643                                  
  2644 00000A21 E8B8FC                  	call make_head_unit          ; head / un
  2645 00000A24 88C4                    	mov ah, al                   ; move to AH (second byte of command)
  2646 00000A26 B04A                    	mov al, CMD_READ_ID | CMD_MF
  2647 00000A28 50                      	push ax                      ; push the 2 - byte command
  2648 00000A29 89E6                    	mov si, sp
  2649 00000A2B 8CD2                    	mov dx, ss                   ; DX:SI points at command
  2650 00000A2D B90200                  	mov cx, 2                    ; 2 bytes to READ_ID
  2651 00000A30 E8C9F7                  	call output_cmd_to_fdc       ; issue the command
  2652 00000A33 58                      	pop ax                       ; discard word in stack
  2653                                  
  2654 00000A34 E8EEFC                  	call wait_operation_complete
  2655                                  
  2656 00000A37 5E595A                  	popm si, cx, dx
  2657 00000A3A C3                      	ret
