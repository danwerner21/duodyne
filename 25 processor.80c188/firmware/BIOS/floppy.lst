     1                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  	; floppy.asm - - WD37C65B floppy disk controller driver
     3                                  	; Version 2.0 - - Apr 2013, JRC
     4                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  	;
     6                                  	; This version is for assembly by NASM 0.98.39 or later
     7                                  	;
     8                                  	; Copyright (C) 2010 - 2013 John R. Coffman. All rights reserved.
     9                                  	; Provided for hobbyist use on the N8VEM SBC - 188 board.
    10                                  	;
    11                                  	; This program is free software: you can redistribute it and / or modify
    12                                  	; it under the terms of the GNU General Public License as published by
    13                                  	; the Free Software Foundation, either version 3 of the License, or
    14                                  	; (at your option) any later version.
    15                                  	;
    16                                  	; This program is distributed in the hope that it will be useful,
    17                                  	; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  	; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    19                                  	; GNU General Public License for more details.
    20                                  	;
    21                                  	; You should have received a copy of the GNU General Public License
    22                                  	; along with this program. If not, see <http: / / www.gnu.org / licenses / >.
    23                                  	;
    24                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    25                                  	%include "config.asm"
    26                              <1> ;/*
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; ANSI.CFG
    29                              <1> ;   Copied to CONFIG.ASM for general release.
    30                              <1> ;
    31                              <1> ;       Modify the parameters below to reflect your system
    32                              <1> ;
    33                              <1> ;
    34                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    35                              <1> ;
    36                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    37                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    38                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    39                              <1> ;
    40                              <1> ; Define the serial terminal that the Video BIOS must emulate
    41                              <1> ; Set one of the following to 1
    42                              <1> ; If you have no idea what to choose, set TTY to 1
    43                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    44                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    45                              <1> ANSI    equ     1       ; very smart, like a VT-100
    46                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    47                              <1> ; others may get added in the future
    48                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    49                              <1> ;
    50                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    51                              <1> ;UART_RATE	equ	0		; 1200
    52                              <1> ;UART_RATE	equ	1		; 2400
    53                              <1> ;UART_RATE	equ	2		; 4800
    54                              <1> UART_RATE	equ	3		; 9600
    55                              <1> ;UART_RATE	equ	4		; 19200
    56                              <1> ;UART_RATE	equ	5		; 38400
    57                              <1> ;UART_RATE	equ	6		; 57600
    58                              <1> ;UART_RATE	equ	7		; 115200
    59                              <1> 
    60                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    61                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    62                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    63                              <1> 						; but not ANSI
    64                              <1> ; Define the size of the ROM image on the system in Kilobytes
    65                              <1> ; It may be smaller than the actual EPROM in use.
    66                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    67                              <1> %ifndef ROM
    68                              <1> ROM             equ     32              ; 64 is the default
    69                              <1> %endif
    70                              <1> 
    71                              <1> ; Define the number of Wait States at which the ROM operates
    72                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    73                              <1> 
    74                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    75                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    76                              <1> RAM_DOS         equ     640
    77                              <1> 
    78                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    79                              <1> ; the default is 512 kilobytes
    80                              <1> RAM             equ     512             ; (512 is the default)
    81                              <1> 
    82                              <1> ; Define the number of Wait States at which the RAM operates
    83                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    84                              <1> 
    85                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    86                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    87                              <1> 
    88                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    89                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    90                              <1> 
    91                              <1> ; Define the time zone in which we build the Relocatable BIOS
    92                              <1> %ifndef TIMEZONE
    93                              <1> %define TIMEZONE "CST"
    94                              <1> %endif
    95                              <1> 
    96                              <1> ; Has the REDBUG debugger been loaded?
    97                              <1> %ifndef SOFT_DEBUG
    98                              <1> %define SOFT_DEBUG 0
    99                              <1> %endif
   100                              <1> 
   101                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   102                              <1> %ifndef TBASIC
   103                              <1> TBASIC          equ     1		; default is 1
   104                              <1> %endif
   105                              <1> 
   106                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   107                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   108                              <1> %ifndef FPEM
   109                              <1> FPEM            equ     1               ; default is 1
   110                              <1> %endif
   111                              <1> 
   112                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   113                              <1> ; or at locations 0280h..3FFh in low memory?
   114                              <1> %if SOFT_DEBUG
   115                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   116                              <1> %else
   117                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   118                              <1> %endif
   119                              <1> 
   120                              <1> ; Define the size of the EPROM that is to be installed on the system
   121                              <1> ; It may be larger than the actual ROM image to be generated.
   122                              <1> %ifndef CHIP
   123                              <1> CHIP            equ     64
   124                              <1> %endif
   125                              <1> 
   126                              <1> ; Define the UART oscillator speed
   127                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   128                              <1> 
   129                              <1> 
   130                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   131                              <1> ; end of the User configuration
   132                              <1> ;       Do Not modify anything below this point
   133                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   134                              <1> 
   135                              <1> ; Define existence of any uart chip
   136                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   137                              <1> startuplength   equ     512                     ; may be up to 1024
   138                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   139                              <1> highrom         equ     (ROM*400h)&0FFFFh
   140                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   141                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   142                              <1> 
   143                              <1> 
   144                              <1> %define ARG(n) [bp+2+(n)*2]
   145                              <1> 
   146                              <1> %macro  check   1.nolist
   147                              <1>  %if (%1)
   148                              <1>    %error Check Failure: %1
   149                              <1>  %endif
   150                              <1> %endm
   151                              <1> %macro  range   3.nolist
   152                              <1>  %if (%1)<(%2)
   153                              <1>    %error Out of Range: %1
   154                              <1>  %elif (%1)>(%3)
   155                              <1>    %error Out of Range: %1
   156                              <1>  %endif
   157                              <1> %endm
   158                              <1> _terminal equ UART
   159                              <1>  check   RAM_DOS&15
   160                              <1>  check   RAM&(RAM-1)
   161                              <1>  check   ROM&(ROM-1)
   162                              <1>  range   RAM,32,512
   163                              <1>  range   ROM,32,256
   164                              <1>  range   RAM_WS,0,3
   165                              <1>  range   ROM_WS,0,3
   166                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   167                              <1>  range   LCL_IO_WS,0,3
   168                              <1>  range   BUS_IO_WS,0,3
   169                              <1>  range   UART_OSC,500000,16000000
   170                              <1>  range   UART_RATE,0,7
   171                              <1>  range	 UART,0,1
   172                              <1>  range	 _terminal,1,2
   173                              <1> 
   174                              <1> %ifndef SOFT_DEBUG
   175                              <1> %define SOFT_DEBUG 0
   176                              <1> %endif
   177                              <1> 
   178                              <1> %ifndef TRACE
   179                              <1> %define TRACE 0
   180                              <1> %endif
   181                              <1> 
   182                              <1> %ifdef MAKE_OBJECT_FILE
   183                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   184                              <1>         export _ROMsize
   185                              <1>         export _CHIPsize
   186                              <1> _ROMsize        dw      ROM
   187                              <1> _CHIPsize       dw      CHIP
   188                              <1> %endif
   189                              <1> ; end of the Hardware configuration file
   190                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   191                              <1> ;*/
    26                                  	%include "cpuregs.asm"
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ; CPUREGS.ASM
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ; Updated for the Duodyne 80c188 SBC
    50                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    51                              <1> %include	"macros.inc"
    52                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <2> ; MACROS.INC  
    54                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <2> ;
    56                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    57                              <2> ;
    58                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    59                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    60                              <2> ;
    61                              <2> ; This program is free software: you can redistribute it and/or modify
    62                              <2> ; it under the terms of the GNU General Public License as published by
    63                              <2> ; the Free Software Foundation, either version 3 of the License, or
    64                              <2> ; (at your option) any later version.
    65                              <2> ;
    66                              <2> ; This program is distributed in the hope that it will be useful,
    67                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    68                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    69                              <2> ; GNU General Public License for more details.
    70                              <2> ;
    71                              <2> ; You should have received a copy of the GNU General Public License
    72                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    73                              <2> ;
    74                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    75                              <2> 
    76                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    77                              <2> ;
    78                              <2> ;
    79                              <2> %ifndef __MACROS_DEFINED_
    80                              <2> %define __MACROS_DEFINED_ 1
    81                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    82                              <2> ;
    83                              <2> ; some useful macros:
    84                              <2> ;
    85                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    86                              <2> ;
    87                              <2> 	cpu	186
    88                              <2> 
    89                              <2> %imacro setloc  1.nolist
    90                              <2>  times   (%1-($-$$)) db 0FFh
    91                              <2> %endm
    92                              <2> 
    93                              <2> %imacro db_lo   1
    94                              <2>  db (%1)&255
    95                              <2> %endm
    96                              <2> 
    97                              <2> %imacro cnop    0.nolist
    98                              <2> %if SOFT_DEBUG
    99                              <2>         nop
   100                              <2> %endif
   101                              <2> %endm
   102                              <2> 
   103                              <2> %imacro popm 1-*.nolist
   104                              <2> %rep %0
   105                              <2> %ifidni %1,ALL
   106                              <2>  popa
   107                              <2> %elifidni %1,F
   108                              <2>  popf
   109                              <2> %else
   110                              <2>  pop %1
   111                              <2> %ifidni %1,DS
   112                              <2>  cnop
   113                              <2> %elifidni %1,ES
   114                              <2>  cnop
   115                              <2> %endif
   116                              <2> %endif
   117                              <2> %rotate 1
   118                              <2> %endrep
   119                              <2> %endm
   120                              <2> 
   121                              <2> %imacro pushm 1-*.nolist
   122                              <2> %rep %0
   123                              <2> %rotate -1
   124                              <2> %ifidni %1,ALL
   125                              <2>  pusha
   126                              <2> %elifidni %1,F
   127                              <2>  pushf
   128                              <2> %else
   129                              <2>  push %1
   130                              <2> %endif
   131                              <2> %endrep
   132                              <2> %endm
   133                              <2> 
   134                              <2> ;
   135                              <2> ; added from the 386EX project
   136                              <2> ;
   137                              <2> 
   138                              <2> ; call arguments
   139                              <2> %define ARG(n) [bp+2+(n)*2]
   140                              <2> 
   141                              <2> ;
   142                              <2> ; format of the BYTE initialization table:  address, byte
   143                              <2> ;
   144                              <2> %imacro  binit 2
   145                              <2>         dw      %1
   146                              <2>         db      %2
   147                              <2> %endmacro
   148                              <2> ; end with DW -1
   149                              <2> 
   150                              <2> ;
   151                              <2> ; format of the WORD initialization table:  address, word
   152                              <2> ;
   153                              <2> %imacro  winit 2
   154                              <2>         dw      %1
   155                              <2>         dw      %2
   156                              <2> %endmacro
   157                              <2> ; end with DW -1
   158                              <2> 
   159                              <2> 
   160                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   161                              <2> %imacro get_bda	1.nolist
   162                              <2> 	push	0x0040
   163                              <2> 	pop	%1
   164                              <2> 	cnop
   165                              <2> %endm
   166                              <2> 
   167                              <2> 
   168                              <2> %endif
    52                              <1> 
    53                              <1> 	cpu     186
    54                              <1> ;
    55                              <1> ;
    56                              <1> ; IBM model byte -- must be less than a 286
    57                              <1> ;
    58                              <1> 
    59                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    60                              <1> SUBMODEL_BYTE		equ	00h	;  "
    61                              <1> 
    62                              <1> 
    63                              <1> ; 80188 peripheral control register block address
    64                              <1> CPU_CSCR	        equ	0FF00h
    65                              <1> 
    66                              <1> ; Compatible Mode registers
    67                              <1> 
    68                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    69                              <1> 
    70                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    71                              <1> 
    72                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    73                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    74                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    75                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    76                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    77                              <1> 
    78                              <1> ; Enhanced Mode registers
    79                              <1> 
    80                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    81                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    82                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    83                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    84                              <1> 
    85                              <1> 
    86                              <1> ; On-board internal peripheral equates
    87                              <1> ; Programmable Interrupt Controller
    88                              <1> PIC	        equ	CPU_CSCR+020H
    89                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    90                              <1> PIC_POLLR	equ	PIC+4
    91                              <1> PIC_POLLSR	equ	PIC+6
    92                              <1> PIC_IMASK	equ	PIC+8
    93                              <1> PIC_PMREG	equ	PIC+0AH
    94                              <1> PIC_SRVR	equ	PIC+0CH
    95                              <1> PIC_IRQR	equ	PIC+0EH
    96                              <1> PIC_IRQSR	equ	PIC+10H
    97                              <1> PIC_TCR	        equ	PIC+12H
    98                              <1> PIC_DMA0CR	equ	PIC+14H
    99                              <1> PIC_DMA1CR	equ	PIC+16H
   100                              <1> PIC_I0CON	equ	PIC+18H
   101                              <1> PIC_I1CON	equ	PIC+1AH
   102                              <1> PIC_I2CON	equ	PIC+1CH
   103                              <1> PIC_I3CON	equ	PIC+1EH
   104                              <1> 
   105                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   106                              <1> 
   107                              <1> ; Interrupt masks (Master Mode)
   108                              <1> ;
   109                              <1> mask_timer_all          equ     0001h
   110                              <1> mask_dma0               equ     0004h
   111                              <1> mask_dma1               equ     0008h
   112                              <1> mask_int0               equ     0010h
   113                              <1> mask_int1               equ     0020h
   114                              <1> mask_int2               equ     0040h
   115                              <1> mask_int3               equ     0080h
   116                              <1> 
   117                              <1> 
   118                              <1> 
   119                              <1> ; Timers
   120                              <1> TIM0	        equ	CPU_CSCR+050H
   121                              <1> TIM1	        equ	CPU_CSCR+058H
   122                              <1> TIM2	        equ	CPU_CSCR+060H
   123                              <1> 
   124                              <1> TCNT	        equ	0	; count register
   125                              <1> CMPA	        equ	2	; max count A
   126                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   127                              <1> TCON	        equ	6	; mode/control word
   128                              <1> 
   129                              <1> ; Timer control bits:
   130                              <1> tc_EN           equ     8000h   ; Enable bit
   131                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   132                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   133                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   134                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   135                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   136                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   137                              <1> tc_EXT          equ     0004h   ; External clock
   138                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   139                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   140                              <1> 
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> ; DMA
   145                              <1> DMA0	        equ	CPU_CSCR+0C0H
   146                              <1> DMA1	        equ	CPU_CSCR+0D0H
   147                              <1> DMASPL	        equ	0	; source pointer low
   148                              <1> DMASPU	        equ	2	; source pointer high
   149                              <1> DMADPL	        equ	4	; destination pointer low
   150                              <1> DMADPU	        equ	6	; destination pointer high
   151                              <1> DMATC	        equ	8	; terminal count
   152                              <1> DMACW	        equ	0AH	; control word
   153                              <1> 
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   159                              <1> ;
   160                              <1> ;       SBC-188 external devices
   161                              <1> ;
   162                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   163                              <1> 
   164                              <1> IO_BASE			equ	0400h
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> 
   172                              <1> uart_base               equ     IO_BASE+0280h
   173                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   174                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   175                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   176                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   177                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   178                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   179                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   180                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   181                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   182                              <1> uart_sr			equ	uart_base+7	;Scratch
   183                              <1> 
   184                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   185                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   186                              <1> 
   187                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   188                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> CTRL259		equ	IO_BASE+0238H
   191                              <1> ; LEDS are at addresses 0..3
   192                              <1> ; other control ports on 4..7
   193                              <1> LED0		equ	CTRL259+0
   194                              <1> LED1		equ	LED0+1
   195                              <1> LED2		equ	LED0+2
   196                              <1> LED3		equ	LED0+3
   197                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   198                              <1> ;unused		equ	CTRL259+5
   199                              <1> ;unused		equ	CTRL259+6
   200                              <1> ;unused		equ	CTRL259+7
   201                              <1> 
   202                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   206                              <1> 
   207                              <1> 
   208                              <1> 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; Floppy controller (Duodyne Disk IO)
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> FDC	        equ	IO_BASE+0080H
   213                              <1> FDC_MSR         equ     FDC
   214                              <1> FDC_DATA        equ     FDC+1
   215                              <1> FDC_TC	        equ	FDC+2
   216                              <1> FDC_RES	        equ	FDC+3
   217                              <1> FDC_LDCR	equ	FDC+5
   218                              <1> FDC_LDOR	equ	FDC+6
   219                              <1> FDC_DACK        equ	FDC+6
   220                              <1> FDC_DACK_TC     equ     FDC+7
   221                              <1> 
   222                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   223                              <1> ; Duodyne Multi IO
   224                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   225                              <1> CH376	        equ	IO_BASE+004EH
   226                              <1> ParPrinter      equ	IO_BASE+0048H
   227                              <1> DuoSerial       equ	IO_BASE+0070H
   228                              <1> MultiIo8242     equ	IO_BASE+004CH
   229                              <1> PrinterTimeout  equ 	020h
   230                              <1> 
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   233                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                              <1> RTC	equ	IO_BASE+0094H
   235                              <1> 
   236                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   237                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   238                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   239                              <1> PPI	        equ	IO_BASE+0088H
   240                              <1> 
   241                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   242                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   243                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   244                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   245                              <1> 
   246                              <1> portA           equ     PPI+0   ;
   247                              <1> portB           equ     PPI+1   ;
   248                              <1> portC           equ     PPI+2   ;
   249                              <1> 
   250                              <1> ; end CPUREGS.ASM
    27                                  	%include "equates.asm"
    28                              <1> ;========================================================================
    29                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    30                              <1> ;========================================================================
    31                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ;========================================================================
    52                              <1> 
    53                              <1>         global  FPEM_segment
    54                              <1> 
    55                              <1> 
    56                              <1> %include "segdef.asm"
    57                              <2> ;========================================================================
    58                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    59                              <2> ;========================================================================
    60                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    61                              <2> ;
    62                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    63                              <2> ;
    64                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    65                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    66                              <2> ;
    67                              <2> ; This program is free software: you can redistribute it and/or modify
    68                              <2> ; it under the terms of the GNU General Public License as published by
    69                              <2> ; the Free Software Foundation, either version 3 of the License, or
    70                              <2> ; (at your option) any later version.
    71                              <2> ;
    72                              <2> ; This program is distributed in the hope that it will be useful,
    73                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    74                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    75                              <2> ; GNU General Public License for more details.
    76                              <2> ;
    77                              <2> ; You should have received a copy of the GNU General Public License
    78                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    79                              <2> ;
    80                              <2> ;========================================================================
    81                              <2> 
    82                              <2> %ifndef __SEGDEF_
    83                              <2> %define __SEGDEF_
    84                              <2> 
    85                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    86                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    87                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    88                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    89                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    90                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    91                              <2> 
    92                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    93                              <2> 
    94                              <2> %endif
    95                              <2> 
    57                              <1> %include "ascii.asm"
    58                              <2> ; ascii.asm
    59                              <2> ;
    60                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    61                              <2> 
    62                              <2> NUL     equ     00h
    63                              <2> BEL     equ     (CTRL & 'G')
    64                              <2> BS      equ     08h		; ^H
    65                              <2> HT      equ     09h		; ^I
    66                              <2> LF	equ	0Ah		; ^J
    67                              <2> NL      equ     LF
    68                              <2> VT	equ	0Bh		; ^K
    69                              <2> FWD	equ	0Ch		; ^L
    70                              <2> CR	equ	0Dh
    71                              <2> XON     equ     (CTRL & 'Q')
    72                              <2> XOFF    equ     (CTRL & 'S')
    73                              <2> DC1     equ     XON
    74                              <2> DC3     equ     XOFF
    75                              <2> ESC     equ	1Bh
    76                              <2> 
    77                              <2> 
    58                              <1> 
    59                              <1> 
    60                              <1> ; POST error codes. Presently one byte but can expand to word.
    61                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    62                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    63                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    64                              <1> ER_FDC	equ	08h		; Bad FDC
    65                              <1> ER_UNK1	equ	10h		; {unassigned}
    66                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    67                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    68                              <1> ER_UNK2	equ	80h		; {unassigned}
    69                              <1> 
    70                              <1> 
    71                              <1> 
    72                              <1> ;; ************************ BIOS Data Segment ******************************
    73                              <1> ;; BIOS data segment - not all will  be used
    74                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    75                              <1> %include "bda.inc"
    76                              <2> ;/*======================================================================
    77                              <2> ; bda.inc -- BIOS data area definitions
    78                              <2> ;========================================================================
    79                              <2> ;   for the N8VEM SBC-188
    80                              <2> ;
    81                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    82                              <2> ;
    83                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    84                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    85                              <2> ;
    86                              <2> ; This program is free software: you can redistribute it and/or modify
    87                              <2> ; it under the terms of the GNU General Public License as published by
    88                              <2> ; the Free Software Foundation, either version 3 of the License, or
    89                              <2> ; (at your option) any later version.
    90                              <2> ;
    91                              <2> ; This program is distributed in the hope that it will be useful,
    92                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    93                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    94                              <2> ; GNU General Public License for more details.
    95                              <2> ;
    96                              <2> ; You should have received a copy of the GNU General Public License
    97                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    98                              <2> ;
    99                              <2> ;========================================================================
   100                              <2> 
   101                              <2> 			;*/ extern				/*
   102                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   103 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   104 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   105 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   106                              <2> ;	dw	?		; 40:10 	; Equipment present word
   107                              <2> ;  						;  = (1 iff floppies) *     1.
   108                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   109                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   110                              <2> ;  						;  + (init crt mode ) *    16.
   111                              <2> ;  						;  + (# of floppies ) *    64.
   112                              <2> ;  						;  + (# serial ports) *   512.
   113                              <2> ;  						;  + (1 iff toy port) *  4096.
   114                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   115                              <2> ;  						;  + (# parallel LPT) * 16384.
   116 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   117 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   118                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   119 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   120 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   121                              <2> ;;---------------[Keyboard data area]------------;
   122 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   123                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;
   124 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   125 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   126 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   127 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   128                              <2> kbd_buffer_last	equ	$	;*/				/*
   129                              <2> ;;---------------[Diskette data area]------------;
   130 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   131 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   132 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   133 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   134                              <2> ;				Floppy return code stat byte
   135                              <2> ;				;  1 = bad ic 765 command req.
   136                              <2> ;				;  2 = address mark not found
   137                              <2> ;				;  3 = write to protected disk
   138                              <2> ;				;  4 = sector not found
   139                              <2> ;				;  8 = data late (DMA overrun)
   140                              <2> ;				;  9 = DMA failed 64K page end
   141                              <2> ;				; 16 = bad CRC on floppy read
   142                              <2> ;				; 32 = bad NEC 765 controller
   143                              <2> ;				; 64 = seek operation failed
   144                              <2> ;				;128 = disk drive timed out
   145 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   146                              <2> ;;---------------[Video display area]------------;
   147 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   148                              <2> ;			 	; Current CRT mode  (software)
   149                              <2> ;				;  0 = 40 x 25 text (no color)
   150                              <2> ;				;  1 = 40 x 25 text (16 color)
   151                              <2> ;				;  2 = 80 x 25 text (no color)
   152                              <2> ;				;  3 = 80 x 25 text (16 color)
   153                              <2> ;				;  4 = 320 x 200 grafix 4 color
   154                              <2> ;				;  5 = 320 x 200 grafix 0 color
   155                              <2> ;				;  6 = 640 x 200 grafix 0 color
   156                              <2> ;				;  7 = 80 x 25 text (mono card)
   157 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   158 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   159 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   160 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   161 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   162 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   163 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   164 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   165 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   166                              <2> ;;---------------[Used to setup ROM]-------------;
   167 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   168 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   169                              <2> ;;---------------[Timer data area]---------------;
   170 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   171 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   172                              <2> ;;---------------[System data area]--------------;
   173 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   174 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   175                              <2> ;;---------------[Hard disk scratchpad]----------;
   176 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   177                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   178 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   179 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   180                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   181 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   182 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   183                              <2> ;;---------------[EGA stuff]---------------------;
   184 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   185                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   186 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   187 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   188 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   189 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   190 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   191                              <2> ;;---------------[Additional KBD flags]----------------;
   192 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   193 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   194                              <2> ;;---------------[RTC/timer1 data]---------------------;
   195 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   196 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   197 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h,
   198                              <2> ;;---------------[Cassette I/O stuff]------------------;
   199 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   200 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   201                              <2> ;									Post Acknowleged=00;
   202 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   203 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   204 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   205                              <2> ;
   206 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   207 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   208 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   209 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   210                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   211 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   212 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   213 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   214 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   215 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   216 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   217 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   218 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   219 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   220 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   221 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   222 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   223 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   224 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   225 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   226                              <2> ;
   227                              <2> ;
   228                              <2> 
   229 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   230                              <2> 
   231 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   232                              <2> 
   233 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   234 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   235                              <2> 
   236 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib
   237                              <2> 
   238 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   239                              <2> 
   240 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   241                              <2> 
   242 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz
   243                              <2> ;								   CPU clock is half of this
   244                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   245                              <2> ;
   246                              <2> ;  System configuration stuff below
   247                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   248                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   249                              <2> %if 0				;*/
   250                              <2> #define FIXED_DISK_MAX 4		/*
   251                              <2> %else
   252                              <2> %define FIXED_DISK_MAX 4
   253                              <2> %endif
   254                              <2> %if 0				;*/
   255                              <2> #define PPIDE_driver 1		/*
   256                              <2> %else
   257                              <2> %define PPIDE_driver 1
   258                              <2> %endif
   259                              <2> %if 0				;*/
   260                              <2> #define USB_driver 1		/*
   261                              <2> %else
   262                              <2> %define USB_driver 1
   263                              <2> %endif
   264                              <2> 				;*/
    76                              <1> 
    77                              <1> ;  this must be the same in EQUATES.H */
    78                              <1> %if SOFT_DEBUG
    79                              <1> %define NBREAK  8
    80                              <1> %endif
    81                              <1> 
    82                              <1> 
    83                              <1> %if 0
    84                              <1>         segment _TEXT
    85                              <1> ;; *************************************************************************
    86                              <1> 
    87                              <1> 
    88                              <1> 
    89                              <1> 
    90                              <1> ;; ************************ DOS Data Segment *******************************
    91                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    92                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    93                              <1> ;						;  1 if PrtSc xeroxing screen
    94                              <1> ;						;255 if PrtSc error in xerox
    95                              <1> ;						;  ...non-grafix PrtSc in bios
    96                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    97                              <1> ;						;  ...IBMBIO.COM buffers the
    98                              <1> ;						;  ...directory of the boot
    99                              <1> ;						;  ...device here at IPL time
   100                              <1> ;						;  ...when locating the guts
   101                              <1> ;						;  ...of the operating system
   102                              <1> ;						;  ...filename "IBMDOS.COM"
   103                              <1> ;dosdir	ends
   104                              <1> ;; *************************************************************************
   105                              <1> ;; ************************ DOS IPL Segment ********************************
   106                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   107                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   108                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   109                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   110                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   111                              <1> ;dosseg	ends					;			      !
   112                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   113                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   114                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   115                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   116                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   117                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   118                              <1> ;iplseg	ends
   119                              <1> 
   120                              <1> %endif
    28                                  
    29                                  	%define DUMP 0
    30                                  	%define DEBUG 0
    31                                  	%define SOFT_DEBUG 0
    32                                  	; sterilize SOFT_DEBUG for now
    33                                  	%if SOFT_DEBUG > 1
    34                                  	%undef SOFT_DEBUG
    35                                  	%define SOFT_DEBUG 1
    36                                  	%endif
    37                                  
    38                                  	global BIOS_call_13h
    39                                  	;; global Floppy_BIOS_call_13h_entry
    40                                  	global wait12
    41                                  	global @enable, @disable
    42                                  	%if SOFT_DEBUG
    43                                  	extern _cprintf
    44                                  	global undefined
    45                                  	global fn00, fn02, fn03, fn04
    46                                  	global get_msr
    47                                  	global get_data
    48                                  	global put_data
    49                                  	global check_DL
    50                                  	global get_disk_type
    51                                  	global get_media
    52                                  	global set_media_pointer
    53                                  	global rwv_common
    54                                  	global Seek, recalibrate, Specify
    55                                  	global rwv_common.marker
    56                                  	global end_rwv
    57                                  	global xfer_read_sector, xfer_write_sector, xfer_verify_sector
    58                                  	global xfer_format_track
    59                                  	global Check_RW_Status
    60                                  	%endif
    61                                  
    62                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                                  	; Error, Okay, Complete status conditions
    64                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    65                                  
    66                                  	%define Error stc
    67                                  	; test with:
    68                                  	; JC xxx (jump on error)
    69                                  	; JNC xxx (jump on no error)
    70                                  
    71                                  	%define Okay xor ah, ah
    72                                  	; test with:
    73                                  	; JZ xxx (jump okay)
    74                                  	; JNZ xxx (jump not okay)
    75                                  
    76                                  	%define Complete or ah, 3
    77                                  	; test with:
    78                                  	; JA xxx (jump complete AND no error)
    79                                  	; JNZ xxx (jump complete)
    80                                  	; JZ xxx (jump not complete)
    81                                  
    82                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                                  
    84                                  
    85                                  	; at most we use 2 floppies
    86                                  	%define FLOPPY_MAX 2
    87                                  
    88                                  	; there is some disagreement about whether ES:DI gets set
    89                                  	; for Floppy calls to "int 13h, function 8"
    90                                  	FN08_SET_ES_DI equ 1
    91                                  	;FN08_SET_ES_DI equ 0
    92                                  
    93                                  	; Define the three modes of operation of the WD37C65B floppy controller
    94                                  	%define BASE 0FFh
    95                                  	%define SPECIAL 80h
    96                                  	%define PC_AT 00h
    97                                  
    98                                  	; DMA watch threshhold
    99                                  	%define THRESHHOLD 12
   100                                  
   101                                  	; Define the mode in which the WD37C65B is operated
   102                                  	%define MODE PC_AT           ; This MUST NOT be changed
   103                                  
   104                                  	; specify bits in the Operations Register
   105                                  	%define DSEL1 00h
   106                                  	%define DSEL2 01h
   107                                  	%define DSEL_MASK (DSEL1|DSEL2)
   108                                  	%define NO_RESET 04h
   109                                  	%define RESET 00h
   110                                  	%define DMAEN 08h
   111                                  	%define MOEN1 10h
   112                                  	%define MOEN2 20h
   113                                  	%define MOEN_MASK (MOEN1|MOEN2)
   114                                  
   115                                  	%define TurnOn 8             ; used by all DSEL's
   116                                  
   117                                  	; the Motor turn - on delay in milliseconds
   118                                  	%define MOTOR_DELAY (TurnOn * 125)
   119                                  
   120                                  	; define the disk density clock rate selects
   121                                  	%define FDC_HD 00h
   122                                  	%define FDC_DD 02h
   123                                  
   124                                  	; The individual floppy disk status bits
   125                                  	%define FDC_DRIVE_PRESENT 1
   126                                  	%define FDC_DRIVE_READY 2
   127                                  
   128                                  
   129                                  	; define the MSR bits:
   130                                  	RQM equ 80h                  ; request for master
   131                                  	DIO equ 40h                  ; data IN=1, out=0
   132                                  	EXM equ 20h                  ; Execution phase in non - DMA mode
   133                                  	; this should NEVER be set
   134                                  	BUSY equ 10h                 ; Controller Busy
   135                                  	FD3 equ 08h                  ; DS3 is seeking
   136                                  	FD2 equ 04h                  ; DS2 is seeking
   137                                  	FD1 equ 02h                  ; DS1 is seeking
   138                                  	FD0 equ 01h                  ; DS0 is seeking
   139                                  
   140                                  	; MSR I / O status (in / out from CPU)
   141                                  	MSR_IN equ RQM | DIO
   142                                  	MSR_OUT equ RQM
   143                                  	MSR_MASK equ RQM | DIO
   144                                  
   145                                  	; This is the list of controller commands that we use
   146                                  
   147                                  	CMD_RECALIBRATE equ 7        ; 1 param byte (unit #)
   148                                  	; No result bytes
   149                                  	CMD_SENSE_INT_STATUS equ 8   ; No paramter bytes
   150                                  	; 2 result bytes
   151                                  	CMD_SENSE_DRIVE_STATUS equ 4 ; 1 param byte
   152                                  	; 1 result byte
   153                                  	CMD_SPECIFY equ 3            ; 2 parameter bytes
   154                                  	; No result bytes
   155                                  	CMD_SEEK equ 15              ; 2 parameter bytes
   156                                  	; No result bytes
   157                                  	CMD_READ_ID equ 10           ; param in cmd; 1 param byte
   158                                  	; 7 result bytes
   159                                  	CMD_READ_DATA equ 6          ; params in cmd; 8 param bytes
   160                                  	; 7 result bytes
   161                                  	CMD_WRITE_DATA equ 5         ; params in cmd; 8 param bytes
   162                                  	; 7 result bytes
   163                                  	CMD_READ_A_TRACK equ 2       ; params in cmd; 8 param bytes
   164                                  	; 7 result bytes
   165                                  	CMD_FORMAT_A_TRACK equ 13    ; params in cmd; 5 param bytes
   166                                  	; 7 result bytes
   167                                  	CMD_SCAN_EQUAL equ 11h       ; params in cmd; 8 param bytes
   168                                  	; 7 result bytes
   169                                  	CMD_SCAN_LOW_OR_EQUAL equ 19h ; params in cmd; 8 param bytes
   170                                  	; 7 result bytes
   171                                  	CMD_SCAN_HIGH_OR_EQUAL equ 1Dh ; params in cmd; 8 param bytes
   172                                  	; 7 result bytes
   173                                  
   174                                  
   175                                  	; define the extra bits in some command codes
   176                                  
   177                                  	CMD_MT equ 80h               ; Multi - track operation
   178                                  	CMD_MF equ 40h               ; MFM recording mode
   179                                  	CMD_SK equ 20h               ; skip deleted data mark
   180                                  
   181                                  
   182                                  
   183                                  	; define the ST3 status bits
   184                                  
   185                                  	ST3_WP equ 40h               ; NOT Write Protected
   186                                  	ST3_TR00 equ 10h             ; Track 0 signal
   187                                  	ST3_WP2 equ 08h              ; duplicate of ST3_WP; ST3_2S for 8" floppies
   188                                  	ST3_HS equ 04h               ; head 0 or 1
   189                                  	ST3_US equ 03h               ; Unit mask (0..3)
   190                                  
   191                                  
   192                                  	; define the ST2 status bits
   193                                  
   194                                  	ST2_CM equ 40h               ; Control Mark (deleted data mark)
   195                                  	ST2_DD equ 20h               ; Data Error (data field)
   196                                  	ST2_WC equ 10h               ; Wrong Cylinder
   197                                  	ST2_SH equ 08h               ; Scan Hit (not used here)
   198                                  	ST2_SN equ 04h               ; Scan Not Satisfied (not used here)
   199                                  	ST2_BC equ 02h               ; Bad Cylinder
   200                                  	ST2_MD equ 01h               ; Missing address mark
   201                                  
   202                                  	ST2_ANY equ ST2_CM + ST2_DD + ST2_WC + ST2_BC + ST2_MD
   203                                  
   204                                  
   205                                  	; define the ST1 status bits
   206                                  
   207                                  	ST1_EN equ 80h               ; End of cylinder
   208                                  	ST1_DE equ 20h               ; Data error (CRC err in address or data field)
   209                                  	ST1_OR equ 10h               ; Overrun (we will always see this flag)
   210                                  	ST1_ND equ 04h               ; No Data
   211                                  	ST1_NW equ 02h               ; Not writeable (WP is set)
   212                                  	ST1_MA equ 01h               ; Missing address mark
   213                                  
   214                                  	; define the ST0 status bits
   215                                  
   216                                  	ST0_IC equ 0C0h              ; Interrupt code mask
   217                                  	; 00 = normal termination
   218                                  	; 01 = abnormal termination
   219                                  	; 10 = invalid command
   220                                  	; 11 = abnormal termination - - change in ready status
   221                                  
   222                                  	ST0_SE equ 20h               ; Seek end
   223                                  	ST0_EC equ 10h               ; Equipment check
   224                                  	ST0_NR equ 08h               ; Not Ready (always 0 on WD37C65B)
   225                                  	ST0_HS equ 04h               ; Head Select
   226                                  	;ST0_US equ 03h ; Unit select mask
   227                                  	ST0_US equ 01h               ; Unit select mask
   228                                  
   229                                  	ST0_ANY equ ST0_EC + ST0_NR  ; Any ST0 error
   230                                  
   231                                  
   232                                  
   233                                  	; The FDC interrupt control register
   234                                  	fdc_int_control equ PIC_I1CON
   235                                  
   236                                  
   237                                  	; Standard int 13h stack frame layout is
   238                                  	; created by: PUSHM ALL, DS, ES
   239                                  	; MOV BP, SP
   240                                  	;
   241                                  	offset_DI equ 0
   242                                  	offset_SI equ offset_DI + 2
   243                                  	offset_BP equ offset_SI + 2
   244                                  	offset_SP equ offset_BP + 2
   245                                  	offset_BX equ offset_SP + 2
   246                                  	offset_DX equ offset_BX + 2
   247                                  	offset_CX equ offset_DX + 2
   248                                  	offset_AX equ offset_CX + 2
   249                                  	offset_DS equ offset_AX + 2
   250                                  	offset_ES equ offset_DS + 2
   251                                  	offset_IP equ offset_ES + 2
   252                                  	offset_CS equ offset_IP + 2
   253                                  	offset_FLAGS equ offset_CS + 2
   254                                  
   255                                  	; The byte registers in the stack
   256                                  	offset_AL equ offset_AX
   257                                  	offset_AH equ offset_AX + 1
   258                                  	offset_BL equ offset_BX
   259                                  	offset_BH equ offset_BX + 1
   260                                  	offset_CL equ offset_CX
   261                                  	offset_CH equ offset_CX + 1
   262                                  	offset_DL equ offset_DX
   263                                  	offset_DH equ offset_DX + 1
   264                                  
   265                                  
   266                                  	; FDC error codes (returned in AH)
   267                                  	;
   268                                  	ERR_no_error equ 0           ; no error (return Carry clear)
   269                                  	; everything below returns with the Carry set to indicate an error
   270                                  	ERR_invalid_command equ 1
   271                                  	ERR_address_mark_not_found equ 2
   272                                  	ERR_write_protect equ 3
   273                                  	ERR_sector_not_found equ 4
   274                                  	ERR_disk_removed equ 6
   275                                  	ERR_dma_overrun equ 8
   276                                  	ERR_dma_crossed_64k equ 9
   277                                  
   278                                  
   279                                  	ERR_media_type_not_found equ 12 ; 0Ch
   280                                  	ERR_uncorrectable_CRC_error equ 10h
   281                                  	ERR_controller_failure equ 20h
   282                                  	ERR_seek_failed equ 40h
   283                                  	ERR_disk_timeout equ 80h
   284                                  
   285                                  	ERR_81 equ 81h               ; fdc_ready_for_cmd, not rdy for input
   286                                  	ERR_82 equ 82h               ; fdc_ready_for_result, not rdy for output
   287                                  	ERR_83 equ 83h               ; input_result_from_fdc, after input, still busy
   288                                  	ERR_84 equ 84h               ; fdc_wait_seek_done, abnormal ST0_IC code
   289                                  	ERR_85 equ 85h               ; xfer_read_sector timeout
   290                                  	ERR_86 equ 86h               ; cylinder requested is invalid for drive
   291                                  	ERR_87 equ 87h               ; not on track 0 after recalibrate
   292                                  	ERR_88 equ 88h               ; wait for operation complete to be posted
   293                                  	ERR_89 equ 89h               ; fdc_ready_for_cmd, unexpectedly BUSY
   294                                  	ERR_8A equ 8Ah               ; second "seek failed" error (ignore during Format)
   295                                  
   296                                  	ERR_unknown equ 8Fh          ; ADDED - - JRC (may need to change)
   297                                  
   298                                  
   299                                  	SEGMENT _TEXT
   300                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   301                                  	; BIOS call entry for Floppy Disk driver
   302                                  	; int 13h
   303                                  	;
   304                                  	; The Fixed Disk driver will move the vector from 13h to 40h
   305                                  	; At the moment there is no Fixed Disk Driver
   306                                  	;
   307                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   308                                  	global BIOS_call_13h
   309                                  BIOS_call_13h:                ; Floppy driver entry
   310 00000000 FB                      	sti                          ; Enable interrupts
   311 00000001 061E60                  	pushm all, ds, es            ; Standard register save
   312 00000004 89E5                    	mov bp, sp                   ; establish stack addressing
   313                                  
   314 00000006 FC                      	cld                          ; may NOT assume direction flag is clear
   315 00000007 6A40                    	push bios_data_seg
   316 00000009 1F                      	popm ds                      ; establish addressability for all functions
   317 0000000A C606AE0000              	mov byte [lock_count], 0     ; clear the lock counter
   318                                  
   319                                  	%if SOFT_DEBUG & DUMP
   320                                  	pushm ax, cx, dx, es
   321                                  
   322                                  	push bx
   323                                  	push es
   324                                  	xor bh, bh
   325                                  	mov bl, dl
   326                                  	push bx
   327                                  	mov bl, cl
   328                                  	push bx
   329                                  	mov bl, dh
   330                                  	push bx
   331                                  	mov bl, ch
   332                                  	push bx
   333                                  	mov bx, ax
   334                                  	push bx
   335                                  	push cs
   336                                  	push rwvc
   337                                  	call _cprintf
   338                                  	add sp, 18
   339                                  
   340                                  	popm ax, cx, dx, es
   341                                  	xor bh, bh
   342                                  	%endif
   343 0000000F 88E3                    	mov bl, ah                   ; set to index into dispatch table
   344 00000011 80FC19                  	cmp ah, max / 2
   345 00000014 7202                    	jb .1
   346 00000016 B314                    	mov bl, 14h                  ; fn not defined for Floppy diskette
   347 00000018 30FF                    .1: xor bh, bh
   348 0000001A D1E3                    	shl bx, 1                    ; index words
   349 0000001C 2EFF97[3400]            	cs call near [dispatch + bx]
   350                                  
   351                                  	; returns come here with AH set
   352                                  
   353 00000021 08E4                    	or ah, ah                    ; is return code 0? sets carry=0, too
   354 00000023 7401                    	jz exit_pops
   355                                  error_exit:
   356 00000025 F9                      	stc
   357                                  exit_pops:
   358 00000026 88660F                  	mov [bp + offset_AH], ah     ; store for return
   359 00000029 89EC                    	mov sp, bp                   ; remove any allocated variables
   360                                  	%if SOFT_DEBUG & DUMP
   361                                  	pushm f                      ;, ax, bx, cx, dx, es
   362                                  	mov al, ah                   ; save AH in AL
   363                                  	lahf                         ; get flags
   364                                  	xor bh, bh                   ; Zap BH
   365                                  	mov bl, [fdc_op_start + 1]
   366                                  	push bx
   367                                  	mov bl, [fdc_op_start]
   368                                  	push bx
   369                                  	mov bl, ah
   370                                  	and bx, 1                    ; mask Carry
   371                                  	push bx
   372                                  	mov bl, al                   ; former AH
   373                                  	push bx
   374                                  	push cs                      ; far pointer to ...
   375                                  	push fnret                   ; format
   376                                  	call _cprintf
   377                                  	add sp, 12
   378                                  	popm f                       ;, ax, bx, cx, dx, es
   379                                  	%endif
   380 0000002B 611F07                  	popm all, ds, es
   381 0000002E CA0200                  	retf 2                       ; return the carry
   382                                  
   383                                  
   384                                  
   385                                  	;fn00 ; Reset Disk System
   386                                  fn01:                         ; Get Disk System Status
   387                                  	;fn02 ; Read Sector
   388                                  	;fn03 ; Write Sector
   389                                  	;fn04 ; Verify Sector
   390                                  	;fn05: ; Format Track
   391                                  fn06:                         ; Format Bad Track (fixed disk) [PC]
   392                                  fn07:                         ; Format Drive (fixed disk) [PC]
   393                                  	;fn08 ; Get Drive Parameters
   394                                  fn09:
   395                                  fn0A:
   396                                  fn0B:
   397                                  fn0C:
   398                                  fn0D:
   399                                  fn0E:
   400                                  fn0F:
   401                                  fn10:
   402                                  fn11:
   403                                  fn12:
   404                                  fn13:
   405                                  fn14:                         ; * * * fixed disk only * * *
   406                                  	;fn15: ; Get Disk Type [AT]
   407                                  	;fn16: ; Get Disk Change Status (floppy)
   408                                  fn17:                         ; Set Disk Type (floppy)
   409                                  	;fn18: ; Set Media Type for Format (floppy)
   410                                  undefined:
   411 00000031 B401                    	mov ah, ERR_invalid_command  ; equ 1
   412 00000033 C3                      	ret
   413                                  
   414                                  
   415                                  dispatch:
   416 00000034 [F901]                  	dw fn00                      ; Reset Disk System
   417 00000036 [3100]                  	dw fn01                      ;
   418 00000038 [8402]                  	dw fn02
   419 0000003A [8B02]                  	dw fn03
   420 0000003C [9202]                  	dw fn04
   421 0000003E [0803]                  	dw fn05
   422 00000040 [3100]                  	dw fn06
   423 00000042 [3100]                  	dw fn07
   424 00000044 [4802]                  	dw fn08
   425 00000046 [3100]                  	dw fn09
   426 00000048 [3100]                  	dw fn0A
   427 0000004A [3100]                  	dw fn0B
   428 0000004C [3100]                  	dw fn0C
   429 0000004E [3100]                  	dw fn0D
   430 00000050 [3100]                  	dw fn0E
   431 00000052 [3100]                  	dw fn0F
   432 00000054 [3100]                  	dw fn10
   433 00000056 [3100]                  	dw fn11
   434 00000058 [3100]                  	dw fn12
   435 0000005A [3100]                  	dw fn13
   436 0000005C [3100]                  	dw fn14
   437 0000005E [7F03]                  	dw fn15
   438 00000060 [9503]                  	dw fn16
   439 00000062 [3100]                  	dw fn17
   440 00000064 [AD03]                  	dw fn18
   441                                  	max equ $ - dispatch
   442                                  
   443                                  
   444                                  	;
   445                                  	; Floppy Drive Types (fn08)
   446                                  	;
   447                                  	; We support:
   448                                  	; 1 = 5.25" 360K 40track yes
   449                                  	; 2 = 5.25" 1.2M 80track yes
   450                                  	; 3 = 3.5" 720K 80track yes
   451                                  	; 4 = 3.5" 1.44M 80track yes
   452                                  	; 6 = 3.5" 2.88M 80track no (WD37C65CJM & 32Mhz osc)
   453                                  	; 7 = 3.5" 1.28M 1024sect no (Japan)
   454                                  	;
   455                                  	; Floppy Combos
   456                                  	; 5 = 5.25" 360K 40track in Drive Type 2 no
   457                                  	; 8 = 5.25" 512k 77track / 128sector in Drv 2 (future) CP / M
   458                                  	; 9 = 3.5" 256k 77track / 128sector in Drv 3 (future) CP / M
   459                                  	; 10 = 3.5" 512k 77track / 128sector in Drv 4 (future) CP / M
   460                                  	;;
   461                                  
   462                                  D_table:
   463 00000066 0000                    	dw 0
   464 00000068 [7C00]                  	dw DTAB1                     ; 360K (MFM)
   465 0000006A [8900]                  	dw DTAB2                     ; 1.2M
   466 0000006C [9600]                  	dw DTAB3                     ; 720K
   467 0000006E [A300]                  	dw DTAB4                     ; 1.44M
   468 00000070 0000                    	dw 0                         ; DTAB5
   469 00000072 0000                    	dw 0                         ; DTAB6
   470 00000074 [CA00]                  	dw DTAB7                     ; 1024 byte sectors (Japan)
   471 00000076 [D700]                  	dw DTAB8                     ; CP / M 26 / 77 in 1.2M drive (128 byte FM sectors)
   472 00000078 [E400]                  	dw DTAB9                     ; CP / M 13 / 77 in 720K drive
   473 0000007A [F100]                  	dw DTAB10                    ; CP / M 26 / 77 in 1.44M drive
   474                                  	L_table equ ($ - D_table) / 2
   475                                  
   476                                  
   477                                  	; Disk Information
   478                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   479                                  	;;; The DOS MFM floppies
   480                                  	; 360K 5.25" DD floppy
   481 0000007C DF022502092AFF50F6-     DTAB1: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   481 00000085 0F082780           
   482                                  
   483                                  	; 1.2M 5.25" HD floppy
   484 00000089 DF0225020F1BFF54F6-     DTAB2: db 0DFh, 2, 25h, 2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   484 00000092 0F084F00           
   485                                  
   486                                  	; 720K 3.5" or 5.25" DD floppy
   487 00000096 DF022502092AFF50F6-     DTAB3: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   487 0000009F 0F084F80           
   488                                  
   489                                  	; 1.44M 3.5" HD floppy
   490 000000A3 AF022502121BFF6CF6-     DTAB4: db 0AFh, 2, 25h, 2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   490 000000AC 0F084F00           
   491                                  
   492                                  	; 360K 5.25" DD floppy in 1.2M HD drive
   493 000000B0 DF022502092AFF50F6-     DTAB5: db 0DFh, 2, 25h, 2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   493 000000B9 0F082740           
   494                                  
   495                                  	; 2.88M 3.5" XD floppy
   496 000000BD AF022502241BFF50F6-     DTAB6: db 0AFh, 2, 25h, 2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   496 000000C6 0F084FC0           
   497                                  
   498                                  	; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   499 000000CA AF0225030835FF74F6-     DTAB7: db 0AFh, 2, 25h, 3, 8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   499 000000D3 0F084F00           
   500                                  
   501                                  	; specify off N R gp DTL gp3 fill unk on cyl clk
   502                                  	;;; The CP / M FM floppies
   503                                  	; 500K 5.25" CP / M (FM) floppy in 1.2M drive
   504 000000D7 DF0225001A098023E5-     DTAB8: db 0DFh, 2, 25h, 0, 26, 9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   504 000000E0 0F084C00           
   505                                  	;;; 7h 1Bh
   506                                  
   507                                  	; 250K 3.5" CP / M (FM) floppy in 720K drive
   508 000000E4 DF0225000D138046E5-     DTAB9: db 0DFh, 2, 25h, 0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   508 000000ED 0F084C80           
   509                                  
   510                                  	; 500K 3.5" CP / M (FM) floppy in 1.44M drive
   511 000000F1 AF0225001A15804BE5-     DTAB10: db 0AFh, 2, 25h, 0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   511 000000FA 0F084C00           
   512                                  
   513                                  
   514                                  	; DTAB table offsets
   515                                  	DTAB_specify equ 0
   516                                  	DTAB_specify2 equ DTAB_specify + 1
   517                                  	DTAB_turnoff_ticks equ DTAB_specify2 + 1
   518                                  	DTAB_N_param equ DTAB_turnoff_ticks + 1
   519                                  	DTAB_EOT_nsect equ DTAB_N_param + 1
   520                                  	DTAB_rw_gap equ DTAB_EOT_nsect + 1
   521                                  	DTAB_data_len equ DTAB_rw_gap + 1
   522                                  	DTAB_fmt_gap3 equ DTAB_data_len + 1
   523                                  	DTAB_fmt_fill equ DTAB_fmt_gap3 + 1
   524                                  	DTAB_unknown equ DTAB_fmt_fill + 1
   525                                  	DTAB_startup equ DTAB_unknown + 1 ; in 1 / 8 seconds
   526                                  	DTAB_max_cylinder equ DTAB_startup + 1
   527                                  	DTAB_control equ DTAB_max_cylinder + 1
   528                                  
   529                                  	;
   530                                  	; takes:
   531                                  	; AL = contents of FDC_DATA (Data Register)
   532                                  	;
   533                                  put_data:
   534 000000FE 52                      	push dx
   535 000000FF BA8104                  	mov dx, FDC_DATA
   536 00000102 EE                      	out dx, al
   537 00000103 5A                      	pop dx
   538 00000104 C3                      	ret
   539                                  
   540                                  	;
   541                                  	; Returns:
   542                                  	; AL = contents of FDC_DATA (Data Register)
   543                                  	;
   544                                  get_data:
   545 00000105 52                      	push dx
   546 00000106 BA8104                  	mov dx, FDC_DATA
   547 00000109 EC                      	in al, dx
   548 0000010A 5A                      	pop dx
   549 0000010B C3                      	ret
   550                                  	;
   551                                  	; Returns:
   552                                  	; AL = contents of FDC_MSR (Main Status Register)
   553                                  	;
   554                                  get_msr:
   555 0000010C 52                      	push dx
   556 0000010D BA8004                  	mov dx, FDC_MSR
   557 00000110 EC                      	in al, dx
   558 00000111 5A                      	pop dx
   559 00000112 C3                      	ret
   560                                  
   561                                  	; delay for about 12 microseconds for MSR to be set
   562                                  	extern microsecond
   563                                  	global wait12
   564                                  wait12:
   565 00000113 51                      	push cx
   566                                  	%if 1
   567                                  	; mov cx, 12 ; 12 microseconds
   568 00000114 30ED                    	xor ch, ch
   569 00000116 8A0EFF00                	mov cl, [cpu_xtal]           ; 2x clock (32usec on 16Mhz CPU)
   570 0000011A D0E9                    	shr cl, 1
   571 0000011C 83E905                  	sub cx, 5                    ; fudge factor for overhead
   572                                  	%else
   573                                  	xor ch, ch
   574                                  	mov cl, [wait12_count]
   575                                  	%endif
   576 0000011F E8(0000)                	call microsecond
   577 00000122 59                      	pop cx
   578 00000123 C3                      	ret
   579                                  wait1000:
   580 00000124 51                      	push cx
   581 00000125 B9E803                  	mov cx, 1000                 ; 1 ms delay
   582 00000128 E8(0000)                	call microsecond
   583 0000012B 59                      	pop cx
   584 0000012C C3                      	ret
   585                                  
   586                                  	; FDC Operations Register operations
   587                                  	; put out the LDOR write - only register
   588                                  	; Assumes DS is BIOS data segment
   589                                  	; Destroys AX and DX
   590                                  out_LDOR_mem:
   591                                  
   592                                  	%if SOFT_DEBUG & DUMP
   593                                  	pushm f                      ;, ax, bx, cx, dx, es
   594                                  	mov al, ah                   ; save AH in AL
   595                                  	lahf                         ; get flags
   596                                  	xor bh, bh                   ; Zap BH
   597                                  	mov bl, [fdc_motor_LDOR]
   598                                  	push bx
   599                                  	push cs                      ; far pointer to ...
   600                                  	push fnldor                  ; format
   601                                  	call _cprintf
   602                                  	add sp, 6
   603                                  	popm f                       ;, ax, bx, cx, dx, es
   604                                  	%endif
   605                                  
   606                                  
   607 0000012D A03F00                  	mov al, [fdc_motor_LDOR]
   608 00000130 BA8604                  	mov dx, FDC_LDOR
   609 00000133 EE                      	out dx, al
   610 00000134 C3                      	ret
   611                                  
   612                                  
   613                                  	;__CHECKINT__________________________________________________________________________________________________________________________
   614                                  	;
   615                                  	; CHECK FOR ACTIVE FDC INTERRUPTS BEFORE GIVING I8272 COMMANDS
   616                                  	; POLL RQM FOR WHEN NOT BUSY AND THEN SEND FDC
   617                                  	; SENSE INTERRUPT COMMAND. IF IT RTSURNS WITH NON ZERO
   618                                  	; ERROR CODE, PASS BACK TO JSRING ROUTINE FOR HANDLING
   619                                  	;________________________________________________________________________________________________________________________________
   620                                  	;
   621                                  CHECKINT:
   622 00000135 51                      	push cx
   623                                  
   624 00000136 B900F1                  	mov cx, 0F100h                  ; setup to allow timeout
   625                                  .1:
   626 00000139 E8D0FF                  	call get_msr
   627 0000013C A880                    	test al, RQM
   628 0000013E 7507                    	jnz .2                       ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
   629 00000140 E8D0FF                  	call wait12
   630 00000143 E2F4                    	loop .1
   631 00000145 EB0C                    	jmp ERRCLR
   632                                  .2:
   633 00000147 E8C2FF                  	call get_msr
   634 0000014A A840                    	test al, 040h                ; WAITING FOR INPUT?
   635 0000014C 7503                    	jnz .3
   636 0000014E E81600                  	call SENDINT
   637                                  .3:
   638                                  	okay
   638          ******************       warning: label alone on a line without a colon might be in error [-w+label-orphan]
   639 00000151 59                      	pop cx
   640 00000152 C3                      	ret
   641                                  
   642                                  ERRCLR:
   643 00000153 B900F1                  	mov cx, 0F100h                 ; setup to allow timeout
   644                                  .1:
   645 00000156 E8ACFF                  	call get_data
   646 00000159 E8B0FF                  	call get_msr
   647 0000015C A880                    	test al, RQM
   648 0000015E 7505                    	jnz .2                       ; WAIT FOR RQM TO BE TRUE. WAIT UNTIL DONE
   649 00000160 E8B0FF                  	call wait12
   650 00000163 E2F1                    	loop .1
   651                                  .2:
   652                                  	error
   652          ******************       warning: label alone on a line without a colon might be in error [-w+label-orphan]
   653 00000165 59                      	pop cx
   654 00000166 C3                      	ret
   655                                  
   656                                  
   657                                  
   658                                  	;__SENDINT__________________________________________________________________________________________________________________________
   659                                  	;
   660                                  	; SENSE INTERRUPT COMMAND
   661                                  	;________________________________________________________________________________________________________________________________
   662                                  	;
   663                                  SENDINT:
   664 00000167 B004                    	mov al, CMD_SENSE_DRIVE_STATUS ; SENSE INTERRUPT COMMAND
   665 00000169 E82F00                  	call PFDATA                  ; SEND IT
   666 0000016C E8A4FF                  	call wait12
   667 0000016F E81200                  	call GFDATA                  ; GET RESULTS
   668 00000172 A24200                  	mov [fdc_ctrl_status], al    ; STORE THAT
   669 00000175 24C0                    	and al, 0C0h                 ; MASK OFF INTERRUPT STATUS BITS
   670 00000177 3C80                    	cmp al, 80h                  ; CHECK IF INVALID COMMAND
   671 00000179 7408                    	jz .1                        ; YES, EXIT
   672 0000017B E80600                  	call GFDATA                  ; GET ANOTHER (STATUS CODE 1)
   673 0000017E A04200                  	mov al, [fdc_ctrl_status]    ; GET FIRST ONE
   674 00000181 24C0                    	and al, 0C0h                 ; MASK OFF ALL BUT INTERRUPT CODE 00 IS NORMAL
   675                                  .1:
   676 00000183 C3                      	ret
   677                                  
   678                                  
   679                                  	;__GFDATA__________________________________________________________________________________________________________________________
   680                                  	;
   681                                  	; GET DATA FROM FLOPPY CONTROLLER
   682                                  	;
   683                                  	; TRANSFERS ARE SYNCHONIZED BYT MSR D7 <RQM> AND D6 <DIO>
   684                                  	; RQM DIO
   685                                  	; 0 0 BUSY
   686                                  	; 1 0 WRITE TO DATA REGISTER PERMITTED
   687                                  	; 1 1 BYTE FOR READ BY HOST PENDING
   688                                  	; 0 1 BUSY
   689                                  	;
   690                                  	;________________________________________________________________________________________________________________________________
   691                                  	;
   692                                  GFDATA:
   693 00000184 B900F1                  	mov cx, 0F100h
   694                                  .1:
   695 00000187 E882FF                  	call get_msr                 ; GET STATUS
   696 0000018A A880                    	test al, RQM
   697 0000018C E1F9                    	loopz .1                    ; NOT READY, WAIT
   698 0000018E 7503                    	jnz .3                       ; ok, continue
   699                                  .2:
   700                                  
   701                                  	%if SOFT_DEBUG & DUMP
   702                                  	pushm f                      ;, ax, bx, cx, dx, es
   703                                  	mov al, ah                   ; save AH in AL
   704                                  	lahf                         ; get flags
   705                                  	push cx
   706                                  	push ax
   707                                  	push cs                      ; far pointer to ...
   708                                  	push fngferr                 ; format
   709                                  	call _cprintf
   710                                  	add sp, 8
   711                                  	popm f                       ;, ax, bx, cx, dx, es
   712                                  	%endif
   713                                  
   714 00000190 B0FF                    	mov al, 0FFh                 ; timeout
   715 00000192 C3                      	ret
   716                                  .3:
   717 00000193 A840                    	test al, DIO                 ; ANY DATA FOR US?
   718 00000195 74F9                    	jz .2                        ; NO, SKIP IT
   719 00000197 E86BFF                  	call get_data
   720 0000019A C3                      	ret
   721                                  
   722                                  	;__PFDATA__________________________________________________________________________________________________________________________
   723                                  	;
   724                                  	; WRITE A COMMAND OR PARAMETER SEQUENCE
   725                                  	;
   726                                  	; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
   727                                  	; RQM DIO
   728                                  	; 0 0 BUSY
   729                                  	; 1 0 WRITE TO DATA REGISTER PERMITTED
   730                                  	; 1 1 BYTE FOR READ BY HOST PENDING
   731                                  	; 0 1 BUSY
   732                                  	;
   733                                  	;________________________________________________________________________________________________________________________________
   734                                  	;
   735                                  PFDATA:
   736 0000019B 88C4                    	mov ah, al                   ; SAVE DATA BYTE
   737 0000019D B900F1                  	mov cx, 0F100h                ; set timeout
   738                                  .1:
   739 000001A0 E869FF                  	call get_msr                 ; READ FDC STATUS
   740 000001A3 A880                    	test al, RQM
   741 000001A5 E1F9                    	loopz .1
   742 000001A7 7503                    	jnz .2
   743                                  
   744                                  
   745                                  	%if SOFT_DEBUG & DUMP
   746                                  	pushm f                      ;, ax, bx, cx, dx, es
   747                                  	mov al, ah                   ; save AH in AL
   748                                  	lahf                         ; get flags
   749                                  	mov bx, ax
   750                                  	push bx
   751                                  	push cs                      ; far pointer to ...
   752                                  	push fnpferr                 ; format
   753                                  	call _cprintf
   754                                  	add sp, 6
   755                                  	popm f                       ;, ax, bx, cx, dx, es
   756                                  	%endif
   757                                  
   758                                  
   759 000001A9 B0FF                    	mov al, 0FFh
   760 000001AB C3                      	ret
   761                                  .2:
   762 000001AC A840                    	test al, DIO                 ; TEST DIO BIT
   763 000001AE 7509                    	jnz .3                       ; FDC IS OUT OF SYNC
   764 000001B0 88E0                    	mov al, ah                   ; RESTORE DATA
   765 000001B2 E849FF                  	call put_data                ; WRITE TO FDC
   766 000001B5 E85BFF                  	call wait12
   767 000001B8 C3                      	ret
   768                                  .3:                           ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE - TRY
   769 000001B9 E849FF                  	call get_data                ; READ DATA REGISTER
   770 000001BC 7AE2                    	JP .1                        ; AND CONTINUE
   771                                  
   772                                  	;__PFDATAS_________________________________________________________________________________________________________________________
   773                                  	;
   774                                  	; WRITE A COMMAND OR PARAMETER SEQUENCE (NO PAUSE)
   775                                  	;
   776                                  	; TRANSFERS ARE SYNCHONIZED BY MSR D7 <RQM> AND D6 <DIO>
   777                                  	; RQM DIO
   778                                  	; 0 0 BUSY
   779                                  	; 1 0 WRITE TO DATA REGISTER PERMITTED
   780                                  	; 1 1 BYTE FOR READ BY HOST PENDING
   781                                  	; 0 1 BUSY
   782                                  	;
   783                                  	;________________________________________________________________________________________________________________________________
   784                                  	;
   785                                  PFDATAS:
   786 000001BE 88C4                    	mov ah, al                   ; SAVE DATA BYTE
   787 000001C0 B90001                  	mov cx, 0100h                ; set timeout
   788                                  .1:
   789 000001C3 E846FF                  	call get_msr                 ; READ FDC STATUS
   790 000001C6 A880                    	test al, RQM
   791 000001C8 E1F9                    	loopz .1
   792 000001CA 7503                    	jnz .2
   793 000001CC B0FF                    	mov al, 0FFh
   794 000001CE C3                      	ret
   795                                  .2:
   796 000001CF A840                    	test al, DIO                 ; TEST DIO BIT
   797 000001D1 7506                    	jnz .3                       ; FDC IS OUT OF SYNC
   798 000001D3 88C4                    	mov ah, al                   ; RESTORE DATA
   799 000001D5 E826FF                  	call put_data                ; WRITE TO FDC
   800 000001D8 C3                      	ret
   801                                  .3:                           ; FDC IS OUT OF SYNC CLEAR IT OUT AND RE - TRY
   802 000001D9 E829FF                  	call get_data                ; READ DATA REGISTER
   803 000001DC 7AE5                    	JP .1                        ; AND CONTINUE
   804                                  
   805                                  
   806                                  	global fdc_timer_hook
   807                                  	; called from Timer Tick code with DS - >BIOS data area
   808                                  	; Destroys AX and DX
   809                                  	global fdc_timer_hook
   810                                  fdc_timer_hook:
   811 000001DE 803E400000              	cmp byte [fdc_motor_ticks], 0
   812 000001E3 740E                    	je .9
   813 000001E5 FE0E4000                	dec byte [fdc_motor_ticks]
   814 000001E9 7508                    	jnz .9
   815                                  	; timer expired, stop the motors
   816 000001EB 80263F00CF              	and byte [fdc_motor_LDOR], ~( MOEN_MASK )
   817 000001F0 E83AFF                  	call out_LDOR_mem
   818 000001F3 C3                      .9: ret
   819                                  
   820                                  
   821                                  	;
   822                                  	; power on init
   823                                  	;
   824                                  	global @floppy_init
   825                                  @floppy_init:
   826 000001F4 B400                    	mov ah, 0                    ; fn00
   827 000001F6 CD13                    	int 13h
   828 000001F8 C3                      	ret
   829                                  
   830                                  
   831                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   832                                  	; Function 00h Reset the Disk System
   833                                  	; Used both at power on and after a serious error
   834                                  	;
   835                                  	; Enter with:
   836                                  	; AH = 00h
   837                                  	; DL = drive 0 or 1
   838                                  	;
   839                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   840                                  fn00:
   841                                  
   842 000001F9 C606AD0020              	mov byte [wait12_count], 32  ; this is about the max.
   843 000001FE E812FF                  	call wait12                  ; wait 12 microseconds
   844 00000201 E808FF                  	call get_msr                 ; set BASE mode
   845 00000204 E80CFF                  	call wait12                  ; wait 12 microseconds
   846                                  
   847 00000207 C6063F0008              	mov byte [fdc_motor_LDOR], (MODE + RESET + DMAEN) ; set PC_AT mode
   848 0000020C E81EFF                  	call out_LDOR_mem
   849 0000020F E801FF                  	call wait12
   850                                  
   851                                  	%if 1
   852                                  	;;; This read may not be necessary, unless Special Mode is set
   853 00000212 BA8504                  	mov dx, FDC_LDCR
   854 00000215 EC                      	in al, dx                    ; read a write - only register to latch Mode
   855                                  	;;;;;
   856                                  	%endif
   857 00000216 E80BFF                  	call wait1000
   858                                  
   859 00000219 800E3F000C              	or byte [fdc_motor_LDOR], (MODE + NO_RESET + DMAEN) ; remove the RESET
   860 0000021E E80CFF                  	call out_LDOR_mem
   861 00000221 E8EFFE                  	call wait12
   862                                  
   863                                  	%if 0
   864                                  	mov dx, FDC_LDCR
   865                                  	mov al, FDC_HD               ; set for HD disks
   866                                  	out dx, al
   867                                  	%endif
   868                                  
   869 00000224 31C0                    	xor ax, ax
   870 00000226 A24000                  	mov [fdc_motor_ticks], al    ; Zero the timer tick counter
   871 00000229 A28B00                  	mov [fdc_last_rate], al      ; force a specify command
   872                                  
   873 0000022C 8EC0                    	mov es, ax
   874                                  	cnop
   875 0000022E 26A37800                	es mov [1Eh * 4], ax
   876 00000232 26A37A00                	es mov [1Eh * 4 + 2], ax     ; Zap the parameter pointer
   877                                  
   878 00000236 C7069400FFFF            	mov word [fdc_cylinder], - 1 ; Specify & Recalibration needed
   879                                  
   880                                  	; now allow time for the polling interrupts
   881 0000023C B90100                  	mov cx, 102400>>16           ; 0.1 seconds
   882 0000023F 31D2                    	xor dx, dx                   ; CX:DX is delay in usec
   883 00000241 B486                    	mov ah, 86h                  ; delay in microseconds
   884 00000243 CD15                    	int 15h
   885                                  
   886 00000245 30E4                    	Okay                         ; signal good execution
   887 00000247 C3                      	ret                          ; end of FN00
   888                                  
   889                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   890                                  	; Function 08h Get Drive Parameters
   891                                  	;
   892                                  	; Enter with:
   893                                  	; AH = 08h
   894                                  	; DL = drive 0 or 1
   895                                  	;
   896                                  	; Return with:
   897                                  	; Carry clear if no error
   898                                  	; BL = drive type (2 or 4 for us)
   899                                  	; CH = max cylinder number
   900                                  	; CL = max sector number
   901                                  	; DH = max head number
   902                                  	; DL = number of drives
   903                                  	; ES:DI = address of disk parameter table
   904                                  	;
   905                                  	; Carry set on error
   906                                  	; AH = error code
   907                                  	;
   908                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   909                                  fn08:                         ; Get Drive Parameters
   910 00000248 A01000                  	mov al, [equipment_flag]
   911 0000024B B401                    	mov ah, 1
   912 0000024D 20C4                    	and ah, al                   ; any floppies at all?
   913 0000024F 7407                    	jz .2
   914 00000251 C0C002                  	rol al, 2                    ; at least one
   915 00000254 2403                    	and al, 3
   916 00000256 00C4                    	add ah, al                   ; 1..4
   917                                  .2:
   918 00000258 88660A                  	mov [offset_DL + bp], ah     ; return # of drives
   919 0000025B E8AA01                  	call check_DL
   920 0000025E 7221                    	jc .err_no_drive
   921 00000260 E8BC01                  	call get_disk_type
   922 00000263 884608                  	mov [offset_BL + bp], al     ; return BL = disk type
   923 00000266 E8C501                  	call get_media
   924 00000269 2E8A670B                	cs mov ah, [DTAB_max_cylinder + bx]
   925 0000026D 2E8A4704                	cs mov al, [DTAB_EOT_nsect + bx]
   926 00000271 89460C                  	mov [offset_CX + bp], ax     ; return CYL | SECT in CX
   927 00000274 C6460B01                	mov byte [offset_DH + bp], 1 ; head max. always 1
   928 00000278 8C4E12                  	mov [offset_ES + bp], cs     ; return ES param table
   929 0000027B 895E00                  	mov [offset_DI + bp], bx     ; return DI param table
   930                                  
   931 0000027E 30E4                    	xor ah, ah                   ; no error
   932 00000280 C3                      	ret
   933                                  
   934                                  .err_no_drive:
   935 00000281 B401                    	mov ah, ERR_invalid_command  ; error if no floppies
   936 00000283 C3                      	ret                          ; DL is still zero !!!
   937                                  
   938                                  
   939                                  
   940                                  
   941                                  
   942                                  
   943                                  	%if 0
   944                                  	; validate the READ / WRITE CHS, SC parameters
   945                                  	; Enter with DI pointing at the type table
   946                                  	;
   947                                  	; Carry clear if okay
   948                                  	; Carry set if invalid
   949                                  	; AX & all other registers are preserved
   950                                  validate_call:
   951                                  	push ax
   952                                  
   953                                  	cs cmp ch, [DTAB_max_cyl + di]
   954                                  	jnbe .7
   955                                  	cs mov ah, [DI_heads + di]
   956                                  	sub ah, dh
   957                                  	jbe .7
   958                                  	cs mov al, [DTAB_EOT_nsect + di]
   959                                  	dec cl                       ; base sectors at 0
   960                                  	cmp cl, al
   961                                  	jnc .6                       ; JNC = JNB = JAE
   962                                  	mul ah
   963                                  	; AX is 1 or 2 * sectors
   964                                  	sub al, cl
   965                                  	; AL is the maximum number of sectors we can transfer
   966                                  	cmp al, [offset_AX + bp]     ; compare to sector count
   967                                  .6: inc cl                    ; back to sectors from 1
   968                                  	jnc .8                       ; JAE = JNB = JNC
   969                                  .7: stc
   970                                  .8: pop ax                    ;
   971                                  	ret
   972                                  	%endif
   973                                  
   974                                  
   975                                  
   976                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   977                                  	; Function 02h Read Sectors
   978                                  	; Function 03h Write Sectors
   979                                  	; Function 04h Verify Sectors
   980                                  	;
   981                                  	; Enter with:
   982                                  	; AH = 02h (read)
   983                                  	; AH = 03h (write)
   984                                  	; AH = 04h (verify)
   985                                  	; AL = number of sectors to transfer
   986                                  	; CH = cylinder number
   987                                  	; CL = sector number
   988                                  	; DH = head number
   989                                  	; DL = drive 0 or 1
   990                                  	; ES:BX = buffer to read into or write from
   991                                  	;
   992                                  	; Return with:
   993                                  	; Carry clear if no error
   994                                  	; AH = 0
   995                                  	; AL = number of sectors transferred
   996                                  	;
   997                                  	; Carry set on error
   998                                  	; AH = error code
   999                                  	;
  1000                                  	; All other registers are preserved.
  1001                                  	;
  1002                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1003                                  	;
  1004                                  	; Stack variables
  1005                                  	;
  1006                                  	rwv_return equ - 2           ; offset from BP
  1007                                  	rwv_dma equ rwv_return - 2
  1008                                  	rwv_xfer equ rwv_dma - 2
  1009                                  	rwv_cmd equ rwv_xfer - 9
  1010                                  	rwv_AL equ rwv_cmd - 1
  1011                                  	rwv_stack equ - rwv_AL
  1012                                  
  1013                                  fn02:                         ; READ
  1014 00000284 B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1015 00000286 BB[EA04]                	mov bx, xfer_read_sector
  1016 00000289 EB0C                    	jmp rwv_common
  1017                                  
  1018                                  	%define EXTRA 0
  1019                                  fn03:                         ; WRITE
  1020                                  	%if EXTRA
  1021                                  	cmp al, 1
  1022                                  	jbe .10
  1023                                  
  1024                                  	mov bx, [offset_BX + bp]     ; restore BX
  1025                                  	mov [offset_AH + bp], al     ; use return code as counter
  1026                                  
  1027                                  .1: mov ax, 0301h             ; write 1 sector
  1028                                  	int 13h
  1029                                  	jc .5
  1030                                  
  1031                                  	inc cl                       ; increment sector number
  1032                                  	add bx, 200h                 ; increment transfer address
  1033                                  	dec byte [offset_AH + bp]
  1034                                  	jnz .1
  1035                                  
  1036                                  	Okay                         ; all went Okay
  1037                                  	ret
  1038                                  
  1039                                  	; process error return
  1040                                  	; AH = error code
  1041                                  .5: mov al, [offset_AL + bp]  ; sectors requested
  1042                                  	sub al, [offset_AH + bp]     ; sectors remaining
  1043                                  	mov [offset_AL + bp], al     ; set sectors transferred
  1044                                  	Error
  1045                                  	ret
  1046                                  
  1047                                  .10:
  1048                                  	%endif
  1049 0000028B B4C5                    	mov ah, (CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1050 0000028D BB[FE04]                	mov bx, xfer_write_sector
  1051 00000290 EB05                    	jmp rwv_common
  1052                                  
  1053                                  fn04:                         ; VERIFY
  1054 00000292 B4E6                    	mov ah, (CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1055 00000294 BB[FE04]                	mov bx, xfer_verify_sector
  1056                                  	;;; jmp rwv_common
  1057                                  
  1058                                  	; Common code to READ, WRITE, and VERIFY
  1059                                  rwv_common:
  1060 00000297 57                      	push di                      ; dma control register
  1061 00000298 53                      	push bx                      ; transfer function
  1062 00000299 83EC08                  	sub sp, rwv_stack - 8        ; 4 words in stack by pushes or Call
  1063 0000029C 50                      	push ax                      ; including this push
  1064                                  
  1065 0000029D E86801                  	call check_DL                ; sets DI
  1066 000002A0 B401                    	mov ah, ERR_invalid_command
  1067 000002A2 7260                    	jc .exit
  1068                                  
  1069 000002A4 E87801                  	call get_disk_type
  1070 000002A7 E88401                  	call get_media               ; get media pointer to CS:BX
  1071 000002AA E88D01                  	call set_media_pointer       ; set up Int 1Eh
  1072 000002AD E8E001                  	call motor_on                ; use DI to start motor
  1073 000002B0 E88402                  	call Seek                    ; use CH to seek to track
  1074                                  	; recalibrate is possible
  1075 000002B3 724F                    	jc .exit                     ; AH is error code
  1076                                  
  1077 000002B5 E82302                  	call make_head_unit          ; AL is next byte
  1078                                  
  1079 000002B8 571E06                  	pushm es, ds, di
  1080 000002BB 8D7EF2                  	lea di, [rwv_cmd + 1 + bp]   ; SS override not needed
  1081 000002BE 8D7703                  	lea si, [DTAB_N_param + bx]
  1082 000002C1 160E                    	pushm cs, ss
  1083 000002C3 1F07                    	popm ds, es
  1084 000002C5 AA                      	stosb                        ; store head unit in cmd stream
  1085 000002C6 88E8                    	mov al, ch                   ; cylinder
  1086 000002C8 AA                      	stosb
  1087 000002C9 88F0                    	mov al, dh                   ; head
  1088 000002CB AA                      	stosb
  1089 000002CC 88C8                    	mov al, cl                   ; sector (R)
  1090 000002CE AA                      	stosb
  1091 000002CF AC                      	lodsb                        ; get N
  1092 000002D0 88C1                    	mov cl, al
  1093 000002D2 AA                      	stosb                        ; store N
  1094 000002D3 A4                      	movsb                        ; EOT
  1095 000002D4 A4                      	movsb                        ; GPL
  1096 000002D5 A4                      	movsb                        ; DTL = FF
  1097 000002D6 8D76F1                  	lea si, [rwv_cmd + bp]       ; get command start
  1098 000002D9 071F5F                  	popm es, ds, di
  1099                                  
  1100 000002DC B88000                  	mov ax, 128                  ; minimum sector size
  1101 000002DF F666F0                  	mul byte [rwv_AL + bp]       ; times number of sectors to transfer
  1102 000002E2 D3E0                    	shl ax, cl                   ; shift by N_param
  1103 000002E4 89C1                    	mov cx, ax                   ; CX is byte count of transfer
  1104                                  
  1105 000002E6 53                      	pushm bx                     ; save DTAB pointer
  1106                                  
  1107 000002E7 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1108 000002EA 8CC3                    	mov bx, es                   ; segment to AX
  1109 000002EC 89DA                    	mov dx, bx                   ; and to DX
  1110 000002EE C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1111 000002F1 C1E204                  	shl dx, 4                    ; high part of offset from segment
  1112 000002F4 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1113 000002F6 83D300                  	adc bx, 0                    ; and carry into the high bits
  1114                                  
  1115 000002F9 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1116                                  
  1117                                  .marker:
  1118                                  	; BX:AX transfer 20 - bit address in memory
  1119                                  	; CX transfer byte count
  1120                                  	; DX:SI pointer to 9 - byte FDC command
  1121                                  	;
  1122 000002FB 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1123                                  
  1124 00000300 FF56FA                  	call near [rwv_xfer + bp]    ;call specific transfer function
  1125                                  
  1126                                  
  1127                                  	%if SOFT_DEBUG
  1128                                  	pushm ax, dx
  1129                                  	mov dx, FRONT_PANEL_LED
  1130                                  	mov al, 09h
  1131                                  	out dx, al
  1132                                  	popm ax, dx
  1133                                  	%endif
  1134                                  
  1135                                  
  1136 00000303 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1137                                  	;;; jc .exit ; AH is set to error code
  1138                                  
  1139                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; call Check_RW_Status ; get final return code
  1140                                  
  1141                                  .exit:
  1142 00000304 8D66FE                  	lea sp, [rwv_return + bp]
  1143 00000307 C3                      	ret
  1144                                  
  1145                                  	%if SOFT_DEBUG
  1146                                  	end_rwv equ $
  1147                                  	%endif
  1148                                  
  1149                                  
  1150                                  
  1151                                  	; Format stack layout
  1152                                  	fmt_return equ - 2           ; return from fn05 call
  1153                                  	fmt_dma equ fmt_return - 2
  1154                                  	fmt_cmd equ fmt_dma - 6
  1155                                  	fmt_stack equ - fmt_cmd      ; stack size
  1156                                  
  1157                                  	%if fmt_dma != rwv_dma
  1158                                  	%error "fmt_dma != rwv_dma"
  1159                                  	%endif
  1160                                  
  1161                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1162                                  	; Function 05h Format a Track
  1163                                  	;
  1164                                  	; Precede with call to Function 18h (or 17h) to set the disk type
  1165                                  	;
  1166                                  	; Enter with:
  1167                                  	; AH = 05h
  1168                                  	; CH = cylinder number
  1169                                  	; DH = head number
  1170                                  	; DL = drive 0 or 1
  1171                                  	; ES:BX = segment / offset of address field list (C / H / R / N)
  1172                                  	;
  1173                                  	; Return with:
  1174                                  	; Carry clear if no error
  1175                                  	; AH = 0
  1176                                  	;
  1177                                  	; Carry set on error
  1178                                  	; AH = error code
  1179                                  	;
  1180                                  	; All other registers are preserved.
  1181                                  	;
  1182                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1183                                  fn05:
  1184 00000308 83EC0A                  	sub sp, fmt_stack            ; allocate stack space
  1185                                  
  1186 0000030B E8FA00                  	call check_DL                ; sets DI
  1187 0000030E B401                    	mov ah, ERR_invalid_command
  1188 00000310 7269                    	jc .exit
  1189                                  
  1190 00000312 06                      	pushm es                     ; save ES
  1191 00000313 6A00                    	push 0
  1192 00000315 07                      	popm es
  1193 00000316 8CCB                    	mov bx, cs                   ; get CS segment
  1194 00000318 263B1E7A00              	es cmp bx, [1Eh * 4 + 2]     ; check segment is CS
  1195 0000031D 755C                    	jne .exit                    ; (will restore stack)
  1196                                  
  1197 0000031F 268B1E7800              	es mov bx, [1Eh * 4]         ; get CS:BX as disk param table pointer
  1198 00000324 07                      	popm es                      ; restore Stack
  1199                                  
  1200 00000325 E86801                  	call motor_on                ; use DI to start motor
  1201                                  
  1202 00000328 E80C02                  	call Seek                    ; use CH to seek to track
  1203                                  	; recalibrate is possible
  1204 0000032B 724E                    	jc .exit                     ; AH is error code
  1205                                  
  1206 0000032D E8AB01                  	call make_head_unit          ; AL is next byte
  1207 00000330 88C4                    	mov ah, al                   ; save head / unit in AH
  1208                                  
  1209 00000332 571E06                  	pushm es, ds, di
  1210                                  
  1211 00000335 160E                    	pushm cs, ss
  1212 00000337 1F07                    	popm ds, es
  1213 00000339 8D7EF6                  	lea di, [bp + fmt_cmd]
  1214 0000033C 8D7703                  	lea si, [bx + DTAB_N_param]
  1215                                  
  1216 0000033F B00D                    	mov al, CMD_FORMAT_A_TRACK
  1217 00000341 803C00                  	cmp byte [si], 0             ; is N==0
  1218 00000344 7402                    	je .2
  1219 00000346 0C40                    	or al, CMD_MF                ; MFM recording
  1220                                  .2:
  1221 00000348 AB                      	stosw                        ; AH=head / unit, AL=format cmd
  1222 00000349 A4                      	movsb                        ; set N
  1223 0000034A AC                      	lodsb                        ; get SC
  1224 0000034B 88C1                    	mov cl, al                   ; save SC in AL
  1225 0000034D AA                      	stosb                        ; set SC
  1226 0000034E 83C602                  	add si, 2                    ; advance to GPL3
  1227 00000351 A5                      	movsw                        ; set GPL3 and Fill
  1228                                  
  1229 00000352 8D76F6                  	lea si, [bp + fmt_cmd]
  1230 00000355 071F5F                  	popm es, ds, di              ; restore regs
  1231                                  
  1232 00000358 30ED                    	xor ch, ch                   ; CX = sector count
  1233 0000035A C1E102                  	shl cx, 2                    ; CX = byte count of param table
  1234                                  
  1235 0000035D 53                      	pushm bx                     ; save DTAB pointer
  1236                                  
  1237 0000035E 8B4608                  	mov ax, [offset_BX + bp]     ; get Xfer address offset
  1238 00000361 8CC3                    	mov bx, es                   ; segment to AX
  1239 00000363 89DA                    	mov dx, bx                   ; and to DX
  1240 00000365 C1EB0C                  	shr bx, 12                   ; high 4 bits of address
  1241 00000368 C1E204                  	shl dx, 4                    ; high part of offset from segment
  1242 0000036B 01D0                    	add ax, dx                   ; form low 16 bits of 20 - bit address
  1243 0000036D 83D300                  	adc bx, 0                    ; and carry into the high bits
  1244                                  
  1245 00000370 8CD2                    	mov dx, ss                   ; DX:SI points at command start
  1246                                  
  1247                                  	;.marker:
  1248                                  	; BX:AX transfer 20 - bit address in memory
  1249                                  	; CX transfer byte count
  1250                                  	; DX:SI pointer to 9 - byte FDC command
  1251                                  	;
  1252 00000372 80263E0000              	and byte [fdc_drv_calib], 00h ;POST no interrupts received
  1253                                  
  1254 00000377 E88401                  	call xfer_format_track       ; format the track
  1255                                  
  1256 0000037A 5B                      	popm bx                      ; restor DTAB pointer (CS:BX)
  1257                                  	;;; jc .exit ; AH is set to error code
  1258                                  
  1259                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;call Check_RW_Status ; get final return code
  1260                                  
  1261                                  
  1262                                  .exit:
  1263 0000037B 8D66FE                  	lea sp, [rwv_return + bp]    ; restore stack location
  1264 0000037E C3                      	ret
  1265                                  
  1266                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1267                                  	; Function 15h Get Disk Type
  1268                                  	;
  1269                                  	; Enter with:
  1270                                  	; AH = 15h
  1271                                  	; DL = drive 0 or 1
  1272                                  	;
  1273                                  	; Return with:
  1274                                  	; Carry clear if no error
  1275                                  	; AH = drive type code
  1276                                  	; 0 = no drive present
  1277                                  	; 1 = floppy without change line support
  1278                                  	; 2 = floppy with change line support
  1279                                  	; 3 = fixed disk
  1280                                  	;
  1281                                  	; Carry set on error
  1282                                  	; AH = error code
  1283                                  	;
  1284                                  	; All other registers are preserved.
  1285                                  	;
  1286                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1287                                  fn15:
  1288 0000037F 30E4                    	xor ah, ah                   ; No drive present
  1289 00000381 E88400                  	call check_DL
  1290 00000384 7309                    	jnc .ok
  1291 00000386 83FFFF                  	cmp di, - 1
  1292 00000389 7503E9A3FC              	je undefined                 ; DL is really bad
  1293 0000038E C3                      	ret                          ; AH=0, no drive present
  1294                                  	; carry will be cleared
  1295                                  .ok:
  1296 0000038F FEC4                    	inc ah                       ; drive ok, no change line support
  1297 00000391 F8                      	clc
  1298 00000392 E991FC                  	jmp exit_pops                ;
  1299                                  
  1300                                  
  1301                                  
  1302                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1303                                  	; Function 16h Get Disk Change Status
  1304                                  	;
  1305                                  	; Enter with:
  1306                                  	; AH = 16h
  1307                                  	; DL = drive 0 or 1
  1308                                  	;
  1309                                  	; Return with:
  1310                                  	; Carry clear
  1311                                  	; AH = 0 disk not changed
  1312                                  	;
  1313                                  	; Carry set
  1314                                  	; AH = 6 disk has been changed
  1315                                  	; 0 error
  1316                                  	;
  1317                                  	; All other registers are preserved.
  1318                                  	;
  1319                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1320                                  fn16:
  1321 00000395 E87000                  	call check_DL
  1322 00000398 7303E994FC              	jc undefined
  1323                                  
  1324 0000039D 89F8                    	mov ax, di                   ; AL = 0, 1 AH = 0
  1325                                  	; AH is now 0
  1326 0000039F FEC0                    	inc al                       ; AL = 1, 2
  1327 000003A1 C0C004                  	rol al, 4                    ; AL = MOEN1 or MOEN2
  1328 000003A4 84063F00                	test [fdc_motor_LDOR], al    ; test if motor running
  1329 000003A8 7502                    	jnz .on
  1330                                  
  1331 000003AA B406                    	mov ah, ERR_disk_removed     ; signal disk changed
  1332                                  .on:
  1333 000003AC C3                      	ret                          ; AH=6, Carry will be set
  1334                                  
  1335                                  
  1336                                  
  1337                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1338                                  	; Function 17h Set Disk Type for Format (PC - AT)
  1339                                  	;
  1340                                  	; Enter with:
  1341                                  	; AH = 17h
  1342                                  	; AL = 00h not used
  1343                                  	; 01h 160, 180, 320, or 360Kb diskette in 360kb drive
  1344                                  	; 02h 360Kb diskette in 1.2Mb drive
  1345                                  	; 03h 1.2Mb diskette in 1.2Mb drive
  1346                                  	; 04h 720Kb diskette in 720Kb drive
  1347                                  	; DL = drive number
  1348                                  	;
  1349                                  	; Return with:
  1350                                  	; AH = 0 success
  1351                                  	; Carry clear
  1352                                  	;
  1353                                  	; Carry set error
  1354                                  	; AH = error code
  1355                                  	;
  1356                                  	; note 1) This function is probably enhanced for the PS / 2 series to detect
  1357                                  	; 1.44 in 1.44 and 720k in 1.44.
  1358                                  	; 2) This function is not supported for floppy disks on the PC or XT.
  1359                                  	; 3) If the change line is active for the specified drive, it is reset.
  1360                                  	; 4) The BIOS sets the data rate for the specified drive and media type.
  1361                                  	; The rate is 250k / sec for double - density media and 500k / sec for high
  1362                                  	; density media. The proper hardware is required.
  1363                                  	; 5) This function is used by DOS <= 3.1
  1364                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1365                                  	;fn17:
  1366                                  	;;; ret
  1367                                  
  1368                                  
  1369                                  
  1370                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1371                                  	; Function 18h Set Media Type For Format (diskette) (AT, XT2, XT / 286, PS / 2)
  1372                                  	;
  1373                                  	; Enter with:
  1374                                  	; AH = 18h
  1375                                  	; CH = max. cylinder number (80 or 40 minus 1)
  1376                                  	; CL = number of sectors (9, 15, 18)
  1377                                  	; DL = drive number
  1378                                  	;
  1379                                  	; Return with:
  1380                                  	; Carry clear - - no errors
  1381                                  	; AH = 00h if requested combination supported
  1382                                  	; ES:DI pointer to 13 - byte parameter table
  1383                                  	;
  1384                                  	; Carry set - - error
  1385                                  	; AH = 01h if function not available
  1386                                  	; 0Ch if not suppported or drive type unknown
  1387                                  	; 80h if there is no media in the drive
  1388                                  	;
  1389                                  	; note 1) A floppy disk must be present in the drive.
  1390                                  	; 2) This function should be called prior to formatting a disk with Int 13h
  1391                                  	; Fn 05h so the BIOS can set the correct data rate for the media.
  1392                                  	; 3) If the change line is active for the specified drive, it is reset.
  1393                                  	; 4) This function is used by DOS >= 3.2
  1394                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1395                                  fn18:
  1396 000003AD E85800                  	call check_DL                ; check validity of drive no.
  1397 000003B0 7303E97CFC              	jc undefined
  1398                                  
  1399 000003B5 E86700                  	call get_disk_type           ; get disk type to AL
  1400 000003B8 3C0B                    	cmp al, L_table
  1401 000003BA 7327                    	jnb .alt
  1402 000003BC 88C3                    	mov bl, al
  1403 000003BE 30FF                    	xor bh, bh
  1404 000003C0 D1E3                    	shl bx, 1
  1405 000003C2 2E8B9F[6600]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1406 000003C7 85DB                    	test bx, bx
  1407 000003C9 743A                    	jz .errC
  1408 000003CB 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1409 000003CF 7512                    	jne .alt                     ; try alternate
  1410 000003D1 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1411 000003D5 750C                    	jne .alt
  1412                                  .found:
  1413 000003D7 E86000                  	call set_media_pointer
  1414 000003DA 895E00                  	mov [offset_DI + bp], bx
  1415 000003DD 8C4E12                  	mov [offset_ES + bp], cs     ; return in ES:DI
  1416 000003E0 30E4                    	xor ah, ah
  1417 000003E2 C3                      	ret
  1418                                  
  1419                                  .alt:
  1420 000003E3 E84000                  	call get_disk_alt_type       ; get disk type to AL
  1421 000003E6 3C0B                    	cmp al, L_table
  1422 000003E8 731B                    	jnb .errC
  1423 000003EA 88C3                    	mov bl, al
  1424 000003EC 30FF                    	xor bh, bh
  1425 000003EE D1E3                    	shl bx, 1
  1426 000003F0 2E8B9F[6600]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1427 000003F5 85DB                    	test bx, bx
  1428 000003F7 740C                    	jz .errC
  1429 000003F9 2E384F04                	cs cmp [DTAB_EOT_nsect + bx], cl ; check number of sectors
  1430 000003FD 7506                    	jne .errC                    ; no match?
  1431 000003FF 2E386F0B                	cs cmp [DTAB_max_cylinder + bx], ch ; check number of cylinders
  1432 00000403 74D2                    	je .found
  1433                                  
  1434 00000405 B40C                    .errC: mov ah, ERR_media_type_not_found
  1435 00000407 C3                      	ret
  1436                                  
  1437                                  
  1438                                  
  1439                                  
  1440                                  
  1441                                  	check cpu_xtal - 0FFh
  1442                                  
  1443                                  
  1444                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1445                                  	; check_DL - - check for valid disk #
  1446                                  	;
  1447                                  	; Return:
  1448                                  	; DI = 0 or 1 if DL is valid floppy
  1449                                  	; Carry clear
  1450                                  	;
  1451                                  	; DI not valid if DL is invalid
  1452                                  	; Carry set
  1453                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1454                                  check_DL:
  1455 00000408 BFFFFF                  	mov di, - 1                  ; invalid DI
  1456 0000040B 80FA02                  	cmp dl, FLOPPY_MAX
  1457 0000040E 730D                    	jnb .err
  1458 00000410 89D7                    	mov di, dx
  1459 00000412 83E701                  	and di, FLOPPY_MAX - 1       ; clear the carry
  1460 00000415 F685F8000F              	test byte [fdc_type + di], 0Fh ; drive present?
  1461 0000041A 7401                    	jz .err
  1462 0000041C C3                      	ret                          ; carry is clear
  1463                                  
  1464 0000041D F9                      .err: stc
  1465 0000041E C3                      	ret
  1466                                  
  1467                                  
  1468                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1469                                  	; get_disk_type
  1470                                  	;
  1471                                  	; Enter with:
  1472                                  	; DI = drive no.
  1473                                  	;
  1474                                  	; Return with:
  1475                                  	; AL = drive type (0..4)
  1476                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1477                                  get_disk_type:
  1478 0000041F 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1479 00000423 240F                    	and al, 0Fh                  ; mask low nibble
  1480 00000425 C3                      	ret
  1481                                  
  1482                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1483                                  	; get_disk_alt_type
  1484                                  	;
  1485                                  	; Enter with:
  1486                                  	; DI = drive no.
  1487                                  	;
  1488                                  	; Return with:
  1489                                  	; AL = drive type (0..4)
  1490                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1491                                  get_disk_alt_type:
  1492 00000426 8A85F800                	mov al, [fdc_type + di]      ; get type byte
  1493 0000042A C0E804                  	shr al, 4
  1494 0000042D C3                      	ret
  1495                                  
  1496                                  
  1497                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1498                                  	; get_media
  1499                                  	;
  1500                                  	; Call with:
  1501                                  	; AL = disk type
  1502                                  	;
  1503                                  	; Return with:
  1504                                  	; CS:BX pointer to 13 - byte disk media table
  1505                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1506                                  get_media:
  1507 0000042E 88C3                    	mov bl, al
  1508 00000430 30FF                    	xor bh, bh
  1509 00000432 D1E3                    	shl bx, 1
  1510 00000434 2E8B9F[6600]            	cs mov bx, [D_table + bx]    ; get offset of DTAB entry
  1511 00000439 C3                      	ret
  1512                                  
  1513                                  
  1514                                  
  1515                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1516                                  	; set_media_pointer
  1517                                  	;
  1518                                  	; Call with:
  1519                                  	; CS:BX pointer to 13 - byte disk media table
  1520                                  	; DS BIOS data area pointer
  1521                                  	;
  1522                                  	; Return with:
  1523                                  	; CS:BX pointer to 13 - byte disk media table
  1524                                  	; Int 1Eh floppy media pointer set
  1525                                  	;
  1526                                  	; Carry Set = new media pointer (needed Specify command)
  1527                                  	; Carry Clear = same media pointer (Specify not needed)
  1528                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1529                                  set_media_pointer:
  1530 0000043A 0651                    	pushm cx, es                 ; save for later
  1531 0000043C 6A00                    	push 0                       ; address interrupt vectors
  1532 0000043E 07                      	pop es                       ; * *
  1533 0000043F 8CC9                    	mov cx, cs
  1534 00000441 26391E7800              	es cmp word [1Eh * 4], bx
  1535 00000446 7508                    	jne .diff
  1536 00000448 26390E7A00              	es cmp word [1Eh * 4 + 2], cx ; segment
  1537 0000044D F8                      	clc
  1538 0000044E 7410                    	jz .same
  1539                                  .diff:
  1540 00000450 26891E7800              	es mov word [1Eh * 4], bx    ; offset
  1541 00000455 26890E7A00              	es mov word [1Eh * 4 + 2], cx ; segment
  1542 0000045A 8EC1                    	mov es, cx
  1543                                  	cnop
  1544 0000045C E80400                  	call Specify                 ; ES:BX is table pointer
  1545 0000045F F9                      	stc
  1546                                  .same:
  1547 00000460 5907                    	popm cx, es                  ; restore DS
  1548 00000462 C3                      	ret
  1549                                  
  1550                                  
  1551                                  
  1552                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1553                                  	; Specify issue specify command to FDC
  1554                                  	;
  1555                                  	; Call with:
  1556                                  	; ES:BX pointer to 13 - byte disk table
  1557                                  	; DS BIOS data area pointer
  1558                                  	;
  1559                                  	; Return with:
  1560                                  	; Nothing
  1561                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1562                                  Specify:
  1563 00000463 56525350                	pushm ax, bx, dx, si
  1564 00000467 E8CBFC                  	call CHECKINT                ;
  1565 0000046A B003                    	mov al, CMD_SPECIFY          ; SPECIFY COMMAND
  1566 0000046C E82CFD                  	call PFDATA                  ; OUTPUT TO FDC
  1567 0000046F B07F                    	mov al, 7Fh                  ; 6 MS STEP, 480 MS HEAD UNLOAD
  1568 00000471 E827FD                  	call PFDATA                  ; OUTPUT TO FDC
  1569 00000474 B005                    	mov al, 05h                  ; 508 MS HEAD LOAD, NON - DMA MODE
  1570 00000476 E822FD                  	call PFDATA                  ; OUTPUT TO FDC
  1571                                  
  1572 00000479 E8B9FC                  	call CHECKINT                ; SEND SEVERAL INTERRUPTS TO ENSURE PROPER STATE
  1573 0000047C E8B6FC                  	call CHECKINT                ;
  1574 0000047F E8B3FC                  	call CHECKINT                ;
  1575 00000482 E8B0FC                  	call CHECKINT                ;
  1576 00000485 E8ADFC                  	call CHECKINT                ;
  1577 00000488 E8AAFC                  	call CHECKINT                ;
  1578 0000048B 585B5A5E                	popm ax, bx, dx, si
  1579 0000048F C3                      	ret
  1580                                  
  1581                                  
  1582                                  
  1583                                  
  1584                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1585                                  	; motor_on Start the drive motor & wait
  1586                                  	;
  1587                                  	; Call with:
  1588                                  	; DI = drive to start (0, 1)
  1589                                  	; CS:BX = drive parameter table pointer
  1590                                  	;
  1591                                  	; Return with:
  1592                                  	; motor is running and startup delay has been taken
  1593                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1594                                  	global motor_on
  1595                                  motor_on:
  1596 00000490 525150                  	pushm ax, cx, dx
  1597 00000493 89F8                    	mov ax, di                   ; drive # to AL
  1598 00000495 0401                    	add al, MOEN1>>4             ; form MOENx >> 4
  1599 00000497 C0E004                  	shl al, 4                    ; form MOENx bitmask
  1600 0000049A 88C4                    	mov ah, al                   ; MOENx - > AH
  1601 0000049C 01F8                    	add ax, di                   ; MOENx + DSELx - > AL
  1602                                  
  1603 0000049E B124                    	mov cl, 36                  ;2 seconds
  1604 000004A0 880E4000                	mov byte [fdc_motor_ticks], cl ; set long timer = 2 seconds
  1605                                  
  1606 000004A4 84263F00                	test byte [fdc_motor_LDOR], ah ; motor already on?
  1607 000004A8 88C5                    	mov ch, al
  1608 000004AA 750F                    	jnz .its_on
  1609                                  
  1610                                  	; motor is not running
  1611 000004AC 2E8B470A                	cs mov ax, [DTAB_startup + bx] ; get startup delay in 1 / 8 seconds
  1612 000004B0 98                      	cbw
  1613 000004B1 6BC07D                  	imul ax, 125                 ; * 125 ms
  1614 000004B4 B236                    	mov dl, 54
  1615 000004B6 F6F2                    	div dl                       ; divided by 54ms / tick
  1616 000004B8 40                      	inc ax                       ; one more tick for good measure
  1617 000004B9 28C1                    	sub cl, al                   ; CL is tick to wait for
  1618                                  
  1619                                  	; if motor was already running, then CL has not been changed
  1620                                  	; Do the select
  1621                                  .its_on:
  1622 000004BB 322E3F00                	xor ch, [fdc_motor_LDOR]     ; set selected bits
  1623 000004BF 80E531                  	and ch, (MOEN_MASK | DSEL_MASK)
  1624 000004C2 302E3F00                	xor [fdc_motor_LDOR], ch
  1625 000004C6 E864FC                  	call out_LDOR_mem            ; Motor Starts here, or continues
  1626                                  
  1627 000004C9 380E4000                .wait: cmp [fdc_motor_ticks], cl ; has tick counter expired?
  1628 000004CD 77F9                    	ja .wait - 1
  1629                                  
  1630                                  	; reduce timer to turn - off delay time
  1631 000004CF 2E8A4F02                	cs mov cl, [DTAB_turnoff_ticks + bx] ; 2 seconds
  1632 000004D3 880E4000                	mov [fdc_motor_ticks], cl
  1633                                  
  1634 000004D7 58595A                  	popm ax, cx, dx
  1635 000004DA C3                      	ret
  1636                                  
  1637                                  
  1638                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1639                                  	; make_head_unit
  1640                                  	;
  1641                                  	; Enter with:
  1642                                  	; DH = head number
  1643                                  	; DI = unit number
  1644                                  	;
  1645                                  	; Return with:
  1646                                  	; AL = 0000 0huu
  1647                                  	; Carry clear
  1648                                  	;
  1649                                  	; Carry is set on error
  1650                                  	;
  1651                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1652                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1653                                  make_head_unit:
  1654 000004DB 88F0                    	mov al, dh                   ; head number to AL
  1655 000004DD A8FE                    	test al, ~1                  ; check for head 0 or 1
  1656 000004DF F9                      	stc                          ; set to signal error
  1657 000004E0 7507                    	jnz .err
  1658 000004E2 2401                    	and al, 1                    ; defensive programming
  1659 000004E4 C0E002                  	shl al, 2                    ; shift H to position
  1660 000004E7 09F8                    	or ax, di                    ; clear the carry
  1661 000004E9 C3                      .err: ret
  1662                                  
  1663                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1664                                  	; xfer_read_sector
  1665                                  	;
  1666                                  	; Call with:
  1667                                  	; BX:AX transfer address in memory
  1668                                  	; CX transfer byte count
  1669                                  	; DX:SI pointer to 9 - byte FDC command
  1670                                  	;
  1671                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1672                                  xfer_read_sector:
  1673 000004EA 061E56525153            	pushm bx, cx, dx, si, ds, es
  1674                                  
  1675                                  	; push cx
  1676                                  	; mov cx, 9 ; 9 - byte FDC command
  1677                                  	; call output_cmd_to_fdc
  1678                                  	; pop cx
  1679                                  
  1680                                  	; mov si, ax
  1681                                  	; mov es, bx ; DS:SI is now the destination
  1682                                  
  1683                                  	;.1:
  1684                                  	; call get_msr ; get status
  1685                                  	;
  1686                                  	; test al, 0b10000000
  1687                                  	; jnz .1 ; FDC IS NOT READY, WAIT FOR IT
  1688                                  	;
  1689                                  	; test al, 0b00100000
  1690                                  	; jz .timeout ; EXECUTION MODE? NO, ERROR
  1691                                  	;
  1692                                  	; call get_data
  1693                                  	; es mov al, [si + 1] ; record byte of data
  1694                                  	; loop .1
  1695                                  	;
  1696                                  	; mov dx, FDC_TC
  1697                                  	; in al, dx
  1698 000004F0 30E4                    	Okay
  1699 000004F2 EB03                    	jmp .99
  1700                                  
  1701                                  .timeout:
  1702 000004F4 B485                    	mov ah, ERR_85
  1703 000004F6 F9                      	Error
  1704                                  .99:
  1705 000004F7 5B595A5E1F07            	popm bx, cx, dx, si, ds, es
  1706 000004FD C3                      	ret
  1707                                  
  1708                                  
  1709                                  
  1710                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1711                                  	; xfer_write_sector
  1712                                  	; xfer_format_track (only command count is different)
  1713                                  	;
  1714                                  	; Call with:
  1715                                  	; BX:AX transfer address in memory
  1716                                  	; CX transfer byte count
  1717                                  	; DX:SI pointer to 9 - byte FDC command
  1718                                  	;
  1719                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1720                                  xfer_format_track:
  1721                                  xfer_write_sector:
  1722                                  	; push dx
  1723                                  
  1724                                  	; ; BX:AX is the transfer source address
  1725                                  	; mov dx, DMA0 + DMASPL ; set low source address
  1726                                  	; call dma_outd
  1727                                  
  1728                                  	; xor bx, bx
  1729                                  	; mov ax, FDC_DACK
  1730                                  
  1731                                  	; ; BX:AX is the transfer destination port
  1732                                  	; mov dx, DMA0 + DMADPL ; set low destination port
  1733                                  	; call dma_outd
  1734                                  
  1735                                  	; mov ax, cx ; total byte count
  1736                                  	; out dx, ax ; set terminal count
  1737                                  
  1738                                  	; mov ax, [rwv_dma + bp] ; get Control register
  1739                                  	; mov dx, DMA0 + DMACW
  1740                                  	; out dx, ax ; starts the DMA
  1741                                  
  1742                                  	; pop dx ; reset DX:SI command pointer
  1743                                  	;
  1744                                  	; mov cx, 9 ; 9 - byte FDC command
  1745                                  	; ss test byte [si], 01000b ; test for FORMAT command
  1746                                  	; jz .4
  1747                                  	; mov cx, 6 ; it is FORMAT
  1748                                  	;.4:
  1749                                  	; call output_cmd_to_fdc
  1750                                  
  1751                                  
  1752                                  	; mov bx, DMA0 + DMADPL ; Destination to be updated
  1753                                  	; mov cx, FDC_DACK_TC
  1754                                  
  1755                                  	; jmp xfer_common_wait
  1756                                  
  1757                                  
  1758                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1759                                  	; xfer_verify_sector
  1760                                  	;
  1761                                  	; Call with:
  1762                                  	; BX:AX transfer address in memory
  1763                                  	; CX transfer byte count
  1764                                  	; DX:SI pointer to 9 - byte FDC command
  1765                                  	;
  1766                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1767                                  xfer_verify_sector:
  1768                                  	; push dx
  1769                                  	;
  1770                                  	; xor bx, bx ; BX:AX is transfer address
  1771                                  	; mov ax, (bios_data_seg<<4) + fdc_ctrl_status
  1772                                  	;
  1773                                  	; ; BX:AX is the transfer destination address
  1774                                  	; mov dx, DMA0 + DMADPL ; set low destination
  1775                                  	; call dma_outd
  1776                                  	;
  1777                                  	; mov ax, cx ; total byte count
  1778                                  	; out dx, ax ; set terminal count
  1779                                  	;
  1780                                  	; xor bx, bx
  1781                                  	; mov ax, FDC_DACK
  1782                                  	; ; BX:AX is the transfer source port
  1783                                  	; mov dx, DMA0 + DMASPL ; set low source pointer
  1784                                  	; call dma_outd
  1785                                  	;
  1786                                  	; mov ax, [rwv_dma + bp] ; get Control register
  1787                                  	; mov dx, DMA0 + DMACW
  1788                                  	; out dx, ax ; starts the DMA
  1789                                  	;
  1790                                  	; pop dx ; reset DX:SI command pointer
  1791                                  	;
  1792                                  	; mov cx, 9 ; 9 - byte FDC command
  1793                                  	; call output_cmd_to_fdc
  1794                                  	;
  1795                                  	;
  1796                                  	; mov bx, DMA0 + DMASPL
  1797                                  	; mov cx, FDC_DACK_TC
  1798                                  	;
  1799                                  	; jmp xfer_common_wait
  1800                                  
  1801                                  
  1802                                  
  1803                                  
  1804                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1805                                  	; recalibrate
  1806                                  	;
  1807                                  	; Enter with:
  1808                                  	; DI = drive number
  1809                                  	; CS:BX = parameter area pointer
  1810                                  	; DS = BIOS data area pointer
  1811                                  	;
  1812                                  	; Return with:
  1813                                  	; Carry = 0 - - okay
  1814                                  	;
  1815                                  	; Carry = 1 - - error
  1816                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1817                                  recalibrate:
  1818 000004FE 565251                  	pushm cx, dx, si
  1819                                  	;
  1820                                  
  1821                                  	%if SOFT_DEBUG & DUMP
  1822                                  	pushm f                      ;, ax, bx, cx, dx, es
  1823                                  	mov al, ah                   ; save AH in AL
  1824                                  	lahf                         ; get flags
  1825                                  	mov bh, ch
  1826                                  	mov bl, [fdc_cylinder + di]
  1827                                  	push bx
  1828                                  	push cs                      ; far pointer to ...
  1829                                  	push fnrecal                 ; format
  1830                                  	call _cprintf
  1831                                  	add sp, 6
  1832                                  	popm f                       ;, ax, bx, cx, dx, es
  1833                                  	%endif
  1834                                  
  1835 00000501 E831FC                  	call CHECKINT
  1836 00000504 722C                    	jc .9
  1837                                  
  1838 00000506 E887FF                  	call motor_on
  1839 00000509 B007                    	mov al, CMD_RECALIBRATE      ; RECAL TO TRACK 0
  1840 0000050B E88DFC                  	call PFDATA                  ; SEND IT
  1841 0000050E B001                    	mov al, ST0_US               ; mask to 2 drives
  1842 00000510 21F8                    	and ax, di                   ; unit number to AL
  1843 00000512 E886FC                  	call PFDATA                  ; SEND THAT TOO
  1844                                  	;
  1845 00000515 B900F1                  	mov cx, 0F100h                 ;setup timeout
  1846                                  .1:
  1847 00000518 E8F8FB                  	call wait12
  1848 0000051B E817FC                  	call CHECKINT
  1849 0000051E E8EBFB                  	call get_msr                 ; READ SEEK STATUS
  1850 00000521 A80F                    	test al, 0fh                 ; ANY DRIVES SEEKING?
  1851 00000523 E0F3                    	loopnz .1                    ; YES, WAIT FOR THEM
  1852 00000525 750B                    	jnz .9
  1853                                  
  1854 00000527 C685940000              	mov byte [fdc_cylinder + di], 0 ; set new cylinder number
  1855                                  .7:
  1856 0000052C 30E4                    	Okay                         ;
  1857 0000052E 595A5E                  	popm cx, dx, si              ; restore
  1858 00000531 C3                      	ret
  1859                                  .9:
  1860 00000532 F9                      	Error                        ; signal error
  1861 00000533 595A5E                  	popm cx, dx, si              ; restore
  1862 00000536 C3                      	ret
  1863                                  
  1864                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1865                                  	; Seek seek to proper cylinder
  1866                                  	;
  1867                                  	; Call with:
  1868                                  	; CH = cylinder to which to position heads
  1869                                  	; CS:BX = disk parameter area
  1870                                  	; DI = unit number
  1871                                  	; DS = BIOS data area pointer
  1872                                  	;
  1873                                  	; Return with:
  1874                                  	; Carry = 0 success
  1875                                  	;
  1876                                  	; Carry = 1 error
  1877                                  	;
  1878                                  	; Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1879                                  	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1880                                  Seek:
  1881 00000537 565251                  	pushm cx, dx, si
  1882                                  
  1883                                  ;	cmp ch,00h
  1884                                  ;	je .dorecal
  1885                                  
  1886                                  	; check for a recalibration needed
  1887                                  ;	mov al, [fdc_cylinder + di]  ; get present cylinder (0FFh forces recalibrate)
  1888                                  ;	cmp al,0FFh
  1889                                  ;	je .dorecal
  1890                                  
  1891                                  ;	jmp .no_recal
  1892                                  
  1893                                  ;.dorecal
  1894                                  ;	mov si, 2                    ; two recalibrates max.
  1895                                  
  1896                                  ;.rerecal:
  1897                                  ;	call recalibrate
  1898                                  ;	jnc .no_recal
  1899                                  ;	dec si
  1900                                  ;	Error
  1901                                  ;	jz .exit                     ; two have failed
  1902                                  ;	jmp .rerecal                 ; try again
  1903                                  
  1904                                  ;.no_recal:
  1905                                  ;
  1906                                  ;	cmp ch, [fdc_cylinder + di]  ; sought : present cylinder
  1907                                  ;	je .okay
  1908                                  
  1909                                  	; we are not on the cylinder we want
  1910                                  
  1911                                  	;cs cmp ch, [DTAB_max_cylinder + bx] ; validate cylinder number
  1912                                  	;ja .invalid
  1913                                  
  1914                                  ;.valid:
  1915                                  	; ANY INTERUPT PENDING
  1916                                  	; IF YES FIND OUT WHY / CLEAR
  1917 0000053A 88AD9400                	mov [fdc_cylinder + di], ch  ; set new cylinder number
  1918                                  
  1919 0000053E E8F4FB                  	call CHECKINT
  1920 00000541 7230                    	jc .err
  1921                                  
  1922 00000543 E84AFF                  	call motor_on
  1923 00000546 B00F                    	mov al, CMD_SEEK             ; SEEK COMMAND
  1924 00000548 E850FC                  	call PFDATA                  ; PUSH COMMAND
  1925 0000054B B001                    	mov al, ST0_US               ; mask to 2 drives
  1926 0000054D 21F8                    	and ax, di                   ; unit number to AL
  1927 0000054F E849FC                  	call PFDATA                  ; SAY WHICH UNIT
  1928 00000552 8A859400                	mov al, [fdc_cylinder + di]  ; set new cylinder number
  1929 00000556 E842FC                  	call PFDATA                  ; SEND THAT TOO
  1930                                  	;
  1931 00000559 B900F1                  	mov cx, 0f100h                 ;setup timeout
  1932                                  .1:
  1933 0000055C E8B4FB                  	call wait12
  1934 0000055F E8D3FB                  	call CHECKINT
  1935 00000562 E8A7FB                  	call get_msr                 ; READ SEEK STATUS
  1936 00000565 A80F                    	test al, 0fh                 ; ANY DRIVES SEEKING?
  1937 00000567 E0F3                    	loopnz .1                    ; YES, WAIT FOR THEM
  1938 00000569 7508                    	jnz .err
  1939                                  
  1940                                  	%if SOFT_DEBUG & DUMP
  1941                                  	pushm f                      ;, ax, bx, cx, dx, es
  1942                                  	mov al, ah                   ; save AH in AL
  1943                                  	lahf                         ; get flags
  1944                                  	mov bh, ch
  1945                                  	mov bl, [fdc_cylinder + di]
  1946                                  	push bx
  1947                                  	push cs                      ; far pointer to ...
  1948                                  	push fnseek                  ; format
  1949                                  	call _cprintf
  1950                                  	add sp, 6
  1951                                  	popm f                       ;, ax, bx, cx, dx, es
  1952                                  	%endif
  1953                                  .okay:
  1954 0000056B 30E4                    	Okay
  1955                                  .exit:
  1956 0000056D 595A5E                  	popm cx, dx, si
  1957 00000570 C3                      	ret
  1958                                  .invalid:
  1959                                  	; error - - the cylinder requested is invalid for this drive
  1960 00000571 B486                    	mov ah, ERR_86
  1961 00000573 F9                      .err:   Error
  1962 00000574 C6859400FF              	mov byte [fdc_cylinder + di], 0ffh  ; set error cylinder number
  1963 00000579 EBF2                    	jmp .exit                    ; jump WAY out
  1964                                  
  1965                                  
  1966                                  	%if SOFT_DEBUG & DUMP
  1967                                  fcrw:
  1968                                  	db NL, "RW ST0 %02x ST1 %02x ST2 %02x C + %02x H + %02x S + %02x N %x", 0
  1969                                  rwvc:
  1970                                  	db NL, "VC AX %04x CHS %02x:%02x:%02x DL %02x ES:BX %04x:%04x", 0
  1971                                  fnret:
  1972                                  	db NL, "RET AH %02x CY %d CMD %02x %02x", NL, 0
  1973                                  fnldor:
  1974                                  	db NL, "LDOR = %02x ", NL, 0
  1975                                  fnseek:
  1976                                  	db NL, "SEEK = %04x ", NL, 0
  1977                                  fnrecal:
  1978                                  	db NL, "RECALIBRATE = %04x ", NL, 0
  1979                                  fnmsr:
  1980                                  	db NL, "MSR = %04x ", NL, 0
  1981                                  fndio:
  1982                                  	db NL, "DIO = %04x ", NL, 0
  1983                                  fncheckint:
  1984                                  	db NL, "Checkint = %04x ", NL, 0
  1985                                  fnpferr:
  1986                                  	db NL, "PFERR = %04x ", NL, 0
  1987                                  fngferr:
  1988                                  	db NL, "GFERR = %04x, %04x ", NL, 0
  1989                                  	%endif
