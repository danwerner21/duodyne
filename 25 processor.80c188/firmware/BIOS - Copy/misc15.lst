     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; MISC15.ASM -- Miscellaneous BIOS calls (mostly int 15h)
     3                                  ;  with mods for version -45 assembly
     4                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     5                                  ;
     6                                  ;   This version is for assembly by  NASM 0.98.39 or later
     7                                  ;
     8                                  ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
     9                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    10                                  ;
    11                                  ; This program is free software: you can redistribute it and/or modify
    12                                  ; it under the terms of the GNU General Public License as published by
    13                                  ; the Free Software Foundation, either version 3 of the License, or
    14                                  ; (at your option) any later version.
    15                                  ;
    16                                  ; This program is distributed in the hope that it will be useful,
    17                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    18                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    19                                  ; GNU General Public License for more details.
    20                                  ;
    21                                  ; You should have received a copy of the GNU General Public License
    22                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    23                                  ;
    24                                  ; Updated for the Duodyne 80c188 SBC
    25                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                                  %include        "config.asm"
    27                              <1> ;/*
    28                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                              <1> ; ANSI.CFG
    30                              <1> ;   Copied to CONFIG.ASM for general release.
    31                              <1> ;
    32                              <1> ;       Modify the parameters below to reflect your system
    33                              <1> ;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    38                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    40                              <1> ;
    41                              <1> ; Define the serial terminal that the Video BIOS must emulate
    42                              <1> ; Set one of the following to 1
    43                              <1> ; If you have no idea what to choose, set TTY to 1
    44                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    45                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    46                              <1> ANSI    equ     1       ; very smart, like a VT-100
    47                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    48                              <1> ; others may get added in the future
    49                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    50                              <1> ;
    51                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    52                              <1> ;UART_RATE	equ	0		; 1200
    53                              <1> ;UART_RATE	equ	1		; 2400
    54                              <1> ;UART_RATE	equ	2		; 4800
    55                              <1> UART_RATE	equ	3		; 9600
    56                              <1> ;UART_RATE	equ	4		; 19200
    57                              <1> ;UART_RATE	equ	5		; 38400
    58                              <1> ;UART_RATE	equ	6		; 57600
    59                              <1> ;UART_RATE	equ	7		; 115200
    60                              <1> 
    61                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    62                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    63                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    64                              <1> 						; but not ANSI
    65                              <1> ; Define the size of the ROM image on the system in Kilobytes
    66                              <1> ; It may be smaller than the actual EPROM in use.
    67                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    68                              <1> %ifndef ROM
    69                              <1> ROM             equ     32              ; 64 is the default
    70                              <1> %endif
    71                              <1> 
    72                              <1> ; Define the number of Wait States at which the ROM operates
    73                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    74                              <1> 
    75                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    76                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    77                              <1> RAM_DOS         equ     640
    78                              <1> 
    79                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    80                              <1> ; the default is 512 kilobytes
    81                              <1> RAM             equ     512             ; (512 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States at which the RAM operates
    84                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    87                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    88                              <1> 
    89                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    90                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    91                              <1> 
    92                              <1> ; Define the time zone in which we build the Relocatable BIOS
    93                              <1> %ifndef TIMEZONE
    94                              <1> %define TIMEZONE "CST"
    95                              <1> %endif
    96                              <1> 
    97                              <1> ; Has the REDBUG debugger been loaded?
    98                              <1> %ifndef SOFT_DEBUG
    99                              <1> %define SOFT_DEBUG 0
   100                              <1> %endif
   101                              <1> 
   102                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   103                              <1> %ifndef TBASIC
   104                              <1> TBASIC          equ     1		; default is 1
   105                              <1> %endif
   106                              <1> 
   107                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   108                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   109                              <1> %ifndef FPEM
   110                              <1> FPEM            equ     1               ; default is 1
   111                              <1> %endif
   112                              <1> 
   113                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   114                              <1> EMM_BOARDS      equ     0
   115                              <1> 
   116                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   117                              <1> ; or at locations 0280h..3FFh in low memory?
   118                              <1> %if SOFT_DEBUG
   119                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   120                              <1> %else
   121                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   122                              <1> %endif
   123                              <1> 
   124                              <1> ; Define the size of the EPROM that is to be installed on the system
   125                              <1> ; It may be larger than the actual ROM image to be generated.
   126                              <1> %ifndef CHIP
   127                              <1> CHIP            equ     64
   128                              <1> %endif
   129                              <1> 
   130                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   131                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   132                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   133                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   134                              <1> 
   135                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   136                              <1> ; If the wiring update is installed, or you have a later board, then
   137                              <1> ; set this to 0.  If you are using the software workaround, then set this
   138                              <1> ; to 1.  The rev 1.0 board has this fix already.
   139                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   140                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   141                              <1> 
   142                              <1> ; Define the UART oscillator speed
   143                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   144                              <1> 
   145                              <1> 
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> ; end of the User configuration
   148                              <1> ;       Do Not modify anything below this point
   149                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   150                              <1> 
   151                              <1> ; Define existence of any uart chip
   152                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   153                              <1> startuplength   equ     512                     ; may be up to 1024
   154                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   155                              <1> highrom         equ     (ROM*400h)&0FFFFh
   156                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   157                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   158                              <1> 
   159                              <1> 
   160                              <1> %define ARG(n) [bp+2+(n)*2]
   161                              <1> 
   162                              <1> %macro  check   1.nolist
   163                              <1>  %if (%1)
   164                              <1>    %error Check Failure: %1
   165                              <1>  %endif
   166                              <1> %endm
   167                              <1> %macro  range   3.nolist
   168                              <1>  %if (%1)<(%2)
   169                              <1>    %error Out of Range: %1
   170                              <1>  %elif (%1)>(%3)
   171                              <1>    %error Out of Range: %1
   172                              <1>  %endif
   173                              <1> %endm
   174                              <1> _terminal equ UART
   175                              <1>  check   RAM_DOS&15
   176                              <1>  check   RAM&(RAM-1)
   177                              <1>  check   ROM&(ROM-1)
   178                              <1>  range   RAM,32,512
   179                              <1>  range   ROM,32,256
   180                              <1>  range   RAM_WS,0,3
   181                              <1>  range   ROM_WS,0,3
   182                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   183                              <1>  range   LCL_IO_WS,0,3
   184                              <1>  range   BUS_IO_WS,0,3
   185                              <1>  range   UART_OSC,500000,16000000
   186                              <1>  range   UART_RATE,0,7
   187                              <1>  range	 UART,0,1
   188                              <1>  range	 _terminal,1,2
   189                              <1> 
   190                              <1> %ifndef SOFT_DEBUG
   191                              <1> %define SOFT_DEBUG 0
   192                              <1> %endif
   193                              <1> 
   194                              <1> %ifndef TRACE
   195                              <1> %define TRACE 0
   196                              <1> %endif
   197                              <1> 
   198                              <1> %ifdef MAKE_OBJECT_FILE
   199                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   200                              <1>         export _ROMsize
   201                              <1>         export _CHIPsize
   202                              <1> _ROMsize        dw      ROM
   203                              <1> _CHIPsize       dw      CHIP
   204                              <1> %endif
   205                              <1> ; end of the Hardware configuration file
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> ;*/
    27                                  %include        "cpuregs.asm"
    28                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                              <1> ; CPUREGS.ASM
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ;
    32                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    33                              <1> ;
    34                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    35                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    36                              <1> ;
    37                              <1> ; This program is free software: you can redistribute it and/or modify
    38                              <1> ; it under the terms of the GNU General Public License as published by
    39                              <1> ; the Free Software Foundation, either version 3 of the License, or
    40                              <1> ; (at your option) any later version.
    41                              <1> ;
    42                              <1> ; This program is distributed in the hope that it will be useful,
    43                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    44                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    45                              <1> ; GNU General Public License for more details.
    46                              <1> ;
    47                              <1> ; You should have received a copy of the GNU General Public License
    48                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    49                              <1> ;
    50                              <1> ; Updated for the Duodyne 80c188 SBC
    51                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    52                              <1> %include	"macros.inc"
    53                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    54                              <2> ; MACROS.INC  
    55                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                              <2> ;
    57                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    58                              <2> ;
    59                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    60                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    61                              <2> ;
    62                              <2> ; This program is free software: you can redistribute it and/or modify
    63                              <2> ; it under the terms of the GNU General Public License as published by
    64                              <2> ; the Free Software Foundation, either version 3 of the License, or
    65                              <2> ; (at your option) any later version.
    66                              <2> ;
    67                              <2> ; This program is distributed in the hope that it will be useful,
    68                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    69                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    70                              <2> ; GNU General Public License for more details.
    71                              <2> ;
    72                              <2> ; You should have received a copy of the GNU General Public License
    73                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    74                              <2> ;
    75                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    76                              <2> 
    77                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    78                              <2> ;
    79                              <2> ;
    80                              <2> %ifndef __MACROS_DEFINED_
    81                              <2> %define __MACROS_DEFINED_ 1
    82                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                              <2> ;
    84                              <2> ; some useful macros:
    85                              <2> ;
    86                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    87                              <2> ;
    88                              <2> 	cpu	186
    89                              <2> 
    90                              <2> %imacro setloc  1.nolist
    91                              <2>  times   (%1-($-$$)) db 0FFh
    92                              <2> %endm
    93                              <2> 
    94                              <2> %imacro db_lo   1
    95                              <2>  db (%1)&255
    96                              <2> %endm
    97                              <2> 
    98                              <2> %imacro cnop    0.nolist
    99                              <2> %if SOFT_DEBUG
   100                              <2>         nop
   101                              <2> %endif
   102                              <2> %endm
   103                              <2> 
   104                              <2> %imacro popm 1-*.nolist
   105                              <2> %rep %0
   106                              <2> %ifidni %1,ALL
   107                              <2>  popa
   108                              <2> %elifidni %1,F
   109                              <2>  popf
   110                              <2> %else
   111                              <2>  pop %1
   112                              <2> %ifidni %1,DS
   113                              <2>  cnop
   114                              <2> %elifidni %1,ES
   115                              <2>  cnop
   116                              <2> %endif
   117                              <2> %endif
   118                              <2> %rotate 1
   119                              <2> %endrep
   120                              <2> %endm
   121                              <2> 
   122                              <2> %imacro pushm 1-*.nolist
   123                              <2> %rep %0
   124                              <2> %rotate -1
   125                              <2> %ifidni %1,ALL
   126                              <2>  pusha
   127                              <2> %elifidni %1,F
   128                              <2>  pushf
   129                              <2> %else
   130                              <2>  push %1
   131                              <2> %endif
   132                              <2> %endrep
   133                              <2> %endm
   134                              <2> 
   135                              <2> ;
   136                              <2> ; added from the 386EX project
   137                              <2> ;
   138                              <2> 
   139                              <2> ; call arguments
   140                              <2> %define ARG(n) [bp+2+(n)*2]
   141                              <2> 
   142                              <2> ;
   143                              <2> ; format of the BYTE initialization table:  address, byte
   144                              <2> ;
   145                              <2> %imacro  binit 2
   146                              <2>         dw      %1
   147                              <2>         db      %2
   148                              <2> %endmacro
   149                              <2> ; end with DW -1
   150                              <2> 
   151                              <2> ;
   152                              <2> ; format of the WORD initialization table:  address, word
   153                              <2> ;
   154                              <2> %imacro  winit 2
   155                              <2>         dw      %1
   156                              <2>         dw      %2
   157                              <2> %endmacro
   158                              <2> ; end with DW -1
   159                              <2> 
   160                              <2> 
   161                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   162                              <2> %imacro get_bda	1.nolist
   163                              <2> 	push	0x0040
   164                              <2> 	pop	%1
   165                              <2> 	cnop
   166                              <2> %endm
   167                              <2> 
   168                              <2> 
   169                              <2> %endif
    53                              <1> 
    54                              <1> 	cpu     186
    55                              <1> ;
    56                              <1> ;
    57                              <1> ; IBM model byte -- must be less than a 286
    58                              <1> ;
    59                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    60                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    61                              <1> 
    62                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    63                              <1> SUBMODEL_BYTE		equ	00h	;  "
    64                              <1> 
    65                              <1> 
    66                              <1> ; 80188 peripheral control register block address
    67                              <1> CPU_CSCR	        equ	0FF00h
    68                              <1> 
    69                              <1> ; Compatible Mode registers
    70                              <1> 
    71                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    72                              <1> 
    73                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    74                              <1> 
    75                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    76                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    77                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    78                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    79                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    80                              <1> 
    81                              <1> ; Enhanced Mode registers
    82                              <1> 
    83                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    84                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    85                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    86                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    87                              <1> 
    88                              <1> 
    89                              <1> ; On-board internal peripheral equates
    90                              <1> ; Programmable Interrupt Controller
    91                              <1> PIC	        equ	CPU_CSCR+020H
    92                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    93                              <1> PIC_POLLR	equ	PIC+4
    94                              <1> PIC_POLLSR	equ	PIC+6
    95                              <1> PIC_IMASK	equ	PIC+8
    96                              <1> PIC_PMREG	equ	PIC+0AH
    97                              <1> PIC_SRVR	equ	PIC+0CH
    98                              <1> PIC_IRQR	equ	PIC+0EH
    99                              <1> PIC_IRQSR	equ	PIC+10H
   100                              <1> PIC_TCR	        equ	PIC+12H
   101                              <1> PIC_DMA0CR	equ	PIC+14H
   102                              <1> PIC_DMA1CR	equ	PIC+16H
   103                              <1> PIC_I0CON	equ	PIC+18H
   104                              <1> PIC_I1CON	equ	PIC+1AH
   105                              <1> PIC_I2CON	equ	PIC+1CH
   106                              <1> PIC_I3CON	equ	PIC+1EH
   107                              <1> 
   108                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   109                              <1> 
   110                              <1> ; Interrupt masks (Master Mode)
   111                              <1> ;
   112                              <1> mask_timer_all          equ     0001h
   113                              <1> mask_dma0               equ     0004h
   114                              <1> mask_dma1               equ     0008h
   115                              <1> mask_int0               equ     0010h
   116                              <1> mask_int1               equ     0020h
   117                              <1> mask_int2               equ     0040h
   118                              <1> mask_int3               equ     0080h
   119                              <1> 
   120                              <1> 
   121                              <1> 
   122                              <1> ; Timers
   123                              <1> TIM0	        equ	CPU_CSCR+050H
   124                              <1> TIM1	        equ	CPU_CSCR+058H
   125                              <1> TIM2	        equ	CPU_CSCR+060H
   126                              <1> 
   127                              <1> TCNT	        equ	0	; count register
   128                              <1> CMPA	        equ	2	; max count A
   129                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   130                              <1> TCON	        equ	6	; mode/control word
   131                              <1> 
   132                              <1> ; Timer control bits:
   133                              <1> tc_EN           equ     8000h   ; Enable bit
   134                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   135                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   136                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   137                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   138                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   139                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   140                              <1> tc_EXT          equ     0004h   ; External clock
   141                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   142                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   143                              <1> 
   144                              <1> 
   145                              <1> 
   146                              <1> 
   147                              <1> ; DMA
   148                              <1> DMA0	        equ	CPU_CSCR+0C0H
   149                              <1> DMA1	        equ	CPU_CSCR+0D0H
   150                              <1> DMASPL	        equ	0	; source pointer low
   151                              <1> DMASPU	        equ	2	; source pointer high
   152                              <1> DMADPL	        equ	4	; destination pointer low
   153                              <1> DMADPU	        equ	6	; destination pointer high
   154                              <1> DMATC	        equ	8	; terminal count
   155                              <1> DMACW	        equ	0AH	; control word
   156                              <1> 
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> 
   161                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   162                              <1> ;
   163                              <1> ;       SBC-188 external devices
   164                              <1> ;
   165                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   166                              <1> 
   167                              <1> IO_BASE			equ	0400h
   168                              <1> 
   169                              <1> 
   170                              <1> 
   171                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   172                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   173                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   174                              <1> 
   175                              <1> uart_base               equ     IO_BASE+0280h
   176                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   177                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   178                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   179                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   180                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   181                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   182                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   183                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   184                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   185                              <1> uart_sr			equ	uart_base+7	;Scratch
   186                              <1> 
   187                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   188                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   189                              <1> 
   190                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   191                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   192                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   193                              <1> CTRL259		equ	IO_BASE+0238H
   194                              <1> ; LEDS are at addresses 0..3
   195                              <1> ; other control ports on 4..7
   196                              <1> LED0		equ	CTRL259+0
   197                              <1> LED1		equ	LED0+1
   198                              <1> LED2		equ	LED0+2
   199                              <1> LED3		equ	LED0+3
   200                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   201                              <1> ;unused		equ	CTRL259+5
   202                              <1> ;unused		equ	CTRL259+6
   203                              <1> ;unused		equ	CTRL259+7
   204                              <1> 
   205                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   206                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   207                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   208                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   209                              <1> 
   210                              <1> 
   211                              <1> 
   212                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   213                              <1> ; Floppy controller (Duodyne Disk IO)
   214                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   215                              <1> FDC	        equ	IO_BASE+0080H
   216                              <1> FDC_MSR         equ     FDC
   217                              <1> FDC_DATA        equ     FDC+1
   218                              <1> FDC_TC	        equ	FDC+2
   219                              <1> FDC_RES	        equ	FDC+3
   220                              <1> FDC_LDCR	equ	FDC+5
   221                              <1> FDC_LDOR	equ	FDC+6
   222                              <1> FDC_DACK        equ	FDC+6
   223                              <1> FDC_DACK_TC     equ     FDC+7
   224                              <1> 
   225                              <1> 
   226                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   227                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   228                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                              <1> RTC	equ	IO_BASE+0094H
   230                              <1> 
   231                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   232                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   233                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   234                              <1> PPI	        equ	IO_BASE+0088H
   235                              <1> 
   236                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   237                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   238                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   239                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   240                              <1> 
   241                              <1> portA           equ     PPI+0   ;
   242                              <1> portB           equ     PPI+1   ;
   243                              <1> portC           equ     PPI+2   ;
   244                              <1> 
   245                              <1> ; end CPUREGS.ASM
    28                                  %include	"date.asm"
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; date.asm
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ; string 0 is for "startup.asm" inclusion; must be 8 chars exactly
    33                              <1> ; string 1 is for RBIOS.ASM inclusion; should be very readable
    34                              <1> ;
    35                              <1> ; N.B.  version 46 is Rich Cini's version for the 2S1P board
    36                              <1> ;
    37                              <1> ; so we jump from BIOS 045 to 047, the first BIOS to support
    38                              <1> ; the Version 3.0 board (with 1024K memory on-board)
    39                              <1> ;
    40                              <1> ; Definitions for version 3.5-2:
    41                              <1> ;
    42                              <1> ; Updated for the Duodyne 80c188 SBC
    43                              <1> 
    44                              <1> %define DATE_STRING0	"10/27/24"
    45                              <1> %define DATE_STRING1	"27-Oct-2024"
    46                              <1> 
    47                              <1> %define VERSION_MAJOR		3
    48                              <1> %define VERSION_MINOR		5
    49                              <1> %define VERSION_REVISION	2
    50                              <1> %define VERSION_SUFFIX		""
    51                              <1> %define VERSION_SEQUENCE	66
    52                              <1> 
    53                              <1> %define VERSION_STRING		"3.5-D",VERSION_SUFFIX
    54                              <1> 
    55                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    56                              <1> ; Revision information:
    57                              <1> ;  ver.	2.1 -- table-driven support for all IBM floppy types
    58                              <1> ;	2.2 -- Dual IDE driver; CVDU memory sizing
    59                              <1> ;	2.3 -- font_vga corrects (i grave) (n_tilde)
    60                              <1> ;	    &  Dual SDcard & Minix boot
    61                              <1> ;	2.4 -- Int 15h multiprogramming hooks: fn90, fn91 (never done)
    62                              <1> ;	3.0 -- VGA3 support
    63                              <1> ;	3.1 -- SBC-188 v.3 board support
    64                              <1> ;	3.2 -- IDE8 support on the v.3 board
    65                              <1> ;	3.3 -- add 2S1P board support (2 SIO & PPort)
    66                              <1> ;	3.4 -- floppy drives did not work
    67                              <1> ;	3.5 -- back to 3.3, sequence #51
    68                              <1> ;		change NVRAM battery backup setup to #53
    69                              <1> ;		re-install 3.4 boot fix for FreeDOS
    70                              <1> ;       3.5-D  Remove SBC-188 specific items and customize for Duodyne
    71                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    29                                  %include        "equates.asm"
    30                              <1> ;========================================================================
    31                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    32                              <1> ;========================================================================
    33                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;
    53                              <1> ;========================================================================
    54                              <1> 
    55                              <1>         global  FPEM_segment
    56                              <1> 
    57                              <1> 
    58                              <1> %include "segdef.asm"
    59                              <2> ;========================================================================
    60                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    61                              <2> ;========================================================================
    62                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    63                              <2> ;
    64                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    65                              <2> ;
    66                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    67                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    68                              <2> ;
    69                              <2> ; This program is free software: you can redistribute it and/or modify
    70                              <2> ; it under the terms of the GNU General Public License as published by
    71                              <2> ; the Free Software Foundation, either version 3 of the License, or
    72                              <2> ; (at your option) any later version.
    73                              <2> ;
    74                              <2> ; This program is distributed in the hope that it will be useful,
    75                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    76                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    77                              <2> ; GNU General Public License for more details.
    78                              <2> ;
    79                              <2> ; You should have received a copy of the GNU General Public License
    80                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    81                              <2> ;
    82                              <2> ;========================================================================
    83                              <2> 
    84                              <2> %ifndef __SEGDEF_
    85                              <2> %define __SEGDEF_
    86                              <2> 
    87                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    88                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    89                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    90                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    91                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    92                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    93                              <2> 
    94                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    95                              <2> 
    96                              <2> %endif
    97                              <2> 
    59                              <1> %include "ascii.asm"
    60                              <2> ; ascii.asm
    61                              <2> ;
    62                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    63                              <2> 
    64                              <2> NUL     equ     00h
    65                              <2> BEL     equ     (CTRL & 'G')
    66                              <2> BS      equ     08h		; ^H
    67                              <2> HT      equ     09h		; ^I
    68                              <2> LF	equ	0Ah		; ^J
    69                              <2> NL      equ     LF
    70                              <2> VT	equ	0Bh		; ^K
    71                              <2> FWD	equ	0Ch		; ^L
    72                              <2> CR	equ	0Dh
    73                              <2> XON     equ     (CTRL & 'Q')
    74                              <2> XOFF    equ     (CTRL & 'S')
    75                              <2> DC1     equ     XON
    76                              <2> DC3     equ     XOFF
    77                              <2> ESC     equ	1Bh
    78                              <2> 
    79                              <2> 
    60                              <1> 
    61                              <1> 
    62                              <1> ; POST error codes. Presently one byte but can expand to word.
    63                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    64                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    65                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    66                              <1> ER_FDC	equ	08h		; Bad FDC
    67                              <1> ER_UNK1	equ	10h		; {unassigned}
    68                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    69                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    70                              <1> ER_UNK2	equ	80h		; {unassigned}
    71                              <1> 
    72                              <1> 
    73                              <1> 
    74                              <1> ;; ************************ BIOS Data Segment ******************************
    75                              <1> ;; BIOS data segment - not all will  be used
    76                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    77                              <1> %include "bda.inc"
    78                              <2> ;/*======================================================================
    79                              <2> ; bda.inc -- BIOS data area definitions
    80                              <2> ;========================================================================
    81                              <2> ;   for the N8VEM SBC-188
    82                              <2> ;
    83                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    84                              <2> ;
    85                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    86                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    87                              <2> ;
    88                              <2> ; This program is free software: you can redistribute it and/or modify
    89                              <2> ; it under the terms of the GNU General Public License as published by
    90                              <2> ; the Free Software Foundation, either version 3 of the License, or
    91                              <2> ; (at your option) any later version.
    92                              <2> ;
    93                              <2> ; This program is distributed in the hope that it will be useful,
    94                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    95                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    96                              <2> ; GNU General Public License for more details.
    97                              <2> ;
    98                              <2> ; You should have received a copy of the GNU General Public License
    99                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   100                              <2> ;
   101                              <2> ;========================================================================
   102                              <2> 
   103                              <2> 			;*/ extern				/*
   104                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   105 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   106 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   107 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   108                              <2> ;	dw	?		; 40:10 	; Equipment present word
   109                              <2> ;  						;  = (1 iff floppies) *     1.
   110                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   111                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   112                              <2> ;  						;  + (init crt mode ) *    16.
   113                              <2> ;  						;  + (# of floppies ) *    64.
   114                              <2> ;  						;  + (# serial ports) *   512.
   115                              <2> ;  						;  + (1 iff toy port) *  4096.
   116                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   117                              <2> ;  						;  + (# parallel LPT) * 16384.
   118 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   119 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   120                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   121 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   122 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   123                              <2> ;;---------------[Keyboard data area]------------;
   124 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   125                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   126 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   127 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   128 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   129 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   130                              <2> kbd_buffer_last	equ	$	;*/				/*
   131                              <2> ;;---------------[Diskette data area]------------;
   132 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   133 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   134 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   135 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   136                              <2> ;				Floppy return code stat byte
   137                              <2> ;				;  1 = bad ic 765 command req.
   138                              <2> ;				;  2 = address mark not found
   139                              <2> ;				;  3 = write to protected disk
   140                              <2> ;				;  4 = sector not found
   141                              <2> ;				;  8 = data late (DMA overrun)
   142                              <2> ;				;  9 = DMA failed 64K page end
   143                              <2> ;				; 16 = bad CRC on floppy read
   144                              <2> ;				; 32 = bad NEC 765 controller
   145                              <2> ;				; 64 = seek operation failed
   146                              <2> ;				;128 = disk drive timed out
   147 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   148                              <2> ;;---------------[Video display area]------------;
   149 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   150                              <2> ;			 	; Current CRT mode  (software)
   151                              <2> ;				;  0 = 40 x 25 text (no color)
   152                              <2> ;				;  1 = 40 x 25 text (16 color)
   153                              <2> ;				;  2 = 80 x 25 text (no color)
   154                              <2> ;				;  3 = 80 x 25 text (16 color)
   155                              <2> ;				;  4 = 320 x 200 grafix 4 color
   156                              <2> ;				;  5 = 320 x 200 grafix 0 color
   157                              <2> ;				;  6 = 640 x 200 grafix 0 color
   158                              <2> ;				;  7 = 80 x 25 text (mono card)
   159 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   160 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   161 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   162 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   163 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   164 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   165 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   166 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   167 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   168                              <2> ;;---------------[Used to setup ROM]-------------;
   169 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   170 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   171                              <2> ;;---------------[Timer data area]---------------;
   172 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   173 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   174                              <2> ;;---------------[System data area]--------------;
   175 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   176 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   177                              <2> ;;---------------[Hard disk scratchpad]----------;
   178 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   179                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   180 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   181 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   182                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   183 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   184 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   185                              <2> ;;---------------[EGA stuff]---------------------;
   186 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   187                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   188 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   189 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   190 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   191 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   192 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   193                              <2> ;;---------------[Additional KBD flags]----------------;
   194 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   195 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   196                              <2> ;;---------------[RTC/timer1 data]---------------------;
   197 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   198 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   199 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   200                              <2> ;;---------------[Cassette I/O stuff]------------------;
   201 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   202 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   203                              <2> ;									Post Acknowleged=00;
   204 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   205 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   206 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   207                              <2> ;
   208 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   209 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   210 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   211 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   212                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   213 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   214 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   215 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   216 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   217 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   218 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   219 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   220 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   221 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   222 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   223 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   224 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   225 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   226 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   227 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   228                              <2> ;
   229                              <2> ;
   230                              <2> 
   231 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   232                              <2> 
   233 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   234                              <2> 
   235 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   236 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   237                              <2> 
   238 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   239                              <2> 
   240 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   241                              <2> 
   242 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   243                              <2> 
   244 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   245                              <2> ;								   CPU clock is half of this
   246                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <2> ;
   248                              <2> ;  System configuration stuff below
   249                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   250                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   251                              <2> %if 0				;*/
   252                              <2> #define FIXED_DISK_MAX 4		/*
   253                              <2> %else
   254                              <2> %define FIXED_DISK_MAX 4
   255                              <2> %endif
   256                              <2> %if 0				;*/
   257                              <2> #define PPIDE_driver 1		/*
   258                              <2> %else
   259                              <2> %define PPIDE_driver 1
   260                              <2> %endif
   261                              <2> %if 0				;*/
   262                              <2> #define DIDE_driver 0		/*
   263                              <2> %else
   264                              <2> %define DIDE_driver 0
   265                              <2> %endif
   266                              <2> %if 0				;*/
   267                              <2> #define DISKIO_driver 1		/*
   268                              <2> %else
   269                              <2> %define DISKIO_driver 1
   270                              <2> %endif
   271                              <2> %if 0				;*/
   272                              <2> #define MFPIC_driver 1		/*
   273                              <2> %else
   274                              <2> %define MFPIC_driver 1
   275                              <2> %endif
   276                              <2> %if 0				;*/
   277                              <2> #define DSD_driver 1		/*
   278                              <2> %else
   279                              <2> %define DSD_driver 1
   280                              <2> %endif
   281                              <2> %if 0				;*/
   282                              <2> #define V3IDE8_driver (SBC188==3)		/*
   283                              <2> %else
   284                              <2> %define V3IDE8_driver (SBC188==3)
   285                              <2> %endif
   286                              <2> 				;*/
    78                              <1> 
    79                              <1> ;  this must be the same in EQUATES.H */
    80                              <1> %if SOFT_DEBUG
    81                              <1> %define NBREAK  8
    82                              <1> %endif
    83                              <1> 
    84                              <1> 
    85                              <1> %if 0
    86                              <1>         segment _TEXT
    87                              <1> ;; *************************************************************************
    88                              <1> 
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ;; ************************ DOS Data Segment *******************************
    93                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    94                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    95                              <1> ;						;  1 if PrtSc xeroxing screen
    96                              <1> ;						;255 if PrtSc error in xerox
    97                              <1> ;						;  ...non-grafix PrtSc in bios
    98                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    99                              <1> ;						;  ...IBMBIO.COM buffers the
   100                              <1> ;						;  ...directory of the boot
   101                              <1> ;						;  ...device here at IPL time
   102                              <1> ;						;  ...when locating the guts
   103                              <1> ;						;  ...of the operating system
   104                              <1> ;						;  ...filename "IBMDOS.COM"
   105                              <1> ;dosdir	ends
   106                              <1> ;; *************************************************************************
   107                              <1> ;; ************************ DOS IPL Segment ********************************
   108                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   109                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   110                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   111                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   112                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   113                              <1> ;dosseg	ends					;			      !
   114                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   115                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   116                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   117                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   118                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   119                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   120                              <1> ;iplseg	ends
   121                              <1> 
   122                              <1> %endif
    30                                  
    31                                  
    32                                  %if NEED_TIMER_FIX
    33                                  ; swap the timers in the intiialization table
    34                                  timer0          equ     TIM1
    35                                  timer1          equ     TIM0
    36                                  %else
    37                                  ; timers are their true selves in the initialization table
    38                                  timer0          equ     TIM0
    39                                  timer1          equ     TIM1
    40                                  %endif
    41                                  
    42                                  
    43                                  	SEGMENT	_TEXT
    44                                  
    45                                          global  BIOS_call_15h
    46                                  
    47                                  ; The stack offsets
    48                                  offset_BP       equ     0
    49                                  offset_AX       equ     offset_BP+2
    50                                  ;offset_AL	equ	offset_AX+0
    51                                  offset_AH       equ     offset_AX+1
    52                                  offset_BX       equ     offset_AX+2
    53                                  offset_DX	equ	offset_BX+2	; added for cassette I/O
    54                                  offset_DS       equ     offset_DX+2
    55                                  offset_IP       equ     offset_DS+2
    56                                  offset_CS       equ     offset_IP+2
    57                                  offset_FLAGS    equ     offset_CS+2
    58                                  
    59                                  
    60                                  BIOS_call_15h:
    61 00000000 80FC4F                  	cmp     ah,04Fh         ; null keyboard intercept handler
    62 00000003 7501                            jne	.1
    63 00000005 CF                              iret			; carry was set by the call
    64                                  .1:
    65 00000006 1E52535055                      pushm   bp,ax,bx,dx,ds
    66 0000000B 89E5                            mov     bp,sp           ; establish stack frame addressing
    67                                  
    68                                  %if 0
    69                                  	cmp     ah,04Fh         ; null keyboard intercept handler
    70                                          je      bye_bye		; was 'set_carry'
    71                                  
    72                                  	cmp	ah,0		; cassette motor on command
    73                                  	je	fn00
    74                                  	cmp	ah,1		; cassette motor off
    75                                  	je	fn01
    76                                  	cmp	ah,2		; cassette read block
    77                                  	je	fn02
    78                                  	cmp	ah,3		; cassette write block
    79                                  	je	fn03
    80                                  	cmp	ah,4		; cassette GPIO2 on command
    81                                  	je	fn04
    82                                  	cmp	ah,5		; cassette GPIO2 off command
    83                                  	je	fn05
    84                                  %else
    85 0000000D 88E3                            mov     bl,ah
    86 0000000F 30FF                            xor     bh,bh
    87 00000011 80FB06                          cmp     bl,fn00max/2
    88 00000014 7307                            jae     try_fn80
    89                                  
    90 00000016 01DB                            add     bx,bx
    91 00000018 2EFFA7[5500]                cs  jmp     near [int15fn00+bx]     ; dispatch
    92                                  %endif
    93                                  
    94                                  try_fn80:
    95 0000001D 80FCC0                  	cmp     ah,0C0h
    96 00000020 747E                            je      fnC0
    97 00000022 80FCC1                          cmp     ah,0C1h
    98 00000025 7503E98100                      je      fnC1
    99                                  
   100 0000002A 88E3                            mov     bl,ah
   101 0000002C 30FF                            xor     bh,bh
   102                                  
   103 0000002E 80EB80                          sub     bl,80h          ; miscellaneous Int15 functions
   104 00000031 80FB11                          cmp     bl,fn80max/2
   105 00000034 7307                            jae     unknown
   106                                  
   107 00000036 01DB                            add     bx,bx
   108 00000038 2EFFA7[6100]                cs  jmp     near [int15fn80+bx]     ; dispatch
   109                                  
   110                                  
   111                                  unknown:
   112 0000003D C64603FF                	mov	byte [offset_AH+bp],0FFh	; flag error
   113                                  set_carry:
   114 00000041 804E0E01                        or      byte [bp+offset_FLAGS],1        ; set the carry bit
   115 00000045 EB08                            jmp     bye_bye
   116                                  
   117                                  okay:
   118 00000047 C6460300                	mov	byte [offset_AH+bp],00h		; flag dummy okay
   119                                  clear_carry:
   120 0000004B 80660EFE                        and     byte [bp+offset_FLAGS],~1       ; clear the carry flag
   121                                  bye_bye:
   122 0000004F 5D585B5A1F                      popm    bp,ax,bx,dx,ds
   123 00000054 CF                              iret
   124                                  
   125                                  
   126                                  int15fn00:
   127 00000055 [9E00]                  	dw	fn00		; cassette motor on command
   128 00000057 [9E00]                  	dw	fn01		; cassette motor off
   129 00000059 [9E00]                  	dw	fn02		; cassette read block
   130 0000005B [9E00]                  	dw	fn03		; cassette write block
   131 0000005D [9E00]                  	dw	fn04		; cassette GPIO2 on command
   132 0000005F [9E00]                  	dw	fn05		; cassette GPIO2 off command
   133                                  fn00max         equ     $-int15fn00
   134                                  
   135                                  int15fn80:
   136 00000061 [4700]                          dw      fn80            ; device open
   137 00000063 [4700]                          dw      fn81            ; device close
   138 00000065 [4700]                          dw      fn82            ; process termination
   139 00000067 [F100]                          dw      fn83            ; event wait
   140 00000069 [3D00]                          dw      fn84            ; read joystick
   141 0000006B [4700]                          dw      fn85            ; SysReq key
   142 0000006D [3A01]                          dw      fn86            ; delay
   143 0000006F [3D00]                          dw      fn87            ; move extended memory block
   144 00000071 [8300]                          dw      fn88            ; get extended memory size
   145 00000073 [3D00]                          dw      fn89            ; enter protected mode
   146                                  %if TBASIC
   147 00000075 [8A00]                          dw      fn8a            ; getline code
   148                                  %else
   149                                  	dw	unknown		; no TBASIC, so no call
   150                                  %endif
   151 00000077 [3D00]                  	dw	fn8b
   152 00000079 [3D00]                  	dw	fn8c
   153 0000007B [3D00]                  	dw	fn8e
   154 0000007D [3D00]                  	dw	fn8f
   155 0000007F [4700]                  	dw	fn90		; Device Wait
   156 00000081 [4700]                  	dw	fn91		; Device Post
   157                                  fn80max         equ     $-int15fn80
   158                                  
   159                                  
   160                                  ; Dummy routines for the following:
   161                                  fn80    equ     okay		; Device Open
   162                                  fn81    equ     okay		; Device Close
   163                                  fn82    equ     okay		; Process Termination
   164                                  
   165                                  fn84    equ     unknown		; Read Joystick
   166                                  fn85    equ     okay		; SysReq Key make/break
   167                                  
   168                                  fn87    equ     unknown		; Move Extended Memory Block
   169                                  fn89    equ     unknown		; Enter Protected Mode
   170                                  
   171                                  fn8b	equ	unknown
   172                                  fn8c	equ	unknown
   173                                  fn8d	equ	unknown
   174                                  fn8e	equ	unknown
   175                                  fn8f	equ	unknown
   176                                  
   177                                  fn90	equ	okay		; Device Wait
   178                                  fn91	equ	okay		; Device Post
   179                                  
   180                                  ;
   181                                  ; Get Extended Memory size
   182                                  ;
   183                                  ;       There is No high memory on an 80186/8
   184                                  ;       Always return 0
   185                                  ;
   186                                  fn88:
   187 00000083 C746020000                      mov     word [bp+offset_AX],0
   188 00000088 EBC1                            jmp     clear_carry
   189                                  
   190                                  
   191                                  
   192                                  %if TBASIC
   193                                  ; Get Line (direct access to SIO.C 'getline' routine)
   194                                  ;
   195                                  ;  Enter with:
   196                                  ;       CX      length of buffer
   197                                  ;       DS:DX   pointer to the buffer
   198                                  ;
   199                                  ;  Return with:
   200                                  ;       Buffer of length-1 characters (maximum), NUL terminated
   201                                  ;
   202                                  fn8a:
   203 0000008A FB                              sti                             ; enable interrupts
   204 0000008B 5251                            pushm   cx,dx
   205                                  
   206 0000008D 89D0                            mov     ax,dx                   ; DX:AX is pointer argument
   207 0000008F 8CDA                            mov     dx,ds                   ; **
   208 00000091 89CB                            mov     bx,cx                   ; BX is second argument
   209                                  
   210 00000093 68[ssss]                        push    DGROUP                  ; for the C-code
   211 00000096 1F                              popm    ds
   212                                          extern  getline_                ; this is a __fastcall entry
   213 00000097 E8(0000)                        call    getline_
   214                                  
   215 0000009A 595A                            popm    cx,dx
   216 0000009C EBAD                            jmp     clear_carry
   217                                  %endif
   218                                  
   219                                  
   220                                  
   221                                  %if 0
   222                                  %include "cassette.asm"
   223                                  ;--------------------------------------------------------
   224                                  ; Cassette support routines
   225                                  ;	(AH) = 0 TURN CASSETTE MOTOR ON
   226                                  ;	(AH) = 1 TURN CASSETTE MOTOR OFF
   227                                  ;	(AH) = 2 READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   228                                  ;		(ES,BX) = POINTER TO DATA BUFFER
   229                                  ;		(CX) = COUNT OF BYTES TO READ
   230                                  ;		ON EXIT:
   231                                  ;  		(ES,BX) = POINTER TO LAST BYTE READ + 1
   232                                  ;  		(DX) = COUNT OF BYTES ACTUALLY READ
   233                                  ;  		(CY) = 0 IF NO ERROR OCCURRED
   234                                  ;  		     = 1 IF ERROR OCCURRED
   235                                  ;  		(AH) = ERROR RETURN IF (CY)= 1
   236                                  ;  			= 01 IF CRC ERROR WAS DETECTED
   237                                  ;  			= 02 IF DATA TRANSITIONS ARE LOST
   238                                  ;  			= 04 IF NO DATA WAS FOUND
   239                                  ;  	(AH) = 3 WRITE 1 OR MORE 256 BYTE BLOCKS TO CASSETTE
   240                                  ;  		(ES,BX) = POINTER TO DATA BUFFER
   241                                  ;  		(CX) = COUNT OF BYTES TO WRITE
   242                                  ;  		ON EXIT:
   243                                  ;		(EX,BX) = POINTER TO LAST BYTE WRITTEN + 1
   244                                  ;		(CX) = 0
   245                                  ;	(AH) = 4 TURN GPIO2 ON
   246                                  ;	(AH) = 5 TURN GPIO2 OFF
   247                                  ;	(AH) = ANY OTHER THAN ABOVE VALUES CAUSES (CY)= 1
   248                                  ;		AND (AH)= 80 TO BE RETURNED (INVALID COMMAND).
   249                                  ;--------------------------------------------------------
   250                                  ; PURPOSE:
   251                                  ;  TO TURN ON CASSETTE MOTOR
   252                                  ;  16550 I/O pins are active low so we need to add
   253                                  ;  an inverter (7400) before the 75452 to make this work.
   254                                  ;  Cassette motor connected to OUT1* on 16550, which is
   255                                  ;  bit2 of MCR.
   256                                  ;--------------------------------------------------------
   257                                  fn00:
   258                                  	mov	dx,cuart_mcr			; get device code
   259                                  	in	al,dx				;read cassette uart mcr
   260                                  	or	al,04H				; SET BIT TO TURN ON
   261                                  W3:	out	dx,al				;WRITE IT OUT
   262                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   263                                  	jmp	clear_carry
   264                                  
   265                                  
   266                                  ;----------------------------------
   267                                  ; PURPOSE:
   268                                  ;  TO TURN CASSETTE MOTOR OFF
   269                                  ;-----------------------------------
   270                                  fn01:
   271                                  	mov	dx,cuart_mcr			; get device code
   272                                  	in	al,dx				;read cassette uart mcr
   273                                  	and	al,~04h				; clear bit to turn off motor
   274                                  	jmp	W3				;write it, clear error, return
   275                                  
   276                                  
   277                                  ;--------------------------------------------
   278                                  ; PURPOSE:
   279                                  ;  TO READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   280                                  ;
   281                                  ; ON ENTRY:
   282                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   283                                  ;  BX POINTS TO START OF MEMORY BUFFER
   284                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   285                                  ; ON EXIT:
   286                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   287                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   288                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   289                                  ;
   290                                  ;  CARRY FLAG IS CLEAR IF NO ERROR DETECTED
   291                                  ;  CARRY FLAG IS SET IF CRC ERROR DETECTED
   292                                  ;--------------------------------------------
   293                                  fn02:
   294                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   295                                  	jmp	set_carry
   296                                  
   297                                  
   298                                  ;--------------------------------------------
   299                                  ;  READ 1 OR MORE 256 BYTE BLOCKS FROM CASSETTE
   300                                  ;
   301                                  ; ON ENTRY:
   302                                  ;  ES IS SEGMENT FOR MEMORY BUFFER (FOR COMPACT CODE)
   303                                  ;  BX POINTS TO START OF MEMORY BUFFER
   304                                  ;  CX CONTAINS NUMBER OF BYTES TO READ
   305                                  ; ON EXIT:
   306                                  ;  BX POINTS 1 BYTE PAST LAST BYTE PUT IN MEM
   307                                  ;  CX CONTAINS DECREMENTED BYTE COUNT
   308                                  ;  DX CONTAINS NUMBER OF BYTES ACTUALLY READ
   309                                  ;--------------------------------------------
   310                                  fn03:
   311                                  	mov	word [bp+offset_AX],80ffh	; return error code to caller
   312                                  	jmp	set_carry
   313                                  
   314                                  
   315                                  ;--------------------------------------------------------
   316                                  ; PURPOSE:
   317                                  ;  TO TURN CASSETTE GPIO2 ON
   318                                  ;  16550 I/O pins are active low so we need to add
   319                                  ;  an inverter (7400) before the 75452 to make this work.
   320                                  ;  GPIO2 is OUT2* on 16550, which is bit3 of MCR.
   321                                  ;--------------------------------------------------------
   322                                  fn04:
   323                                  	mov	dx,cuart_mcr			; get device code
   324                                  	in	al,dx   			;read cassette uart mcr
   325                                  	or	al,08h				; set bit to turn on
   326                                  W4:	out	dx,al				;write it out
   327                                  	mov	word [bp+offset_AX],0000h	; signal success to caller
   328                                  	jmp	clear_carry
   329                                  
   330                                  
   331                                  ;----------------------------------
   332                                  ; PURPOSE:
   333                                  ;  TO TURN CASSETTE GPIO2 OFF
   334                                  ;-----------------------------------
   335                                  fn05:
   336                                  	mov	dx,cuart_mcr			; get device code
   337                                  	in	al,dx				;read cassette uart mcr
   338                                  	and	al,~08h				; clear bit to turn off motor
   339                                  	jmp	W4				;write it, clear error, return
   340                                  
   341                                  %else
   342                                  fn00:
   343                                  fn01:
   344                                  fn02:
   345                                  fn03:
   346                                  fn04:
   347                                  fn05:
   348 0000009E EBA1                    jmp	set_carry
   349                                  %endif
   350                                  
   351                                  
   352                                          SEGMENT CONST
   353                                  env_table:
   354 00000000 0800                            dw      len_env_table
   355 00000002 FE                      	db	MODEL_BYTE	; PC/XT
   356 00000003 00                      	db	SUBMODEL_BYTE	; rev 1		CPUREGS.ASM
   357 00000004 03                      	db	VERSION_MAJOR	; BIOS revision level  DATE.ASM
   358 00000005 24                              db      00100100b
   359                                  				; DMA ch 3 used = 0             7
   360                                                                  ; slave 8259 present = 0        6
   361                                                                  ; RTC available = 1             5
   362                                                                  ; KBD intercept available (int 15h, fn4F) = 0
   363                                                                  ; Wait for Event avail. = 0     3
   364                                                                  ; Extended BIOS data area alloc. = 1   (FPEM will use)
   365                                                                  ; Micro Channel = 0             1
   366                                                                  ; reserved bit = 0              0
   367 00000006 00                              db      0       ; unknown usage
   368 00000007 00                              db      0       ; unknown usage
   369                                  len_env_table   equ     $-env_table
   370 00000008 0000                            db      0,0     ; just in case
   371                                  
   372                                  
   373                                  	SEGMENT	_TEXT
   374                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   375                                  ; Get System Environment
   376                                  ;   Input:
   377                                  ;	AH = 0C0h	function code
   378                                  ;   Returns:
   379                                  ;	ES:BX		pointer to the environment table above
   380                                  ;	Carry clear	success
   381                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   382                                  fnC0:
   383 000000A0 C74604[0000]                    mov     word [bp+offset_BX],env_table
   384 000000A5 68[ssss]                        push    DGROUP
   385 000000A8 07                              popm    es                              ; return ES:BX
   386                                  ;;;	mov     byte [bp+offset_AH],0           ; signal no error
   387 000000A9 EBA0                            jmp     clear_carry
   388                                  
   389                                  
   390                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   391                                  ; Get Extended BIOS Data Area Address
   392                                  ;   Input:
   393                                  ;	AH = 0C1h	function code
   394                                  ;   Returns:
   395                                  ;	ES		set to the EBDA segment address
   396                                  ;	Carry clear	success
   397                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   398                                  fnC1:
   399 000000AB 6A40                            push    bios_data_seg
   400 000000AD 1F                              popm    ds
   401 000000AE 8E06F200                        mov     es,[EBDA_paragraph]
   402 000000B2 EB97                            jmp     clear_carry
   403                                  
   404                                  
   405                                  ; Disable timer1 interrupts
   406                                  ;
   407                                  ;	uses AX & DX
   408                                  ;	exits with AX=0
   409                                  ;
   410                                  timer_disable:
   411 000000B4 BA5EFF                  	mov	dx,timer1+TCON
   412 000000B7 ED                      	in	ax,dx		; get control register
   413 000000B8 25FF7F                  	and	ax,(~tc_EN)&0FFFFh  ; disable timer
   414 000000BB 0D0040                  	or	ax,tc_nINH		; change enable flag
   415 000000BE EF                      	out	dx,ax		; disable the timer
   416                                  
   417 000000BF 31C0                    	xor	ax,ax
   418 000000C1 BA58FF                  	mov	dx,timer1+TCNT		; zero the count
   419 000000C4 EF                      	out	dx,ax
   420 000000C5 C3                       	ret
   421                                  
   422                                  ; Enable timer1 interrupts
   423                                  ;
   424                                  ;	uses AX & DX
   425                                  ;
   426                                  timer_enable:
   427 000000C6 BA5EFF                  	mov	dx,timer1+TCON
   428 000000C9 ED                      	in	ax,dx		; get control register
   429 000000CA 0D00E0                  	or	ax,tc_EN+tc_nINH+tc_INT		; enable timer & interrupts
   430 000000CD EF                      	out	dx,ax		; enable the timer
   431 000000CE C3                       	ret
   432                                  
   433                                  	global set_count
   434                                  set_count:
   435 000000CF 31DB                    	xor	bx,bx
   436                                  ; wait in microseconds in BX:CX:DX
   437                                  
   438                                  ;  to divide by 976 microseconds, the resolution of the timer
   439                                  ;  we divide by 1000000/1024 == 15625/16
   440                                  ;  OR we multiply by 16, then divide by 15625
   441                                  
   442 000000D1 51                      	pushm	cx
   443 000000D2 89C8                    	mov	ax,cx		; BX:AX:DX is microsecond count
   444 000000D4 B90400                  	mov	cx,4
   445 000000D7 D1E2                    .4:	shl	dx,1		; * 16 is left shift by 4
   446 000000D9 D1D0                    	rcl	ax,1
   447 000000DB D1D3                    	rcl	bx,1
   448 000000DD E2F8                    	loop	.4
   449 000000DF B9093D                  	mov	cx,15625	; divisor
   450 000000E2 87DA                    	xchg	bx,dx		; DX:AX:BX is count
   451 000000E4 F7F1                    	div	cx
   452 000000E6 A39E00                  	mov	word [rtc_count+2],ax	; AX is high quotient
   453 000000E9 93                      	xchg	ax,bx		; and DX is remainder
   454 000000EA F7F1                    	div	cx		; DX:AX is low dividend
   455 000000EC 59                      	popm	cx
   456                                  
   457                                  %if 0
   458                                  ; since count goes to -1, there will always be at least 1 tick
   459                                  	or	bx,ax		; test for zero tick count
   460                                  	jnz	.5
   461                                  	inc	ax		; wait at least 1 tick
   462                                  .5:
   463                                  %endif
   464 000000ED A39C00                  	mov	word [rtc_count],ax	; AX is final low quotient
   465 000000F0 C3                      	ret
   466                                  
   467                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   468                                  ; fn83 -- Event Wait
   469                                  ;   Input:
   470                                  ;	AH = 83h
   471                                  ;
   472                                  ;   Subfucntion:
   473                                  ;	AL = 01h	Cancel event wait
   474                                  ;   Output:
   475                                  ;	nothing
   476                                  ;
   477                                  ;   Subfunction:
   478                                  ;	AL = 00h	Request Event Wait
   479                                  ;	CX:DX = delay in microseconds
   480                                  ;	ES:BX = address of semaphore byte
   481                                  ;		the semaphore bit 7 is set at the end of the inverval
   482                                  ;   Output:
   483                                  ;	Carry flag clear if timer started
   484                                  ;	Carry flag set if function unsuccessful (event wait already active)
   485                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                                  fn83:		; BP,AX,BX,DX,DS already saved
   487 000000F1 6A40                    	push	bios_data_seg
   488 000000F3 1F                      	popm	ds
   489 000000F4 08C0                    	or	al,al		; test for zero
   490 000000F6 741C                    	jz	.set_wait
   491                                  
   492 000000F8 FEC8                    	dec	al		; test for one
   493 000000FA 7403E942FF              	jnz	set_carry	; error on illegal subfunction
   494                                  ; cancel wait
   495 000000FF E8B2FF                  	call	timer_disable
   496                                  ;	xor	ax,ax		; side effect of 'timer_disable'
   497 00000102 A2A000                  	mov	byte [rtc_wait_active],al
   498 00000105 A39E00                  	mov	word [rtc_count+2],ax
   499 00000108 A39C00                  	mov	word [rtc_count],ax
   500 0000010B A39A00                  	mov	word [user_semaphore+2],ax
   501 0000010E A39800                  	mov	word [user_semaphore],ax
   502 00000111 E937FF                  	jmp	clear_carry
   503                                  
   504                                  .set_wait:
   505 00000114 F606A00001              	test	byte [rtc_wait_active],01h	; any wait in progress
   506 00000119 7403E923FF              	jnz	set_carry
   507                                  
   508 0000011E 8B5E04                  	mov	bx,[offset_BX+bp]	; restore BX
   509 00000121 8C069A00                	mov	word [user_semaphore+2],es
   510 00000125 891E9800                	mov	word [user_semaphore],bx
   511                                  
   512 00000129 E8A3FF                  	call	set_count
   513                                  
   514 0000012C E897FF                  	call	timer_enable
   515 0000012F C606A00001              	mov	byte [rtc_wait_active],01h	; flag wait active
   516 00000134 B80083                  	mov	ax,8300h
   517 00000137 E911FF                  	jmp	clear_carry
   518                                  
   519                                  
   520                                  
   521                                  
   522                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   523                                  ; fn86 -- Delay
   524                                  ;   Input:
   525                                  ;	AH = 86h
   526                                  ;	CX:DX = delay in microseconds
   527                                  ;
   528                                  ;   Output:
   529                                  ;	Carry flag clear if delay occurred
   530                                  ;	Carry flag set if timer busy; no delay occurred
   531                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   532                                  fn86:		; BP,AX,BX,DX,DS already saved
   533 0000013A 6A40                    	push	bios_data_seg
   534 0000013C 1F                      	popm	ds
   535 0000013D F606A00001              	test	byte [rtc_wait_active],01h	; is a wait active?
   536 00000142 7403E9FAFE              	jnz	set_carry		; perform no wait, we're busy
   537                                  
   538 00000147 E885FF                  	call	set_count
   539 0000014A C606A00001              	mov	byte [rtc_wait_active],01h		; mark timer active
   540                                  
   541 0000014F 31DB                    	xor	bx,bx
   542 00000151 891E9800                	mov	word [user_semaphore],bx
   543 00000155 891E9A00                	mov	word [user_semaphore+2],bx
   544                                  
   545 00000159 E86AFF                  	call	timer_enable
   546 0000015C FB                      	sti					; don't forget to enable interrupts
   547 0000015D EB01                    	jmp	.3
   548                                  
   549                                  
   550 0000015F F4                      .wait:	hlt
   551 00000160 F606A00080              .3:	test	byte [rtc_wait_active],80h		; wait for posting
   552 00000165 74F8                    	jz	.wait
   553                                  
   554 00000167 C606A00000              	mov	byte [rtc_wait_active],0		; mark not in use
   555 0000016C E9DCFE                  	jmp	clear_carry
   556                                  
   557                                  
   558                                  	global	rtc_interrupt
   559                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   560                                  ;  rtc_interrupt             (timer0, if NEED_TIMER_FIX)
   561                                  ;
   562                                  ;       This is the 1024 Hz timer tick from INT 70h
   563                                  ;
   564                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   565                                  rtc_interrupt:
   566 0000016F 1E565250                	pushm	ax,dx,si,ds
   567                                  
   568 00000173 6A40                    	push	bios_data_seg
   569 00000175 1F                      	popm	ds
   570                                  
   571 00000176 F606A00001              	test	byte [rtc_wait_active],01h	; test active bit
   572 0000017B 7421                    	jz	.dismiss
   573                                  
   574 0000017D 832E9C0001              	sub	word [rtc_count],1
   575 00000182 831E9E0000              	sbb	word [rtc_count+2],0
   576 00000187 7315                    	jnc	.dismiss		; counted down by 1
   577                                  
   578                                  ; counted down to -1, post the event
   579 00000189 C606A00080              	mov	byte [rtc_wait_active],80h	; mark posted, inactive
   580 0000018E C5369800                	lds	si,[user_semaphore]
   581 00000192 8CD8                    	mov	ax,ds			; check for null pointer
   582 00000194 09F0                    	or	ax,si			; **
   583 00000196 7403                    	jz	.2
   584 00000198 800C80                  	or	byte [si],80h			; post event
   585 0000019B E816FF                  .2:	call	timer_disable
   586                                  
   587                                  .dismiss:
   588                                  ; signal EOI (End of Interrupt)
   589 0000019E BA22FF                          mov     dx,PIC_EOI              ; EOI register
   590 000001A1 B80080                          mov     ax,EOI_NSPEC            ; non-specific
   591 000001A4 EF                              out     dx,ax                   ; signal it
   592                                  
   593 000001A5 585A5E1F                	popm	ax,dx,si,ds
   594 000001A9 CF                              iret
