     1                                  
     2                                  
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ; floppy.asm -- WD37C65B floppy disk controller driver
     5                                  ;		Version 2.0 -- Apr 2013, JRC
     6                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     7                                  ;
     8                                  ;   This version is for assembly by  NASM 0.98.39 or later
     9                                  ;
    10                                  ; Copyright (C) 2010-2013 John R. Coffman.  All rights reserved.
    11                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
    12                                  ;
    13                                  ; This program is free software: you can redistribute it and/or modify
    14                                  ; it under the terms of the GNU General Public License as published by
    15                                  ; the Free Software Foundation, either version 3 of the License, or
    16                                  ; (at your option) any later version.
    17                                  ;
    18                                  ; This program is distributed in the hope that it will be useful,
    19                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    20                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    21                                  ; GNU General Public License for more details.
    22                                  ;
    23                                  ; You should have received a copy of the GNU General Public License
    24                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    25                                  ;
    26                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    27                                  %include        "config.asm"
    28                              <1> ;/*
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; ANSI.CFG
    31                              <1> ;   Copied to CONFIG.ASM for general release.
    32                              <1> ;
    33                              <1> ;       Modify the parameters below to reflect your system
    34                              <1> ;
    35                              <1> ;
    36                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    37                              <1> ;
    38                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    39                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    40                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    41                              <1> ;
    42                              <1> ; Define the serial terminal that the Video BIOS must emulate
    43                              <1> ; Set one of the following to 1
    44                              <1> ; If you have no idea what to choose, set TTY to 1
    45                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    46                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    47                              <1> ANSI    equ     1       ; very smart, like a VT-100
    48                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    49                              <1> ; others may get added in the future
    50                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    51                              <1> ;
    52                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    53                              <1> ;UART_RATE	equ	0		; 1200
    54                              <1> ;UART_RATE	equ	1		; 2400
    55                              <1> ;UART_RATE	equ	2		; 4800
    56                              <1> UART_RATE	equ	3		; 9600
    57                              <1> ;UART_RATE	equ	4		; 19200
    58                              <1> ;UART_RATE	equ	5		; 38400
    59                              <1> ;UART_RATE	equ	6		; 57600
    60                              <1> ;UART_RATE	equ	7		; 115200
    61                              <1> 
    62                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    63                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    64                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    65                              <1> 						; but not ANSI
    66                              <1> ; Define the size of the ROM image on the system in Kilobytes
    67                              <1> ; It may be smaller than the actual EPROM in use.
    68                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    69                              <1> %ifndef ROM
    70                              <1> ROM             equ     32              ; 64 is the default
    71                              <1> %endif
    72                              <1> 
    73                              <1> ; Define the number of Wait States at which the ROM operates
    74                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    75                              <1> 
    76                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    77                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    78                              <1> RAM_DOS         equ     640
    79                              <1> 
    80                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    81                              <1> ; the default is 512 kilobytes
    82                              <1> RAM             equ     512             ; (512 is the default)
    83                              <1> 
    84                              <1> ; Define the number of Wait States at which the RAM operates
    85                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    86                              <1> 
    87                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    88                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    89                              <1> 
    90                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    91                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    92                              <1> 
    93                              <1> ; Define the time zone in which we build the Relocatable BIOS
    94                              <1> %ifndef TIMEZONE
    95                              <1> %define TIMEZONE "CST"
    96                              <1> %endif
    97                              <1> 
    98                              <1> ; Has the REDBUG debugger been loaded?
    99                              <1> %ifndef SOFT_DEBUG
   100                              <1> %define SOFT_DEBUG 0
   101                              <1> %endif
   102                              <1> 
   103                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   104                              <1> %ifndef TBASIC
   105                              <1> TBASIC          equ     1		; default is 1
   106                              <1> %endif
   107                              <1> 
   108                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   109                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   110                              <1> %ifndef FPEM
   111                              <1> FPEM            equ     1               ; default is 1
   112                              <1> %endif
   113                              <1> 
   114                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   115                              <1> EMM_BOARDS      equ     0
   116                              <1> 
   117                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   118                              <1> ; or at locations 0280h..3FFh in low memory?
   119                              <1> %if SOFT_DEBUG
   120                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   121                              <1> %else
   122                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   123                              <1> %endif
   124                              <1> 
   125                              <1> ; Define the size of the EPROM that is to be installed on the system
   126                              <1> ; It may be larger than the actual ROM image to be generated.
   127                              <1> %ifndef CHIP
   128                              <1> CHIP            equ     64
   129                              <1> %endif
   130                              <1> 
   131                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   132                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   133                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   134                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   135                              <1> 
   136                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   137                              <1> ; If the wiring update is installed, or you have a later board, then
   138                              <1> ; set this to 0.  If you are using the software workaround, then set this
   139                              <1> ; to 1.  The rev 1.0 board has this fix already.
   140                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   141                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   142                              <1> 
   143                              <1> ; Define the UART oscillator speed
   144                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   145                              <1> 
   146                              <1> 
   147                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   148                              <1> ; end of the User configuration
   149                              <1> ;       Do Not modify anything below this point
   150                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   151                              <1> 
   152                              <1> ; Define existence of any uart chip
   153                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   154                              <1> startuplength   equ     512                     ; may be up to 1024
   155                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   156                              <1> highrom         equ     (ROM*400h)&0FFFFh
   157                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   158                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   159                              <1> 
   160                              <1> 
   161                              <1> %define ARG(n) [bp+2+(n)*2]
   162                              <1> 
   163                              <1> %macro  check   1.nolist
   164                              <1>  %if (%1)
   165                              <1>    %error Check Failure: %1
   166                              <1>  %endif
   167                              <1> %endm
   168                              <1> %macro  range   3.nolist
   169                              <1>  %if (%1)<(%2)
   170                              <1>    %error Out of Range: %1
   171                              <1>  %elif (%1)>(%3)
   172                              <1>    %error Out of Range: %1
   173                              <1>  %endif
   174                              <1> %endm
   175                              <1> _terminal equ UART
   176                              <1>  check   RAM_DOS&15
   177                              <1>  check   RAM&(RAM-1)
   178                              <1>  check   ROM&(ROM-1)
   179                              <1>  range   RAM,32,512
   180                              <1>  range   ROM,32,256
   181                              <1>  range   RAM_WS,0,3
   182                              <1>  range   ROM_WS,0,3
   183                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   184                              <1>  range   LCL_IO_WS,0,3
   185                              <1>  range   BUS_IO_WS,0,3
   186                              <1>  range   UART_OSC,500000,16000000
   187                              <1>  range   UART_RATE,0,7
   188                              <1>  range	 UART,0,1
   189                              <1>  range	 _terminal,1,2
   190                              <1> 
   191                              <1> %ifndef SOFT_DEBUG
   192                              <1> %define SOFT_DEBUG 0
   193                              <1> %endif
   194                              <1> 
   195                              <1> %ifndef TRACE
   196                              <1> %define TRACE 0
   197                              <1> %endif
   198                              <1> 
   199                              <1> %ifdef MAKE_OBJECT_FILE
   200                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   201                              <1>         export _ROMsize
   202                              <1>         export _CHIPsize
   203                              <1> _ROMsize        dw      ROM
   204                              <1> _CHIPsize       dw      CHIP
   205                              <1> %endif
   206                              <1> ; end of the Hardware configuration file
   207                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   208                              <1> ;*/
    28                                  %include        "cpuregs.asm"
    29                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    30                              <1> ; CPUREGS.ASM
    31                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    32                              <1> ;
    33                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    34                              <1> ;
    35                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    36                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    37                              <1> ;
    38                              <1> ; This program is free software: you can redistribute it and/or modify
    39                              <1> ; it under the terms of the GNU General Public License as published by
    40                              <1> ; the Free Software Foundation, either version 3 of the License, or
    41                              <1> ; (at your option) any later version.
    42                              <1> ;
    43                              <1> ; This program is distributed in the hope that it will be useful,
    44                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    45                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    46                              <1> ; GNU General Public License for more details.
    47                              <1> ;
    48                              <1> ; You should have received a copy of the GNU General Public License
    49                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    50                              <1> ;
    51                              <1> ; Updated for the Duodyne 80c188 SBC
    52                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <1> %include	"macros.inc"
    54                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    55                              <2> ; MACROS.INC  
    56                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    57                              <2> ;
    58                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    59                              <2> ;
    60                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    61                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    62                              <2> ;
    63                              <2> ; This program is free software: you can redistribute it and/or modify
    64                              <2> ; it under the terms of the GNU General Public License as published by
    65                              <2> ; the Free Software Foundation, either version 3 of the License, or
    66                              <2> ; (at your option) any later version.
    67                              <2> ;
    68                              <2> ; This program is distributed in the hope that it will be useful,
    69                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    70                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    71                              <2> ; GNU General Public License for more details.
    72                              <2> ;
    73                              <2> ; You should have received a copy of the GNU General Public License
    74                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    75                              <2> ;
    76                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    77                              <2> 
    78                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    79                              <2> ;
    80                              <2> ;
    81                              <2> %ifndef __MACROS_DEFINED_
    82                              <2> %define __MACROS_DEFINED_ 1
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> ;
    85                              <2> ; some useful macros:
    86                              <2> ;
    87                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    88                              <2> ;
    89                              <2> 	cpu	186
    90                              <2> 
    91                              <2> %imacro setloc  1.nolist
    92                              <2>  times   (%1-($-$$)) db 0FFh
    93                              <2> %endm
    94                              <2> 
    95                              <2> %imacro db_lo   1
    96                              <2>  db (%1)&255
    97                              <2> %endm
    98                              <2> 
    99                              <2> %imacro cnop    0.nolist
   100                              <2> %if SOFT_DEBUG
   101                              <2>         nop
   102                              <2> %endif
   103                              <2> %endm
   104                              <2> 
   105                              <2> %imacro popm 1-*.nolist
   106                              <2> %rep %0
   107                              <2> %ifidni %1,ALL
   108                              <2>  popa
   109                              <2> %elifidni %1,F
   110                              <2>  popf
   111                              <2> %else
   112                              <2>  pop %1
   113                              <2> %ifidni %1,DS
   114                              <2>  cnop
   115                              <2> %elifidni %1,ES
   116                              <2>  cnop
   117                              <2> %endif
   118                              <2> %endif
   119                              <2> %rotate 1
   120                              <2> %endrep
   121                              <2> %endm
   122                              <2> 
   123                              <2> %imacro pushm 1-*.nolist
   124                              <2> %rep %0
   125                              <2> %rotate -1
   126                              <2> %ifidni %1,ALL
   127                              <2>  pusha
   128                              <2> %elifidni %1,F
   129                              <2>  pushf
   130                              <2> %else
   131                              <2>  push %1
   132                              <2> %endif
   133                              <2> %endrep
   134                              <2> %endm
   135                              <2> 
   136                              <2> ;
   137                              <2> ; added from the 386EX project
   138                              <2> ;
   139                              <2> 
   140                              <2> ; call arguments
   141                              <2> %define ARG(n) [bp+2+(n)*2]
   142                              <2> 
   143                              <2> ;
   144                              <2> ; format of the BYTE initialization table:  address, byte
   145                              <2> ;
   146                              <2> %imacro  binit 2
   147                              <2>         dw      %1
   148                              <2>         db      %2
   149                              <2> %endmacro
   150                              <2> ; end with DW -1
   151                              <2> 
   152                              <2> ;
   153                              <2> ; format of the WORD initialization table:  address, word
   154                              <2> ;
   155                              <2> %imacro  winit 2
   156                              <2>         dw      %1
   157                              <2>         dw      %2
   158                              <2> %endmacro
   159                              <2> ; end with DW -1
   160                              <2> 
   161                              <2> 
   162                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   163                              <2> %imacro get_bda	1.nolist
   164                              <2> 	push	0x0040
   165                              <2> 	pop	%1
   166                              <2> 	cnop
   167                              <2> %endm
   168                              <2> 
   169                              <2> 
   170                              <2> %endif
    54                              <1> 
    55                              <1> 	cpu     186
    56                              <1> ;
    57                              <1> ;
    58                              <1> ; IBM model byte -- must be less than a 286
    59                              <1> ;
    60                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    61                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    62                              <1> 
    63                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    64                              <1> SUBMODEL_BYTE		equ	00h	;  "
    65                              <1> 
    66                              <1> 
    67                              <1> ; 80188 peripheral control register block address
    68                              <1> CPU_CSCR	        equ	0FF00h
    69                              <1> 
    70                              <1> ; Compatible Mode registers
    71                              <1> 
    72                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    73                              <1> 
    74                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    75                              <1> 
    76                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    77                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    78                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    79                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    80                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    81                              <1> 
    82                              <1> ; Enhanced Mode registers
    83                              <1> 
    84                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    85                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    86                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    87                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    88                              <1> 
    89                              <1> 
    90                              <1> ; On-board internal peripheral equates
    91                              <1> ; Programmable Interrupt Controller
    92                              <1> PIC	        equ	CPU_CSCR+020H
    93                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    94                              <1> PIC_POLLR	equ	PIC+4
    95                              <1> PIC_POLLSR	equ	PIC+6
    96                              <1> PIC_IMASK	equ	PIC+8
    97                              <1> PIC_PMREG	equ	PIC+0AH
    98                              <1> PIC_SRVR	equ	PIC+0CH
    99                              <1> PIC_IRQR	equ	PIC+0EH
   100                              <1> PIC_IRQSR	equ	PIC+10H
   101                              <1> PIC_TCR	        equ	PIC+12H
   102                              <1> PIC_DMA0CR	equ	PIC+14H
   103                              <1> PIC_DMA1CR	equ	PIC+16H
   104                              <1> PIC_I0CON	equ	PIC+18H
   105                              <1> PIC_I1CON	equ	PIC+1AH
   106                              <1> PIC_I2CON	equ	PIC+1CH
   107                              <1> PIC_I3CON	equ	PIC+1EH
   108                              <1> 
   109                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   110                              <1> 
   111                              <1> ; Interrupt masks (Master Mode)
   112                              <1> ;
   113                              <1> mask_timer_all          equ     0001h
   114                              <1> mask_dma0               equ     0004h
   115                              <1> mask_dma1               equ     0008h
   116                              <1> mask_int0               equ     0010h
   117                              <1> mask_int1               equ     0020h
   118                              <1> mask_int2               equ     0040h
   119                              <1> mask_int3               equ     0080h
   120                              <1> 
   121                              <1> 
   122                              <1> 
   123                              <1> ; Timers
   124                              <1> TIM0	        equ	CPU_CSCR+050H
   125                              <1> TIM1	        equ	CPU_CSCR+058H
   126                              <1> TIM2	        equ	CPU_CSCR+060H
   127                              <1> 
   128                              <1> TCNT	        equ	0	; count register
   129                              <1> CMPA	        equ	2	; max count A
   130                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   131                              <1> TCON	        equ	6	; mode/control word
   132                              <1> 
   133                              <1> ; Timer control bits:
   134                              <1> tc_EN           equ     8000h   ; Enable bit
   135                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   136                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   137                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   138                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   139                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   140                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   141                              <1> tc_EXT          equ     0004h   ; External clock
   142                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   143                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   144                              <1> 
   145                              <1> 
   146                              <1> 
   147                              <1> 
   148                              <1> ; DMA
   149                              <1> DMA0	        equ	CPU_CSCR+0C0H
   150                              <1> DMA1	        equ	CPU_CSCR+0D0H
   151                              <1> DMASPL	        equ	0	; source pointer low
   152                              <1> DMASPU	        equ	2	; source pointer high
   153                              <1> DMADPL	        equ	4	; destination pointer low
   154                              <1> DMADPU	        equ	6	; destination pointer high
   155                              <1> DMATC	        equ	8	; terminal count
   156                              <1> DMACW	        equ	0AH	; control word
   157                              <1> 
   158                              <1> 
   159                              <1> 
   160                              <1> 
   161                              <1> 
   162                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   163                              <1> ;
   164                              <1> ;       SBC-188 external devices
   165                              <1> ;
   166                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   167                              <1> 
   168                              <1> IO_BASE			equ	0400h
   169                              <1> 
   170                              <1> 
   171                              <1> 
   172                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   173                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   174                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   175                              <1> 
   176                              <1> uart_base               equ     IO_BASE+0280h
   177                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   178                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   179                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   180                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   181                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   182                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   183                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   184                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   185                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   186                              <1> uart_sr			equ	uart_base+7	;Scratch
   187                              <1> 
   188                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   189                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   190                              <1> 
   191                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   192                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   193                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   194                              <1> CTRL259		equ	IO_BASE+0238H
   195                              <1> ; LEDS are at addresses 0..3
   196                              <1> ; other control ports on 4..7
   197                              <1> LED0		equ	CTRL259+0
   198                              <1> LED1		equ	LED0+1
   199                              <1> LED2		equ	LED0+2
   200                              <1> LED3		equ	LED0+3
   201                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   202                              <1> ;unused		equ	CTRL259+5
   203                              <1> ;unused		equ	CTRL259+6
   204                              <1> ;unused		equ	CTRL259+7
   205                              <1> 
   206                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   207                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   208                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   209                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   210                              <1> 
   211                              <1> 
   212                              <1> 
   213                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   214                              <1> ; Floppy controller (Duodyne Disk IO)
   215                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   216                              <1> FDC	        equ	IO_BASE+0080H
   217                              <1> FDC_MSR         equ     FDC
   218                              <1> FDC_DATA        equ     FDC+1
   219                              <1> FDC_TC	        equ	FDC+2
   220                              <1> FDC_RES	        equ	FDC+3
   221                              <1> FDC_LDCR	equ	FDC+5
   222                              <1> FDC_LDOR	equ	FDC+6
   223                              <1> FDC_DACK        equ	FDC+6
   224                              <1> FDC_DACK_TC     equ     FDC+7
   225                              <1> 
   226                              <1> 
   227                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   228                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   229                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   230                              <1> RTC	equ	IO_BASE+0094H
   231                              <1> 
   232                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   234                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   235                              <1> PPI	        equ	IO_BASE+0088H
   236                              <1> 
   237                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   238                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   239                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   240                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   241                              <1> 
   242                              <1> portA           equ     PPI+0   ;
   243                              <1> portB           equ     PPI+1   ;
   244                              <1> portC           equ     PPI+2   ;
   245                              <1> 
   246                              <1> ; end CPUREGS.ASM
    29                                  %include        "equates.asm"
    30                              <1> ;========================================================================
    31                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    32                              <1> ;========================================================================
    33                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;
    53                              <1> ;========================================================================
    54                              <1> 
    55                              <1>         global  FPEM_segment
    56                              <1> 
    57                              <1> 
    58                              <1> %include "segdef.asm"
    59                              <2> ;========================================================================
    60                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    61                              <2> ;========================================================================
    62                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    63                              <2> ;
    64                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    65                              <2> ;
    66                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    67                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    68                              <2> ;
    69                              <2> ; This program is free software: you can redistribute it and/or modify
    70                              <2> ; it under the terms of the GNU General Public License as published by
    71                              <2> ; the Free Software Foundation, either version 3 of the License, or
    72                              <2> ; (at your option) any later version.
    73                              <2> ;
    74                              <2> ; This program is distributed in the hope that it will be useful,
    75                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    76                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    77                              <2> ; GNU General Public License for more details.
    78                              <2> ;
    79                              <2> ; You should have received a copy of the GNU General Public License
    80                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    81                              <2> ;
    82                              <2> ;========================================================================
    83                              <2> 
    84                              <2> %ifndef __SEGDEF_
    85                              <2> %define __SEGDEF_
    86                              <2> 
    87                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    88                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    89                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    90                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    91                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    92                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    93                              <2> 
    94                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    95                              <2> 
    96                              <2> %endif
    97                              <2> 
    59                              <1> %include "ascii.asm"
    60                              <2> ; ascii.asm
    61                              <2> ;
    62                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    63                              <2> 
    64                              <2> NUL     equ     00h
    65                              <2> BEL     equ     (CTRL & 'G')
    66                              <2> BS      equ     08h		; ^H
    67                              <2> HT      equ     09h		; ^I
    68                              <2> LF	equ	0Ah		; ^J
    69                              <2> NL      equ     LF
    70                              <2> VT	equ	0Bh		; ^K
    71                              <2> FWD	equ	0Ch		; ^L
    72                              <2> CR	equ	0Dh
    73                              <2> XON     equ     (CTRL & 'Q')
    74                              <2> XOFF    equ     (CTRL & 'S')
    75                              <2> DC1     equ     XON
    76                              <2> DC3     equ     XOFF
    77                              <2> ESC     equ	1Bh
    78                              <2> 
    79                              <2> 
    60                              <1> 
    61                              <1> 
    62                              <1> ; POST error codes. Presently one byte but can expand to word.
    63                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    64                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    65                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    66                              <1> ER_FDC	equ	08h		; Bad FDC
    67                              <1> ER_UNK1	equ	10h		; {unassigned}
    68                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    69                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    70                              <1> ER_UNK2	equ	80h		; {unassigned}
    71                              <1> 
    72                              <1> 
    73                              <1> 
    74                              <1> ;; ************************ BIOS Data Segment ******************************
    75                              <1> ;; BIOS data segment - not all will  be used
    76                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    77                              <1> %include "bda.inc"
    78                              <2> ;/*======================================================================
    79                              <2> ; bda.inc -- BIOS data area definitions
    80                              <2> ;========================================================================
    81                              <2> ;   for the N8VEM SBC-188
    82                              <2> ;
    83                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    84                              <2> ;
    85                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    86                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    87                              <2> ;
    88                              <2> ; This program is free software: you can redistribute it and/or modify
    89                              <2> ; it under the terms of the GNU General Public License as published by
    90                              <2> ; the Free Software Foundation, either version 3 of the License, or
    91                              <2> ; (at your option) any later version.
    92                              <2> ;
    93                              <2> ; This program is distributed in the hope that it will be useful,
    94                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    95                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    96                              <2> ; GNU General Public License for more details.
    97                              <2> ;
    98                              <2> ; You should have received a copy of the GNU General Public License
    99                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   100                              <2> ;
   101                              <2> ;========================================================================
   102                              <2> 
   103                              <2> 			;*/ extern				/*
   104                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   105 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   106 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   107 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   108                              <2> ;	dw	?		; 40:10 	; Equipment present word
   109                              <2> ;  						;  = (1 iff floppies) *     1.
   110                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   111                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   112                              <2> ;  						;  + (init crt mode ) *    16.
   113                              <2> ;  						;  + (# of floppies ) *    64.
   114                              <2> ;  						;  + (# serial ports) *   512.
   115                              <2> ;  						;  + (1 iff toy port) *  4096.
   116                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   117                              <2> ;  						;  + (# parallel LPT) * 16384.
   118 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   119 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   120                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   121 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   122 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   123                              <2> ;;---------------[Keyboard data area]------------;
   124 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   125                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   126 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   127 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   128 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   129 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   130                              <2> kbd_buffer_last	equ	$	;*/				/*
   131                              <2> ;;---------------[Diskette data area]------------;
   132 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   133 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   134 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   135 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   136                              <2> ;				Floppy return code stat byte
   137                              <2> ;				;  1 = bad ic 765 command req.
   138                              <2> ;				;  2 = address mark not found
   139                              <2> ;				;  3 = write to protected disk
   140                              <2> ;				;  4 = sector not found
   141                              <2> ;				;  8 = data late (DMA overrun)
   142                              <2> ;				;  9 = DMA failed 64K page end
   143                              <2> ;				; 16 = bad CRC on floppy read
   144                              <2> ;				; 32 = bad NEC 765 controller
   145                              <2> ;				; 64 = seek operation failed
   146                              <2> ;				;128 = disk drive timed out
   147 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   148                              <2> ;;---------------[Video display area]------------;
   149 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   150                              <2> ;			 	; Current CRT mode  (software)
   151                              <2> ;				;  0 = 40 x 25 text (no color)
   152                              <2> ;				;  1 = 40 x 25 text (16 color)
   153                              <2> ;				;  2 = 80 x 25 text (no color)
   154                              <2> ;				;  3 = 80 x 25 text (16 color)
   155                              <2> ;				;  4 = 320 x 200 grafix 4 color
   156                              <2> ;				;  5 = 320 x 200 grafix 0 color
   157                              <2> ;				;  6 = 640 x 200 grafix 0 color
   158                              <2> ;				;  7 = 80 x 25 text (mono card)
   159 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   160 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   161 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   162 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   163 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   164 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   165 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   166 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   167 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   168                              <2> ;;---------------[Used to setup ROM]-------------;
   169 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   170 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   171                              <2> ;;---------------[Timer data area]---------------;
   172 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   173 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   174                              <2> ;;---------------[System data area]--------------;
   175 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   176 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   177                              <2> ;;---------------[Hard disk scratchpad]----------;
   178 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   179                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   180 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   181 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   182                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   183 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   184 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   185                              <2> ;;---------------[EGA stuff]---------------------;
   186 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   187                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   188 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   189 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   190 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   191 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   192 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   193                              <2> ;;---------------[Additional KBD flags]----------------;
   194 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   195 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   196                              <2> ;;---------------[RTC/timer1 data]---------------------;
   197 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   198 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   199 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   200                              <2> ;;---------------[Cassette I/O stuff]------------------;
   201 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   202 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   203                              <2> ;									Post Acknowleged=00;
   204 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   205 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   206 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   207                              <2> ;
   208 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   209 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   210 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   211 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   212                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   213 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   214 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   215 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   216 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   217 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   218 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   219 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   220 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   221 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   222 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   223 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   224 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   225 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   226 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   227 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   228                              <2> ;
   229                              <2> ;
   230                              <2> 
   231 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   232                              <2> 
   233 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   234                              <2> 
   235 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   236 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   237                              <2> 
   238 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   239                              <2> 
   240 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   241                              <2> 
   242 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   243                              <2> 
   244 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   245                              <2> ;								   CPU clock is half of this
   246                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <2> ;
   248                              <2> ;  System configuration stuff below
   249                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   250                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   251                              <2> %if 0				;*/
   252                              <2> #define FIXED_DISK_MAX 4		/*
   253                              <2> %else
   254                              <2> %define FIXED_DISK_MAX 4
   255                              <2> %endif
   256                              <2> %if 0				;*/
   257                              <2> #define PPIDE_driver 1		/*
   258                              <2> %else
   259                              <2> %define PPIDE_driver 1
   260                              <2> %endif
   261                              <2> %if 0				;*/
   262                              <2> #define DIDE_driver 0		/*
   263                              <2> %else
   264                              <2> %define DIDE_driver 0
   265                              <2> %endif
   266                              <2> %if 0				;*/
   267                              <2> #define DISKIO_driver 1		/*
   268                              <2> %else
   269                              <2> %define DISKIO_driver 1
   270                              <2> %endif
   271                              <2> %if 0				;*/
   272                              <2> #define MFPIC_driver 1		/*
   273                              <2> %else
   274                              <2> %define MFPIC_driver 1
   275                              <2> %endif
   276                              <2> %if 0				;*/
   277                              <2> #define DSD_driver 1		/*
   278                              <2> %else
   279                              <2> %define DSD_driver 1
   280                              <2> %endif
   281                              <2> %if 0				;*/
   282                              <2> #define V3IDE8_driver (SBC188==3)		/*
   283                              <2> %else
   284                              <2> %define V3IDE8_driver (SBC188==3)
   285                              <2> %endif
   286                              <2> 				;*/
    78                              <1> 
    79                              <1> ;  this must be the same in EQUATES.H */
    80                              <1> %if SOFT_DEBUG
    81                              <1> %define NBREAK  8
    82                              <1> %endif
    83                              <1> 
    84                              <1> 
    85                              <1> %if 0
    86                              <1>         segment _TEXT
    87                              <1> ;; *************************************************************************
    88                              <1> 
    89                              <1> 
    90                              <1> 
    91                              <1> 
    92                              <1> ;; ************************ DOS Data Segment *******************************
    93                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    94                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    95                              <1> ;						;  1 if PrtSc xeroxing screen
    96                              <1> ;						;255 if PrtSc error in xerox
    97                              <1> ;						;  ...non-grafix PrtSc in bios
    98                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    99                              <1> ;						;  ...IBMBIO.COM buffers the
   100                              <1> ;						;  ...directory of the boot
   101                              <1> ;						;  ...device here at IPL time
   102                              <1> ;						;  ...when locating the guts
   103                              <1> ;						;  ...of the operating system
   104                              <1> ;						;  ...filename "IBMDOS.COM"
   105                              <1> ;dosdir	ends
   106                              <1> ;; *************************************************************************
   107                              <1> ;; ************************ DOS IPL Segment ********************************
   108                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   109                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   110                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   111                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   112                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   113                              <1> ;dosseg	ends					;			      !
   114                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   115                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   116                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   117                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   118                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   119                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   120                              <1> ;iplseg	ends
   121                              <1> 
   122                              <1> %endif
    30                                  
    31                                  %define DUMP 1
    32                                  %define DEBUG 1
    33                                  %define SOFT_DEBUG 1
    34                                  ; sterilize SOFT_DEBUG for now
    35                                  %if SOFT_DEBUG > 1
    36                                  %undef SOFT_DEBUG
    37                                  %define SOFT_DEBUG 1
    38                                  %endif
    39                                  
    40                                  	global  BIOS_call_13h
    41                                  ;;	global  Floppy_BIOS_call_13h_entry
    42                                  	global  wait12
    43                                  	global	@enable, @disable
    44                                  %if SOFT_DEBUG
    45                                  	extern	_cprintf
    46                                  	global  undefined
    47                                  	global	fn00,fn02,fn03,fn04
    48                                  	global  get_msr
    49                                  	global	check_DL
    50                                  	global	get_disk_type
    51                                  	global	get_media
    52                                  	global	set_media_pointer
    53                                  	global	rwv_common
    54                                  	global	Seek, recalibrate, Specify
    55                                  	global	rwv_common.marker
    56                                  	global	end_rwv
    57                                  	global	xfer_read_sector, xfer_write_sector, xfer_verify_sector
    58                                  	global	xfer_format_track
    59                                   	global	Check_RW_Status
    60                                  %endif
    61                                  
    62                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    63                                  ; Error, Okay, Complete status conditions
    64                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    65                                  
    66                                  %define	Error		stc
    67                                  ;  test with:
    68                                  ;	JC xxx	(jump on error)
    69                                  ;	JNC xxx	(jump on no error)
    70                                  
    71                                  %define	Okay		xor ah,ah
    72                                  ;  test with:
    73                                  ;	JZ xxx	(jump okay)
    74                                  ;	JNZ xxx (jump not okay)
    75                                  
    76                                  %define Complete	or ah,3
    77                                  ;  test with:
    78                                  ;	JA xxx	(jump complete AND no error)
    79                                  ;	JNZ xxx	(jump complete)
    80                                  ;	JZ xxx	(jump not complete)
    81                                  
    82                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    83                                  
    84                                  
    85                                  ; at most we use 2 floppies
    86                                  %define FLOPPY_MAX	2
    87                                  
    88                                  ; there is some disagreement about whether ES:DI gets set
    89                                  ; for Floppy calls to "int 13h, function 8"
    90                                  FN08_SET_ES_DI   equ     1
    91                                  ;FN08_SET_ES_DI   equ     0
    92                                  
    93                                  ; Define the three modes of operation of the WD37C65B floppy controller
    94                                  %define BASE    0FFh
    95                                  %define SPECIAL 80h
    96                                  %define PC_AT   00h
    97                                  
    98                                  ; DMA watch threshhold
    99                                  %define THRESHHOLD  12
   100                                  
   101                                  ; Do we use DMA or Programmed I/O
   102                                  %define USE_DMA 1       ; We want this to be 1
   103                                  %define USE_DMA_INTs	1	; Use DMA interrupts
   104                                  
   105                                  ; Define the mode in which the WD37C65B is operated
   106                                  %define MODE    PC_AT   ; This MUST NOT be changed
   107                                  
   108                                  ; specify bits in the Operations Register
   109                                  %define DSEL1    00h
   110                                  %define DSEL2    01h
   111                                  %define DSEL_MASK (DSEL1|DSEL2)
   112                                  %define NO_RESET 04h
   113                                  %define RESET    00h
   114                                  %define DMAEN    08h
   115                                  %define MOEN1    10h
   116                                  %define MOEN2    20h
   117                                  %define MOEN_MASK (MOEN1|MOEN2)
   118                                  
   119                                  %define TurnOn	8			; used by all DSEL's
   120                                  
   121                                  ; the Motor turn-on delay in milliseconds
   122                                  %define MOTOR_DELAY     (TurnOn*125)
   123                                  
   124                                  ; define the disk density clock rate selects
   125                                  %define FDC_HD  00h
   126                                  %define FDC_DD  02h
   127                                  
   128                                  ; The individual floppy disk status bits
   129                                  %define FDC_DRIVE_PRESENT  1
   130                                  %define FDC_DRIVE_READY    2
   131                                  
   132                                  
   133                                  ; define the MSR bits:
   134                                  RQM     equ     80h             ; request for master
   135                                  DIO     equ     40h             ; data IN=1, out=0
   136                                  EXM     equ     20h             ; Execution phase in non-DMA mode
   137                                  				;  this should NEVER be set
   138                                  BUSY    equ     10h             ; Controller Busy
   139                                  FD3     equ     08h             ; DS3 is seeking
   140                                  FD2     equ     04h             ; DS2 is seeking
   141                                  FD1     equ     02h             ; DS1 is seeking
   142                                  FD0     equ     01h             ; DS0 is seeking
   143                                  
   144                                  ; MSR I/O status (in/out from CPU)
   145                                  MSR_IN	equ	RQM | DIO
   146                                  MSR_OUT	equ	RQM
   147                                  MSR_MASK equ	RQM | DIO
   148                                  
   149                                  ;  This is the list of controller commands that we use
   150                                  
   151                                  CMD_RECALIBRATE         equ     7       ; 1 param byte (unit #)
   152                                  					; No result bytes
   153                                  CMD_SENSE_INT_STATUS    equ     8       ; No paramter bytes
   154                                  					; 2 result bytes
   155                                  CMD_SENSE_DRIVE_STATUS  equ     4       ; 1 param byte
   156                                  					; 1 result byte
   157                                  CMD_SPECIFY             equ     3       ; 2 parameter bytes
   158                                  					; No result bytes
   159                                  CMD_SEEK                equ     15      ; 2 parameter bytes
   160                                  					; No result bytes
   161                                  CMD_READ_ID             equ     10      ; param in cmd; 1 param byte
   162                                  					; 7 result bytes
   163                                  CMD_READ_DATA           equ     6       ; params in cmd; 8 param bytes
   164                                  					; 7 result bytes
   165                                  CMD_WRITE_DATA          equ     5       ; params in cmd; 8 param bytes
   166                                  					; 7 result bytes
   167                                  CMD_READ_A_TRACK        equ     2       ; params in cmd; 8 param bytes
   168                                  					; 7 result bytes
   169                                  CMD_FORMAT_A_TRACK      equ     13      ; params in cmd; 5 param bytes
   170                                  					; 7 result bytes
   171                                  CMD_SCAN_EQUAL          equ     11h     ; params in cmd; 8 param bytes
   172                                  					; 7 result bytes
   173                                  CMD_SCAN_LOW_OR_EQUAL   equ     19h     ; params in cmd; 8 param bytes
   174                                  					; 7 result bytes
   175                                  CMD_SCAN_HIGH_OR_EQUAL  equ     1Dh     ; params in cmd; 8 param bytes
   176                                  					; 7 result bytes
   177                                  
   178                                  
   179                                  ; define the extra bits in some command codes
   180                                  
   181                                  CMD_MT          equ     80h             ; Multi-track operation
   182                                  CMD_MF          equ     40h             ; MFM recording mode
   183                                  CMD_SK          equ     20h             ; skip deleted data mark
   184                                  
   185                                  
   186                                  
   187                                  ; define the ST3 status bits
   188                                  
   189                                  ST3_WP          equ     40h             ; NOT Write Protected
   190                                  ST3_TR00        equ     10h             ; Track 0 signal
   191                                  ST3_WP2         equ     08h             ; duplicate of ST3_WP; ST3_2S for 8" floppies
   192                                  ST3_HS          equ     04h             ; head 0 or 1
   193                                  ST3_US          equ     03h             ; Unit mask (0..3)
   194                                  
   195                                  
   196                                  ; define the ST2 status bits
   197                                  
   198                                  ST2_CM          equ     40h             ; Control Mark (deleted data mark)
   199                                  ST2_DD          equ     20h             ; Data Error (data field)
   200                                  ST2_WC          equ     10h             ; Wrong Cylinder
   201                                  ST2_SH          equ     08h             ; Scan Hit (not used here)
   202                                  ST2_SN          equ     04h             ; Scan Not Satisfied (not used here)
   203                                  ST2_BC          equ     02h             ; Bad Cylinder
   204                                  ST2_MD          equ     01h             ; Missing address mark
   205                                  
   206                                  ST2_ANY         equ     ST2_CM+ST2_DD+ST2_WC+ST2_BC+ST2_MD
   207                                  
   208                                  
   209                                  ; define the ST1 status bits
   210                                  
   211                                  ST1_EN          equ     80h             ; End of cylinder
   212                                  ST1_DE          equ     20h             ; Data error (CRC err in address or data field)
   213                                  ST1_OR          equ     10h             ; Overrun (we will always see this flag)
   214                                  ST1_ND          equ     04h             ; No Data
   215                                  ST1_NW          equ     02h             ; Not writeable (WP is set)
   216                                  ST1_MA          equ     01h             ; Missing address mark
   217                                  
   218                                  %if FDC_PIGGYBACK_FIX
   219                                  ST1_ANY         equ     ST1_EN+ST1_DE+ST1_OR+ST1_ND+ST1_NW+ST1_MA
   220                                  %else
   221                                  ;ST1_ANY         equ     ST1_EN+ST1_DE+ST1_ND+ST1_NW+ST1_MA
   222                                  ST1_ANY         equ            ST1_DE+ST1_ND+ST1_NW+ST1_MA
   223                                  %endif
   224                                  
   225                                  ; define the ST0 status bits
   226                                  
   227                                  ST0_IC          equ     0C0h            ; Interrupt code mask
   228                                  					; 00 = normal termination
   229                                  					; 01 = abnormal termination
   230                                  					; 10 = invalid command
   231                                  					; 11 = abnormal termination -- change in ready status
   232                                  
   233                                  ST0_SE          equ     20h             ; Seek end
   234                                  ST0_EC          equ     10h             ; Equipment check
   235                                  ST0_NR          equ     08h             ; Not Ready (always 0 on WD37C65B)
   236                                  ST0_HS          equ     04h             ; Head Select
   237                                  ;ST0_US          equ     03h             ; Unit select mask
   238                                  ST0_US          equ     01h             ; Unit select mask
   239                                  
   240                                  ST0_ANY         equ     ST0_EC+ST0_NR   ; Any ST0 error
   241                                  
   242                                  
   243                                  
   244                                  ; The FDC interrupt control register
   245                                  fdc_int_control         equ     PIC_I3CON
   246                                  
   247                                  
   248                                  ; Standard int 13h stack frame layout is
   249                                  ; created by:   PUSHM  ALL,DS,ES
   250                                  ;               MOV    BP,SP
   251                                  ;
   252                                  offset_DI       equ     0
   253                                  offset_SI       equ     offset_DI+2
   254                                  offset_BP       equ     offset_SI+2
   255                                  offset_SP       equ     offset_BP+2
   256                                  offset_BX       equ     offset_SP+2
   257                                  offset_DX       equ     offset_BX+2
   258                                  offset_CX       equ     offset_DX+2
   259                                  offset_AX       equ     offset_CX+2
   260                                  offset_DS       equ     offset_AX+2
   261                                  offset_ES       equ     offset_DS+2
   262                                  offset_IP       equ     offset_ES+2
   263                                  offset_CS       equ     offset_IP+2
   264                                  offset_FLAGS    equ     offset_CS+2
   265                                  
   266                                  ; The byte registers in the stack
   267                                  offset_AL       equ     offset_AX
   268                                  offset_AH       equ     offset_AX+1
   269                                  offset_BL       equ     offset_BX
   270                                  offset_BH       equ     offset_BX+1
   271                                  offset_CL       equ     offset_CX
   272                                  offset_CH       equ     offset_CX+1
   273                                  offset_DL       equ     offset_DX
   274                                  offset_DH       equ     offset_DX+1
   275                                  
   276                                  
   277                                  ; FDC error codes (returned in AH)
   278                                  ;
   279                                  ERR_no_error            equ     0       ; no error (return Carry clear)
   280                                  ;   everything below returns with the Carry set to indicate an error
   281                                  ERR_invalid_command     equ     1
   282                                  ERR_address_mark_not_found      equ     2
   283                                  ERR_write_protect       equ     3
   284                                  ERR_sector_not_found    equ     4
   285                                  ERR_disk_removed        equ     6
   286                                  ERR_dma_overrun         equ     8
   287                                  ERR_dma_crossed_64k     equ     9
   288                                  
   289                                  
   290                                  ERR_media_type_not_found        equ     12	; 0Ch
   291                                  ERR_uncorrectable_CRC_error     equ     10h
   292                                  ERR_controller_failure  equ     20h
   293                                  ERR_seek_failed         equ     40h
   294                                  ERR_disk_timeout        equ     80h
   295                                  
   296                                  ERR_81			equ	81h	; fdc_ready_for_cmd, not rdy for input
   297                                  ERR_82			equ	82h	; fdc_ready_for_result, not rdy for output
   298                                  ERR_83			equ	83h	; input_result_from_fdc, after input, still busy
   299                                  ERR_84			equ	84h	; fdc_wait_seek_done, abnormal ST0_IC code
   300                                  ERR_85			equ	85h	; xfer_read_sector timeout
   301                                  ERR_86			equ	86h	; cylinder requested is invalid for drive
   302                                  ERR_87			equ	87h	; not on track 0 after recalibrate
   303                                  ERR_88			equ	88h	; wait for operation complete to be posted
   304                                  ERR_89			equ	89h	; fdc_ready_for_cmd, unexpectedly BUSY
   305                                  ERR_8A			equ	8Ah	; second "seek failed" error (ignore during Format)
   306                                  
   307                                  ERR_unknown		equ	8Fh	;   ADDED--JRC (may need to change)
   308                                  
   309                                  
   310                                  	SEGMENT	_TEXT
   311                                  %if SOFT_DEBUG > 1
   312                                  	extern  lites
   313                                  %endif
   314                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   315                                  ;  BIOS call entry for Floppy Disk driver
   316                                  ;       int  13h
   317                                  ;
   318                                  ; The Fixed Disk driver will move the vector from 13h to 40h
   319                                  ; At the moment there is no Fixed Disk Driver
   320                                  ;
   321                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   322                                  	global  BIOS_call_13h
   323                                  BIOS_call_13h:          ; Floppy driver entry
   324 00000000 FB                      	sti                     ; Enable interrupts
   325 00000001 061E60                  	pushm   all,ds,es       ; Standard register save
   326 00000004 89E5                    	mov     bp,sp           ; establish stack addressing
   327                                  
   328 00000006 FC                      	cld			; may NOT assume direction flag is clear
   329 00000007 6A40                    	push    bios_data_seg
   330 00000009 1F90                    	popm	ds              ; establish addressability for all functions
   331 0000000B C606AE0000              	mov	byte [lock_count],0	; clear the lock counter
   332                                  
   333                                  %if SOFT_DEBUG & DUMP
   334 00000010 06525150                	pushm	ax,cx,dx,es
   335                                  
   336 00000014 53                      	push	bx
   337 00000015 06                      	push	es
   338 00000016 30FF                    	xor	bh,bh
   339 00000018 88D3                    	mov	bl,dl
   340 0000001A 53                      	push	bx
   341 0000001B 88CB                    	mov	bl,cl
   342 0000001D 53                      	push	bx
   343 0000001E 88F3                    	mov	bl,dh
   344 00000020 53                      	push	bx
   345 00000021 88EB                    	mov	bl,ch
   346 00000023 53                      	push	bx
   347 00000024 89C3                    	mov	bx,ax
   348 00000026 53                      	push	bx
   349 00000027 0E                      	push	cs
   350 00000028 68[D708]                	push	rwvc
   351 0000002B E8(0000)                	call	_cprintf
   352 0000002E 83C412                  	add	sp,18
   353                                  
   354 00000031 58595A0790              	popm	ax,cx,dx,es
   355 00000036 30FF                    	xor	bh,bh
   356                                  %endif
   357 00000038 88E3                    	mov     bl,ah           ; set to index into dispatch table
   358 0000003A 80FC19                  	cmp     ah,max/2
   359 0000003D 7202                    	jb	.1
   360 0000003F B314                    	mov	bl,14h		; fn not defined for Floppy diskette
   361 00000041 30FF                    .1:	xor     bh,bh
   362 00000043 D1E3                    	shl     bx,1            ; index words
   363 00000045 2EFF97[8300]                cs  call    near [dispatch+bx]
   364                                  
   365                                  ; returns come here with AH set
   366                                  
   367 0000004A 08E4                    	or	ah,ah		; is return code 0? sets carry=0, too
   368 0000004C 7401                    	jz	exit_pops
   369                                  error_exit:
   370 0000004E F9                      	stc
   371                                  exit_pops:
   372 0000004F 88660F                  	mov	[bp+offset_AH],ah	; store for return
   373 00000052 89EC                    	mov     sp,bp		; remove any allocated variables
   374                                  %if SOFT_DEBUG & DUMP
   375 00000054 9C                      	pushm	f	;  ,ax,bx,cx,dx,es
   376 00000055 88E0                    	mov	al,ah		; save AH in AL
   377 00000057 9F                      	lahf			; get flags
   378 00000058 30FF                    	xor	bh,bh		; Zap BH
   379 0000005A 8A1E9300                	mov	bl,[fdc_op_start+1]
   380 0000005E 53                      	push	bx
   381 0000005F 8A1E9200                	mov	bl,[fdc_op_start]
   382 00000063 53                      	push	bx
   383 00000064 88E3                    	mov	bl,ah
   384 00000066 83E301                  	and	bx,1		; mask Carry
   385 00000069 53                      	push	bx
   386 0000006A 88C3                    	mov	bl,al		; former AH
   387 0000006C 53                      	push	bx
   388 0000006D 0E                      	push	cs		; far pointer to ...
   389 0000006E 68[0E09]                	push	fnret		;   format
   390 00000071 E8(0000)                	call	_cprintf
   391 00000074 83C40C                  	add	sp,12
   392 00000077 9D                      	popm	f	; ,ax,bx,cx,dx,es
   393                                  %endif
   394 00000078 611F900790              	popm    all,ds,es
   395 0000007D CA0200                  	retf	2			; return the carry
   396                                  
   397                                  
   398                                  
   399                                  ;fn00           ; Reset Disk System
   400                                  fn01:           ; Get Disk System Status
   401                                  ;fn02           ; Read Sector
   402                                  ;fn03           ; Write Sector
   403                                  ;fn04           ; Verify Sector
   404                                  ;fn05:           ; Format Track
   405                                  fn06:           ; Format Bad Track (fixed disk) [PC]
   406                                  fn07:           ; Format Drive (fixed disk)     [PC]
   407                                  ;fn08           ; Get Drive Parameters
   408                                  fn09:
   409                                  fn0A:
   410                                  fn0B:
   411                                  fn0C:
   412                                  fn0D:
   413                                  fn0E:
   414                                  fn0F:
   415                                  fn10:
   416                                  fn11:
   417                                  fn12:
   418                                  fn13:
   419                                  fn14:		; *** fixed disk only ***
   420                                  ;fn15:		; Get Disk Type                 [AT]
   421                                  ;fn16:           ; Get Disk Change Status (floppy)
   422                                  fn17:           ; Set Disk Type (floppy)
   423                                  ;fn18:           ; Set Media Type for Format (floppy)
   424                                  undefined:
   425 00000080 B401                    	mov     ah,ERR_invalid_command	; equ 1
   426 00000082 C3                      	ret
   427                                  
   428                                  
   429                                  dispatch:
   430 00000083 [ED02]                  	dw      fn00    ; Reset Disk System
   431 00000085 [8000]                  	dw      fn01    ;
   432 00000087 [D303]                  	dw      fn02
   433 00000089 [DD03]                  	dw      fn03
   434 0000008B [E703]                  	dw      fn04
   435 0000008D [6704]                  	dw      fn05
   436 0000008F [8000]                  	dw      fn06
   437 00000091 [8000]                  	dw      fn07
   438 00000093 [9103]                  	dw      fn08
   439 00000095 [8000]                  	dw      fn09
   440 00000097 [8000]                  	dw      fn0A
   441 00000099 [8000]                  	dw      fn0B
   442 0000009B [8000]                  	dw      fn0C
   443 0000009D [8000]                  	dw      fn0D
   444 0000009F [8000]                  	dw      fn0E
   445 000000A1 [8000]                  	dw      fn0F
   446 000000A3 [8000]                  	dw      fn10
   447 000000A5 [8000]                  	dw      fn11
   448 000000A7 [8000]                  	dw      fn12
   449 000000A9 [8000]                  	dw      fn13
   450 000000AB [8000]                  	dw      fn14
   451 000000AD [0405]                  	dw      fn15
   452 000000AF [1A05]                  	dw      fn16
   453 000000B1 [8000]                  	dw      fn17
   454 000000B3 [3205]                  	dw      fn18
   455                                  max     equ     $-dispatch
   456                                  
   457                                  
   458                                  ;
   459                                  ;   Floppy Drive Types  (fn08)
   460                                  ;
   461                                  ;                               We support:
   462                                  ;       1 = 5.25" 360K 40track     yes
   463                                  ;       2 = 5.25" 1.2M 80track     yes
   464                                  ;       3 = 3.5"  720K 80track     yes
   465                                  ;       4 = 3.5" 1.44M 80track     yes
   466                                  ;       6 = 3.5" 2.88M 80track      no  (WD37C65CJM & 32Mhz osc)
   467                                  ;	7 = 3.5" 1.28M 1024sect	    no  (Japan)
   468                                  ;
   469                                  ;   Floppy Combos
   470                                  ;       5 = 5.25" 360K 40track in Drive Type 2   	no
   471                                  ;	8 = 5.25" 512k 77track/128sector in Drv 2	(future) CP/M
   472                                  ;	9 = 3.5" 256k 77track/128sector in Drv 3	(future) CP/M
   473                                  ;      10 = 3.5" 512k 77track/128sector in Drv 4	(future) CP/M
   474                                  ;;
   475                                  
   476                                  D_table:
   477 000000B5 0000                    	dw      0
   478 000000B7 [CB00]                  	dw      DTAB1	; 360K	(MFM)
   479 000000B9 [D800]                  	dw      DTAB2	; 1.2M
   480 000000BB [E500]                  	dw      DTAB3	; 720K
   481 000000BD [F200]                  	dw      DTAB4	; 1.44M
   482 000000BF 0000                    	dw      0; DTAB5
   483 000000C1 0000                    	dw      0; DTAB6
   484 000000C3 [1901]                  	dw      DTAB7	; 1024 byte sectors (Japan)
   485 000000C5 [2601]                  	dw      DTAB8	; CP/M 26/77 in 1.2M drive	(128 byte FM sectors)
   486 000000C7 [3301]                  	dw      DTAB9	; CP/M 13/77 in 720K drive
   487 000000C9 [4001]                  	dw      DTAB10	; CP/M 26/77 in 1.44M drive
   488                                  L_table         equ     ($ - D_table)/2
   489                                  
   490                                  
   491                                  ;   Disk Information
   492                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   493                                  ;;; The DOS MFM floppies
   494                                  ; 360K 5.25" DD floppy
   495 000000CB DF022502092AFF50F6-     DTAB1:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 80h
   495 000000D4 0F082780           
   496                                  
   497                                  ; 1.2M 5.25" HD floppy
   498 000000D8 DF0225020F1BFF54F6-     DTAB2:  db      0DFh, 2, 25h,  2, 15, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 8, 79, 00h
   498 000000E1 0F084F00           
   499                                  
   500                                  ; 720K 3.5" or 5.25" DD floppy
   501 000000E5 DF022502092AFF50F6-     DTAB3:  db      0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 80h
   501 000000EE 0F084F80           
   502                                  
   503                                  ; 1.44M 3.5" HD floppy
   504 000000F2 AF022502121BFF6CF6-     DTAB4:  db      0AFh, 2, 25h,  2, 18, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 8, 79, 00h
   504 000000FB 0F084F00           
   505                                  
   506                                  ; 360K 5.25" DD floppy in 1.2M HD drive
   507 000000FF DF022502092AFF50F6-     DTAB5:	db	0DFh, 2, 25h,  2, 9, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 8, 39, 40h
   507 00000108 0F082740           
   508                                  
   509                                  ; 2.88M 3.5" XD floppy
   510 0000010C AF022502241BFF50F6-     DTAB6:	db      0AFh, 2, 25h,  2, 36, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 8, 79, 0C0h
   510 00000115 0F084FC0           
   511                                  
   512                                  ; 1.28M 3.5" HD floppy with 1K sectors (Japan)
   513 00000119 AF0225030835FF74F6-     DTAB7:	db	0AFh, 2, 25h,  3,  8, 35h, 0FFh, 74h, 0F6h, 0Fh, 8, 79, 00h
   513 00000122 0F084F00           
   514                                  
   515                                  ;               specify  off   N  R  gp   DTL   gp3  fill  unk  on cyl clk
   516                                  ;;; The CP/M FM floppies
   517                                  ; 500K 5.25" CP/M (FM) floppy in 1.2M drive
   518 00000126 DF0225001A098023E5-     DTAB8:  db      0DFh, 2, 25h,  0, 26,  9, 80h, 35, 0E5h, 0Fh, 8, 76, 00h
   518 0000012F 0F084C00           
   519                                  ;;;				       7h      1Bh
   520                                  
   521                                  ; 250K 3.5" CP/M (FM) floppy in 720K drive
   522 00000133 DF0225000D138046E5-     DTAB9:  db      0DFh, 2, 25h,  0, 13, 19, 80h, 70, 0E5h, 0Fh, 8, 76, 80h
   522 0000013C 0F084C80           
   523                                  
   524                                  ; 500K 3.5" CP/M (FM) floppy in 1.44M drive
   525 00000140 AF0225001A15804BE5-     DTAB10: db      0AFh, 2, 25h,  0, 26, 21, 80h, 75, 0E5h, 0Fh, 8, 76, 00h
   525 00000149 0F084C00           
   526                                  
   527                                  
   528                                  ; DTAB table offsets
   529                                  DTAB_specify    	equ     0
   530                                  DTAB_specify2   	equ     DTAB_specify+1
   531                                  DTAB_turnoff_ticks	equ     DTAB_specify2+1
   532                                  DTAB_N_param    	equ     DTAB_turnoff_ticks+1
   533                                  DTAB_EOT_nsect  	equ     DTAB_N_param+1
   534                                  DTAB_rw_gap     	equ     DTAB_EOT_nsect+1
   535                                  DTAB_data_len   	equ     DTAB_rw_gap+1
   536                                  DTAB_fmt_gap3   	equ     DTAB_data_len+1
   537                                  DTAB_fmt_fill   	equ     DTAB_fmt_gap3+1
   538                                  DTAB_unknown    equ     DTAB_fmt_fill+1
   539                                  DTAB_startup		equ     DTAB_unknown+1	; in 1/8 seconds
   540                                  DTAB_max_cylinder	equ     DTAB_startup+1
   541                                  DTAB_control    equ     DTAB_max_cylinder+1
   542                                  
   543                                  
   544                                  
   545                                  ;
   546                                  ; Returns:
   547                                  ;	AL = contents of FDC_MSR  (Main Status Register)
   548                                  ;
   549                                  get_msr:
   550 0000014D 52                      	push	dx
   551 0000014E BA8004                  	mov     dx,FDC_MSR
   552 00000151 EC                      	in      al,dx
   553                                  %if SOFT_DEBUG > 1
   554                                  	push    ax
   555                                  	call    lites
   556                                  %endif
   557 00000152 5A                      	pop	dx
   558 00000153 C3                      	ret
   559                                  
   560                                  ; delay for about 12 microseconds for MSR to be set
   561                                  	extern  microsecond
   562                                  	global  wait12
   563                                  wait12:
   564 00000154 51                      	push    cx
   565                                  %if 1
   566                                  ;	mov	cx,12		; 12 microseconds
   567 00000155 30ED                    	xor	ch,ch
   568 00000157 8A0EFF00                	mov	cl,[cpu_xtal]	; 2x clock (32usec on 16Mhz CPU)
   569 0000015B D0E9                    	shr	cl,1
   570 0000015D 83E905                  	sub	cx,5		; fudge factor for overhead
   571                                  %else
   572                                  	xor	ch,ch
   573                                  	mov	cl,[wait12_count]
   574                                  %endif
   575 00000160 E8(0000)                	call    microsecond
   576 00000163 59                      	pop     cx
   577 00000164 C3                      	ret
   578                                  
   579                                  
   580                                  wait1000:
   581 00000165 51                      	push	cx
   582 00000166 B9E803                  	mov	cx,1000		; 1 ms delay
   583 00000169 E8(0000)                	call	microsecond
   584 0000016C 59                      	pop	cx
   585 0000016D C3                      	ret
   586                                  
   587                                  ;
   588                                  ;  Convention used below
   589                                  ;     Flags:           Meaning:
   590                                  ;       C=1             error
   591                                  ;       C=0, AH=0       okay
   592                                  ;       C=0, AH=3+      complete
   593                                  ;
   594                                  	global  fdc_ready_for_command
   595                                  fdc_ready_for_command:
   596 0000016E 51                      	push	cx
   597                                  
   598                                  .0:
   599 0000016F B9E803                  	mov	cx,1000
   600 00000172 E8DFFF                  .1:	call	wait12
   601 00000175 E8D5FF                  	call    get_msr
   602 00000178 A880                    	test    al,RQM 		; C=0
   603 0000017A E1F6                    	loopz	.1
   604                                  ; try to compensate for MSDOS anomaly with a BUSY test
   605 0000017C 7508                    	jnz	.req
   606 0000017E A810                    	test	al,BUSY		; How does MSDOS manage this???
   607 00000180 74ED                    	jz      .0
   608 00000182 B489                    	mov	ah,ERR_89
   609 00000184 EB06                    	jmp	.err
   610                                  
   611                                  .req:
   612 00000186 A840                    	test    al,DIO          ; C=0,	clear the carry
   613 00000188 7405                    	jz     .2               ; ready for input?
   614 0000018A B481                    	mov	ah,ERR_81	; not ready for input
   615 0000018C F9                      .err:	Error			; C=1, signal error
   616 0000018D EB02                    	jmp	.99
   617                                  
   618 0000018F 30E4                    .2:	Okay			; AH=0, C=0
   619 00000191 59                      .99:	pop	cx
   620 00000192 C3                      	ret
   621                                  ; returns Error or Okay
   622                                  
   623                                  
   624                                  	global  fdc_ready_for_result
   625                                  fdc_ready_for_result:
   626 00000193 E8BEFF                  	call    wait12
   627 00000196 E8B4FF                  	call    get_msr
   628 00000199 A810                    	test    al,BUSY         ; controller busy?
   629 0000019B 7505                    	jnz	.0 		; jump if busy
   630 0000019D 80CC03                  	Complete		; not busy, return Complete
   631 000001A0 EB15                    	jmp	.99
   632                                  .0:
   633 000001A2 E8AFFF                  	call	wait12
   634 000001A5 E8A5FF                  .1:	call    get_msr
   635 000001A8 A880                    	test    al,RQM          ; wait for RQM
   636 000001AA 74F9                    	jz      .1
   637                                  
   638 000001AC A840                    	test    al,DIO		; set C=0, Z-flag
   639 000001AE 7505                    	jnz     .5		; DIO==1 means output
   640 000001B0 B482                    	mov	ah,ERR_82
   641 000001B2 F9                      	Error
   642 000001B3 EB02                    	jmp	.99
   643                                  
   644 000001B5 30E4                    .5:	Okay
   645 000001B7 C3                      .99:	ret
   646                                  ; returns Error, Okay, or Complete
   647                                  
   648                                  
   649                                  
   650                                  ; byte to output is in AL
   651                                  ; AH=0 and Carry=0 if all Okay
   652                                  ; Carry=1, AH=code if FDC not ready
   653                                  	global  output_byte_to_fdc
   654                                  output_byte_to_fdc:
   655 000001B8 52                      	pushm	dx
   656                                  
   657 000001B9 88C2                    	mov	dl,al
   658 000001BB E8B0FF                  	call    fdc_ready_for_command
   659 000001BE 88D0                    	mov	al,dl
   660 000001C0 7206                    	jc      .8              ; propagate error
   661                                  
   662 000001C2 BA8104                  	mov     dx,FDC_DATA
   663 000001C5 EE                      	out     dx,al
   664 000001C6 30E4                    	Okay			; C=0, AH=okay
   665                                  .8:
   666 000001C8 5A                      	popm	dx
   667 000001C9 C3                      	ret                     ; C=0, AH=okay
   668                                  ; returns Error or Okay
   669                                  
   670                                  
   671                                  	global  input_byte_from_fdc
   672                                  input_byte_from_fdc:
   673 000001CA 52                      	push	dx
   674 000001CB E8C5FF                  	call    fdc_ready_for_result
   675 000001CE 7208                    	jc      .9              ; propagate error
   676 000001D0 7506                    	jnz	.9		; if (Complete) return Complete;
   677                                  
   678 000001D2 BA8104                  	mov     dx,FDC_DATA
   679 000001D5 EC                      	in      al,dx
   680 000001D6 30E4                    	Okay			; return Okay
   681                                  .9:
   682 000001D8 5A                      	pop	dx
   683 000001D9 C3                      	ret                     ;
   684                                  ; returns Error, Okay, or Complete
   685                                  
   686                                  
   687                                  ;  CX = length of command
   688                                  ;  DX:SI = pointer to command (not DS:SI, we'll set this up)
   689                                  ;
   690                                  	global  output_cmd_to_fdc
   691                                  output_cmd_to_fdc:
   692 000001DA 0656                    	pushm   si,es
   693 000001DC 8EC2                    	mov     es,dx           ; DS:SI is now the source
   694 000001DE 90                      	cnop
   695                                  
   696                                  %if SOFT_DEBUG & DUMP
   697 000001DF 268A04                    es	mov	al,[si]			; record two bytes of command
   698 000001E2 A29200                    	mov	[fdc_op_start],al
   699 000001E5 268A4401                  es	mov	al,[si+1]		; first & second
   700 000001E9 A29300                    	mov	[fdc_op_start+1],al
   701                                  %endif
   702                                  
   703 000001EC E83F07                  	call	@disable
   704                                  .1:
   705 000001EF 26AC                      es	lodsb			; note segment override
   706 000001F1 E8C4FF                  	call    output_byte_to_fdc  ; returns error or okay
   707 000001F4 7206                    	jc      .7              ; propagate any error
   708 000001F6 E2F7                    	loop    .1
   709                                  
   710 000001F8 30E4                    	Okay			; return ok
   711 000001FA EB01                    	jmp	.9
   712                                  
   713 000001FC F9                      .7:	Error			; propagate error
   714                                  
   715 000001FD E83F07                  .9:	call	@enable
   716 00000200 5E0790                  	popm	si,es
   717 00000203 C3                      	ret
   718                                  ; returns Error or Okay
   719                                  
   720                                  
   721                                  
   722                                  ; assumes DS points at BIOS Data Area
   723                                  ; preserves DI
   724                                  	global  input_result_from_fdc
   725                                  input_result_from_fdc:
   726 00000204 5157                    	pushm   di,cx
   727 00000206 E82507                  	call	@disable	; lock the operation
   728                                  
   729 00000209 BF4200                  	mov     di,fdc_ctrl_status      ; in BIOS Data Area
   730 0000020C B90800                  	mov     cx,8            ; 7 bytes input, then 'complete'
   731                                  
   732 0000020F E8B8FF                  .0:     call    input_byte_from_fdc
   733 00000212 7217                    	jc      .9              ; propagate error
   734 00000214 7511                    	jnz     .8              ; if complete, return okay
   735                                  
   736 00000216 8805                    	mov     byte [di],al    ; store the result
   737 00000218 47                      	inc     di
   738 00000219 E2F4                    	loop    .0
   739                                  
   740 0000021B E836FF                  	call	wait12		;
   741 0000021E E82CFF                  	call	get_msr		; check for busy
   742 00000221 A810                    	test	al,BUSY
   743                                  
   744 00000223 B483                    	mov	ah,ERR_83
   745 00000225 7504                    	jnz	.95		; return error if busy
   746                                  
   747                                  .8:
   748 00000227 30E4                    	Okay			; return okay
   749 00000229 EB01                    	jmp	.99		; single return point
   750                                  
   751                                  .9:
   752 0000022B F9                      .95:	Error			; return error;
   753                                  
   754 0000022C E81007                  .99:	call	@enable		; unlock the operation
   755 0000022F 5F59                    	popm	di,cx
   756 00000231 C3                      	ret
   757                                  ; returns Error, Okay, or Complete
   758                                  
   759                                  
   760                                  %define INT_ENABLE 1
   761                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   762                                  ;
   763                                  ;  Floppy Disk Controller
   764                                  ;               Interrupt Handler
   765                                  ;
   766                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   767                                  	global  fdc_interrupt_level
   768                                  fdc_interrupt_level:
   769                                  %if INT_ENABLE
   770 00000232 FB                      	sti
   771                                  %endif
   772 00000233 1E60                    	pushm   all,ds
   773 00000235 FC                      	cld                     ; just be sure
   774                                  
   775 00000236 6A40                    	push    bios_data_seg
   776 00000238 1F90                    	popm    ds
   777                                  %if INT_ENABLE==0
   778                                  	inc	byte [lock_count]	; so we don't re-enable
   779                                  %endif
   780 0000023A E810FF                  	call    get_msr
   781 0000023D A810                    	test    al,BUSY         ; test for controller busy
   782 0000023F 740A                    	jz      .4
   783                                  ; BUSY is set
   784 00000241 E8C0FF                  	call    input_result_from_fdc
   785 00000244 18C0                    	sbb     al,al           ; carry to AL
   786 00000246 A24100                  	mov     byte [fdc_status],al    ; FF=error, 0=okay
   787 00000249 EB2C                    	jmp     .9              ; we got the results
   788                                  
   789                                  
   790                                  ; FDC not busy:
   791                                  
   792                                  .4:
   793                                  ;;        xor     bh,bh           ; BH = false
   794 0000024B B008                    .5:     mov     al,CMD_SENSE_INT_STATUS
   795 0000024D E868FF                  	call    output_byte_to_fdc
   796 00000250 7225                    	jc      .9              ; quit if error
   797 00000252 E8AFFF                  	call    input_result_from_fdc
   798 00000255 7220                    	jc      .9
   799                                  
   800 00000257 A04200                  	mov	al,[fdc_ctrl_status]	; get ST0
   801 0000025A 3480                    	xor	al,80h			; IC= 10xxxxxxb (invalid)
   802 0000025C 24C0                    	and	al,ST0_IC		; isolate IC
   803 0000025E 7417                    	je	.9			; invalid command
   804                                  
   805 00000260 A14200                  	mov	ax,[fdc_ctrl_status]	; get ST0 + PCN (present cylinder)
   806 00000263 A820                    	test	al,ST0_SE		; test Seek End condition
   807 00000265 74E4                    	jz	.5
   808                                  
   809 00000267 89C7                    	mov	di,ax			;
   810 00000269 83E701                  	and	di,ST0_US		; isolate unit number
   811 0000026C 88A59400                	mov	[fdc_cylinder+di],ah	; set PCN from controller
   812 00000270 800E3E0004              	or	byte [fdc_drv_calib],04h     ;POST Seek End seen
   813 00000275 EBD4                    	jmp     .5
   814                                  
   815                                  
   816                                  .9:
   817 00000277 800E3E0001              	or	byte [fdc_drv_calib],01h     ;POST end of FDC interrupt
   818                                  %if INT_ENABLE==0
   819                                  	dec	byte [lock_count]	; restore the lock count
   820                                  %endif
   821                                  ; signal EOI (End of Interrupt)
   822 0000027C BA22FF                  	mov     dx,PIC_EOI              ; EOI register
   823 0000027F B80080                  	mov     ax,EOI_NSPEC            ; non-specific
   824 00000282 EF                      	out     dx,ax                   ; signal it
   825                                  
   826 00000283 611F90                  	popm    all,ds
   827 00000286 CF                      	iret
   828                                  
   829                                  
   830                                  
   831                                  	global  fdc_timer_hook
   832                                  ; called from Timer Tick code with DS->BIOS data area
   833                                  ; Destroys AX and DX
   834                                  	global  fdc_timer_hook
   835                                  fdc_timer_hook:
   836 00000287 803E400000              	cmp     byte [fdc_motor_ticks],0
   837 0000028C 740E                    	je      .9
   838 0000028E FE0E4000                	dec     byte [fdc_motor_ticks]
   839 00000292 7508                    	jnz     .9
   840                                  ; timer expired, stop the motors
   841 00000294 80263F00CF              	and     byte [fdc_motor_LDOR],~(MOEN1+MOEN2)
   842 00000299 E80100                  	call    out_LDOR_mem
   843 0000029C C3                      .9:     ret
   844                                  
   845                                  
   846                                  
   847                                  ; FDC Operations Register operations
   848                                  ; put out the LDOR write-only register
   849                                  ;  Assumes DS is BIOS data segment
   850                                  ; Destroys AX and DX
   851                                  out_LDOR_mem:
   852 0000029D A03F00                  	mov     al,[fdc_motor_LDOR]
   853 000002A0 BA8604                  	mov     dx,FDC_LDOR
   854 000002A3 EE                      	out     dx,al
   855 000002A4 C3                      	ret
   856                                  
   857                                  
   858                                  ; wait until all seeking is done
   859                                  ; assumes DS is set to BIOS data area
   860                                  ;
   861                                  	global  fdc_wait_seek_done
   862                                  fdc_wait_seek_done:
   863                                  .1:
   864 000002A5 E8ACFE                  	call    wait12
   865 000002A8 E8A2FE                  	call    get_msr
   866 000002AB A80F                    	test    al,0Fh          ; test all the seek bits
   867 000002AD 740C                    	jz      .8
   868 000002AF 803E400000              	cmp     byte [fdc_motor_ticks],0
   869 000002B4 75EF                    	jnz     .1
   870 000002B6 B480                    	mov	ah,ERR_disk_timeout
   871 000002B8 F9                      .7:     Error			; signal error
   872 000002B9 EB22                    	jmp	.9
   873                                  
   874                                  .8:     ; seek is done, check ST0 bits
   875 000002BB F6063E0004              	test	byte [fdc_drv_calib],04h	; Seek End seen?
   876 000002C0 7512                    	jnz	.okay
   877                                  
   878 000002C2 F6064200C0              	test    byte [fdc_ctrl_status],ST0_IC   ; interrupt code
   879 000002C7 B484                    	mov	ah,ERR_84
   880 000002C9 75ED                    	jnz     .7
   881 000002CB F606420020              	test    byte [fdc_ctrl_status],ST0_SE   ; Seek End
   882 000002D0 B440                    	mov	ah,ERR_seek_failed
   883 000002D2 74E4                    	jz      .7
   884                                  .okay:
   885                                  
   886                                  %if 0
   887                                  ; add settle time -- may not really be needed
   888                                  	mov	al,[fdc_motor_ticks]
   889                                  	add	al,450/54
   890                                  	xchg	al,[fdc_motor_ticks]
   891                                  .settle:
   892                                  	cmp	[fdc_motor_ticks],al
   893                                  	ja	.settle
   894                                  %else
   895                                  ; add time for more revolutions if a seek occurs
   896 000002D4 2E8A4702                  cs	mov	al,[DTAB_turnoff_ticks+bx]
   897 000002D8 A24000                    	mov	[fdc_motor_ticks],al
   898                                  %endif
   899                                  
   900 000002DB 30E4                    	Okay					; IC==00 and SE=1
   901 000002DD C3                      .9	ret
   902                                  
   903                                  ;
   904                                  ;  power on init
   905                                  ;
   906                                  	global  @floppy_init
   907                                  @floppy_init:
   908                                  
   909                                  %if DEBUG
   910                                  ; do some debug I/O
   911 000002DE 52                      	push 	dx
   912 000002DF 50                      	push 	ax
   913 000002E0 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
   914 000002E3 B003                    	mov	al,03h
   915 000002E5 EE                      	out	dx,al
   916 000002E6 58                      	pop 	ax
   917 000002E7 5A                      	pop 	dx
   918                                  %endif
   919                                  
   920 000002E8 B400                    	mov     ah,0            ; fn00
   921 000002EA CD13                    	int     13h
   922 000002EC C3                      	ret
   923                                  
   924                                  
   925                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   926                                  ;  Function 00h         Reset the Disk System
   927                                  ;       Used both at power on and after a serious error
   928                                  ;
   929                                  ;  Enter with:
   930                                  ;       AH = 00h
   931                                  ;       DL = drive 0 or 1
   932                                  ;
   933                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   934                                  fn00:
   935                                  
   936                                  %if DEBUG
   937                                  ; do some debug I/O
   938 000002ED 52                      	push 	dx
   939 000002EE 50                      	push 	ax
   940 000002EF BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
   941 000002F2 B004                    	mov	al,04h
   942 000002F4 EE                      	out	dx,al
   943 000002F5 58                      	pop 	ax
   944 000002F6 5A                      	pop 	dx
   945                                  %endif
   946                                  
   947                                  
   948 000002F7 B81700                  	mov     ax,0017h        ; LTM=1, MSK=0, PRI=7    (07h for LTM=0)
   949 000002FA BA3EFF                  	mov     dx,fdc_int_control
   950 000002FD EF                      	out     dx,ax           ; enable interrupt controller
   951 000002FE C606AD0020              	mov	byte [wait12_count],32	; this is about the max.
   952                                  
   953 00000303 E84EFE                  	call    wait12          ; wait 12 microseconds
   954 00000306 E844FE                  	call    get_msr         ; set BASE mode
   955 00000309 E848FE                  	call    wait12          ; wait 12 microseconds
   956                                  
   957 0000030C C6063F0008              	mov     byte [fdc_motor_LDOR],(MODE + RESET + DMAEN)         ; set PC_AT mode
   958 00000311 E889FF                  	call    out_LDOR_mem
   959 00000314 E83DFE                  	call    wait12
   960                                  
   961                                  %if DEBUG
   962                                  ; do some debug I/O
   963 00000317 52                      	push 	dx
   964 00000318 50                      	push 	ax
   965 00000319 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
   966 0000031C B005                    	mov	al,05h
   967 0000031E EE                      	out	dx,al
   968 0000031F 58                      	pop 	ax
   969 00000320 5A                      	pop 	dx
   970                                  %endif
   971                                  
   972                                  
   973                                  %if 1
   974                                  ;;; This read may not be necessary, unless Special Mode is set
   975 00000321 BA8504                  	mov     dx,FDC_LDCR
   976 00000324 EC                      	in      al,dx           ; read a write-only register to latch Mode
   977                                  ;;;;;
   978                                  %endif
   979 00000325 E83DFE                  	call	wait1000
   980                                  
   981 00000328 800E3F000C              	or	byte [fdc_motor_LDOR],(MODE + NO_RESET + DMAEN)      ; remove the RESET
   982 0000032D E86DFF                  	call    out_LDOR_mem
   983 00000330 E821FE                  	call	wait12
   984                                  
   985                                  %if DEBUG
   986                                  ; do some debug I/O
   987 00000333 52                      	push 	dx
   988 00000334 50                      	push 	ax
   989 00000335 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
   990 00000338 B006                    	mov	al,06h
   991 0000033A EE                      	out	dx,al
   992 0000033B 58                      	pop 	ax
   993 0000033C 5A                      	pop 	dx
   994                                  %endif
   995                                  
   996                                  
   997                                  %if 0
   998                                  	mov     dx,FDC_LDCR
   999                                  	mov     al,FDC_HD               ; set for HD disks
  1000                                  	out     dx,al
  1001                                  %endif
  1002                                  
  1003 0000033D BACAFF                  	mov	dx,DMA0+DMACW
  1004                                  %if 1
  1005 00000340 B80400                  	mov	ax,4			; set change bit
  1006                                  %else
  1007                                  	in	ax,dx
  1008                                  	and	ax,~2			; clear the stop bit
  1009                                  	or	ax,4			; set the change bit
  1010                                  %endif
  1011 00000343 EF                      	out	dx,ax
  1012                                  
  1013                                  %if DEBUG
  1014                                  ; do some debug I/O
  1015 00000344 52                      	push 	dx
  1016 00000345 50                      	push 	ax
  1017 00000346 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
  1018 00000349 B007                    	mov	al,07h
  1019 0000034B EE                      	out	dx,al
  1020 0000034C 58                      	pop 	ax
  1021 0000034D 5A                      	pop 	dx
  1022                                  %endif
  1023                                  
  1024                                  
  1025 0000034E BA34FF                  	mov     dx,PIC_DMA0CR
  1026 00000351 B80700                  	mov     ax,0007h        ; MSK=0, PRI=7
  1027 00000354 EF                      	out     dx,ax           ; enable DMA0 interrupts
  1028                                  
  1029 00000355 31C0                    	xor	ax,ax
  1030 00000357 A24000                  	mov	[fdc_motor_ticks],al	; Zero the timer tick counter
  1031 0000035A A28B00                  	mov	[fdc_last_rate],al	; force a specify command
  1032                                  
  1033 0000035D 8EC0                    	mov	es,ax
  1034 0000035F 90                      	cnop
  1035 00000360 26A37800                  es	mov	[1Eh*4],ax
  1036 00000364 26A37A00                  es	mov	[1Eh*4+2],ax		; Zap the parameter pointer
  1037                                  
  1038 00000368 C7069400FFFF            	mov	word [fdc_cylinder],-1	; Specify & Recalibration needed
  1039                                  ;***	mov	[fdc_cylinder+1],-1	; done by above instruction
  1040                                  
  1041                                  ; now allow time for the polling interrupts
  1042 0000036E B90100                  	mov	cx, 102400>>16		; 0.1 seconds
  1043 00000371 31D2                    	xor	dx,dx			; CX:DX is delay in usec
  1044 00000373 B486                    	mov	ah,86h			; delay in microseconds
  1045 00000375 CD15                    	int	15h
  1046                                  
  1047                                  %if DEBUG
  1048                                  ; do some debug I/O
  1049 00000377 52                      	push 	dx
  1050 00000378 50                      	push 	ax
  1051 00000379 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
  1052 0000037C B008                    	mov	al,08h
  1053 0000037E EE                      	out	dx,al
  1054 0000037F 58                      	pop 	ax
  1055 00000380 5A                      	pop 	dx
  1056                                  %endif
  1057                                  
  1058                                  
  1059 00000381 E880FE                  	call	input_result_from_fdc
  1060                                  
  1061                                  %if DEBUG
  1062                                  ; do some debug I/O
  1063 00000384 52                      	push 	dx
  1064 00000385 50                      	push 	ax
  1065 00000386 BA3006                  	mov	dx,FRONT_PANEL_LED		;JRC's debug lights
  1066 00000389 B009                    	mov	al,09h
  1067 0000038B EE                      	out	dx,al
  1068 0000038C 58                      	pop 	ax
  1069 0000038D 5A                      	pop 	dx
  1070                                  %endif
  1071                                  
  1072                                  
  1073 0000038E 30E4                    	Okay			; signal good execution
  1074 00000390 C3                      	ret			; end of FN00
  1075                                  
  1076                                  
  1077                                  
  1078                                  
  1079                                  
  1080                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1081                                  ;  Function 08h         Get Drive Parameters
  1082                                  ;
  1083                                  ;  Enter with:
  1084                                  ;       AH = 08h
  1085                                  ;       DL = drive 0 or 1
  1086                                  ;
  1087                                  ;  Return with:
  1088                                  ;       Carry clear if no error
  1089                                  ;       BL = drive type (2 or 4 for us)
  1090                                  ;       CH = max cylinder number
  1091                                  ;       CL = max sector number
  1092                                  ;       DH = max head number
  1093                                  ;       DL = number of drives
  1094                                  ;       ES:DI = address of disk parameter table
  1095                                  ;
  1096                                  ;       Carry set on error
  1097                                  ;       AH = error code
  1098                                  ;
  1099                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1100                                  fn08:           ; Get Drive Parameters
  1101 00000391 A01000                  	mov	al,[equipment_flag]
  1102 00000394 B401                    	mov	ah,1
  1103 00000396 20C4                    	and	ah,al			; any floppies at all?
  1104 00000398 7407                    	jz	.2
  1105 0000039A C0C002                  	rol	al,2			; at least one
  1106 0000039D 2403                    	and	al,3
  1107 0000039F 00C4                    	add	ah,al			; 1..4
  1108                                  .2:
  1109 000003A1 88660A                  	mov	[offset_DL+bp],ah		; return # of drives
  1110 000003A4 E8E601                  	call	check_DL
  1111 000003A7 7221                    	jc	.err_no_drive
  1112 000003A9 E8F801                  	call	get_disk_type
  1113 000003AC 884608                  	mov	[offset_BL+bp],al		; return BL = disk type
  1114 000003AF E80102                  	call	get_media
  1115 000003B2 2E8A670B                  cs	mov	ah,[DTAB_max_cylinder+bx]
  1116 000003B6 2E8A4704                  cs	mov	al,[DTAB_EOT_nsect+bx]
  1117 000003BA 89460C                    	mov	[offset_CX+bp],ax		; return CYL | SECT in CX
  1118 000003BD C6460B01                	mov	byte [offset_DH+bp],1		; head max. always 1
  1119 000003C1 8C4E12                  	mov	[offset_ES+bp],cs		; return ES  param table
  1120 000003C4 895E00                  	mov	[offset_DI+bp],bx		; return DI  param table
  1121                                  
  1122 000003C7 30E4                    	xor	ah,ah				; no error
  1123 000003C9 C3                      	ret
  1124                                  
  1125                                  .err_no_drive:
  1126 000003CA B401                    	mov	ah,ERR_invalid_command		; error if no floppies
  1127 000003CC C3                      	ret					; DL is still zero !!!
  1128                                  
  1129                                  
  1130                                  
  1131                                  
  1132                                  
  1133                                  
  1134                                  %if 0
  1135                                  ; validate the READ/WRITE CHS,SC parameters
  1136                                  ;       Enter with DI pointing at the type table
  1137                                  ;
  1138                                  ;  Carry clear if okay
  1139                                  ;  Carry set if invalid
  1140                                  ;       AX & all other registers are preserved
  1141                                  validate_call:
  1142                                  	push    ax
  1143                                  
  1144                                     cs   cmp     ch,[DTAB_max_cyl+di]
  1145                                  	jnbe    .7
  1146                                     cs   mov     ah,[DI_heads+di]
  1147                                  	sub     ah,dh
  1148                                  	jbe     .7
  1149                                     cs   mov     al,[DTAB_EOT_nsect+di]
  1150                                  	dec     cl      ; base sectors at 0
  1151                                  	cmp     cl,al
  1152                                  	jnc     .6      ; JNC = JNB = JAE
  1153                                  	mul     ah
  1154                                  ; AX is 1 or 2 * sectors
  1155                                  	sub     al,cl
  1156                                  ; AL is the maximum number of sectors we can transfer
  1157                                  	cmp     al,[offset_AX+bp]       ; compare to sector count
  1158                                  .6:     inc     cl      ; back to sectors from 1
  1159                                  	jnc     .8      ; JAE = JNB = JNC
  1160                                  .7:     stc
  1161                                  .8:     pop     ax      ;
  1162                                  	ret
  1163                                  %endif
  1164                                  
  1165                                  
  1166                                  
  1167                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1168                                  ;  Function 02h         Read Sectors
  1169                                  ;  Function 03h         Write Sectors
  1170                                  ;  Function 04h         Verify Sectors
  1171                                  ;
  1172                                  ;  Enter with:
  1173                                  ;       AH = 02h (read)
  1174                                  ;       AH = 03h (write)
  1175                                  ;       AH = 04h (verify)
  1176                                  ;       AL = number of sectors to transfer
  1177                                  ;       CH = cylinder number
  1178                                  ;       CL = sector number
  1179                                  ;       DH = head number
  1180                                  ;       DL = drive 0 or 1
  1181                                  ;       ES:BX = buffer to read into or write from
  1182                                  ;
  1183                                  ;  Return with:
  1184                                  ;       Carry clear if no error
  1185                                  ;       AH = 0
  1186                                  ;       AL = number of sectors transferred
  1187                                  ;
  1188                                  ;       Carry set on error
  1189                                  ;       AH = error code
  1190                                  ;
  1191                                  ;       All other registers are preserved.
  1192                                  ;
  1193                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1194                                  ;
  1195                                  ;  Stack variables
  1196                                  ;
  1197                                  rwv_return	equ	-2	; offset from BP
  1198                                  rwv_dma		equ	rwv_return - 2
  1199                                  rwv_xfer	equ	rwv_dma - 2
  1200                                  rwv_cmd		equ	rwv_xfer - 9
  1201                                  rwv_AL		equ	rwv_cmd - 1
  1202                                  rwv_stack	equ	- rwv_AL
  1203                                  
  1204                                  ;FDC_DMA_READ	equ (101b<<13)+(011b<<10)+(11b<<8)+(01b<<6)+(00b<<4)+0110b
  1205                                  FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1206                                  
  1207                                  ;FDC_DMA_WRITE	equ (011b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(00b<<4)+0110b
  1208                                  FDC_DMA_WRITE	equ (000b<<13)+(101b<<10)+(11b<<8)+(10b<<6)+(10b<<4)+0110b
  1209                                  
  1210                                  ;FDC_DMA_READ	equ (101b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1211                                  FDC_DMA_SCAN	equ (100b<<13)+(000b<<10)+(11b<<8)+(01b<<6)+(10b<<4)+0110b
  1212                                  
  1213                                  FDC_DMA_FORMAT	equ	FDC_DMA_WRITE
  1214                                  
  1215                                  
  1216                                  %if SOFT_DEBUG
  1217 000003CD 66A3                    	dw	FDC_DMA_READ
  1218 000003CF A617                    	dw	FDC_DMA_WRITE
  1219 000003D1 6683                    	dw	FDC_DMA_SCAN
  1220                                  %endif
  1221                                  
  1222                                  fn02:	; READ
  1223 000003D3 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1224 000003D5 BF66A3                  	mov	di,FDC_DMA_READ
  1225 000003D8 BB[9706]                	mov	bx,xfer_read_sector
  1226 000003DB EB12                    	jmp	rwv_common
  1227                                  
  1228                                  %define EXTRA 0
  1229                                  fn03:	; WRITE
  1230                                  %if EXTRA
  1231                                  	cmp	al,1
  1232                                  	jbe	.10
  1233                                  
  1234                                  	mov	bx,[offset_BX+bp]	; restore BX
  1235                                  	mov	[offset_AH+bp],al	; use return code as counter
  1236                                  
  1237                                  .1:	mov	ax,0301h		; write 1 sector
  1238                                  	int	13h
  1239                                  	jc	.5
  1240                                  
  1241                                  	inc	cl			; increment sector number
  1242                                  	add	bx,200h			; increment transfer address
  1243                                  	dec	byte [offset_AH+bp]
  1244                                  	jnz	.1
  1245                                  
  1246                                  	Okay				; all went Okay
  1247                                  	ret
  1248                                  
  1249                                  ; process error return
  1250                                  ;  AH = error code
  1251                                  .5:	mov	al,[offset_AL+bp]	; sectors requested
  1252                                  	sub	al,[offset_AH+bp]	; sectors remaining
  1253                                  	mov	[offset_AL+bp],al	; set sectors transferred
  1254                                  	Error
  1255                                  	ret
  1256                                  
  1257                                  .10:
  1258                                  %endif
  1259 000003DD B4C5                    	mov	ah,(CMD_WRITE_DATA | CMD_MT | CMD_MF)
  1260 000003DF BFA617                  	mov	di,FDC_DMA_WRITE
  1261 000003E2 BB[1207]                	mov	bx,xfer_write_sector
  1262 000003E5 EB08                    	jmp	rwv_common
  1263                                  
  1264                                  fn04:	; VERIFY
  1265 000003E7 B4E6                    	mov	ah,(CMD_READ_DATA | CMD_MT | CMD_MF | CMD_SK)
  1266 000003E9 BF6683                  	mov	di,FDC_DMA_SCAN
  1267 000003EC BB[4707]                	mov	bx,xfer_verify_sector
  1268                                  ;;;	jmp	rwv_common
  1269                                  
  1270                                  ;  Common code to READ, WRITE, and VERIFY
  1271                                  rwv_common:
  1272 000003EF 57                      	push	di			; dma control register
  1273 000003F0 53                      	push	bx			; transfer function
  1274 000003F1 83EC08                  	sub	sp,rwv_stack - 8	; 4 words in stack by pushes or Call
  1275 000003F4 50                      	push	ax			; including this push
  1276                                  
  1277 000003F5 E89501                  	call	check_DL		; sets DI
  1278 000003F8 B401                    	mov	ah,ERR_invalid_command
  1279 000003FA 7267                    	jc	.exit
  1280 000003FC E8A501                  	call	get_disk_type
  1281 000003FF E8B101                  	call	get_media		; get media pointer to CS:BX
  1282 00000402 E8BA01                  	call	set_media_pointer	; set up Int 1Eh
  1283 00000405 E82A02                  	call	motor_on		; use DI to start motor
  1284                                  
  1285 00000408 E8C003                  	call	Seek			; use CH to seek to track
  1286                                  					; recalibrate is possible
  1287 0000040B 7256                    	jc	.exit			; AH is error code
  1288                                  
  1289 0000040D E87002                  	call	make_head_unit		; AL is next byte
  1290                                  
  1291 00000410 571E06                  	pushm	es,ds,di
  1292 00000413 8D7EF2                  	lea	di,[rwv_cmd+1+bp]		; SS override not needed
  1293 00000416 8D7703                  	lea	si,[DTAB_N_param+bx]
  1294 00000419 160E                    	pushm	cs,ss
  1295 0000041B 1F900790                	popm	ds,es
  1296 0000041F AA                      	stosb				; store head unit in cmd stream
  1297 00000420 88E8                    	mov	al,ch			; cylinder
  1298 00000422 AA                      	stosb
  1299 00000423 88F0                    	mov	al,dh			; head
  1300 00000425 AA                      	stosb
  1301 00000426 88C8                    	mov	al,cl			; sector (R)
  1302 00000428 AA                      	stosb
  1303 00000429 AC                      	lodsb				; get N
  1304 0000042A 88C1                    	mov	cl,al
  1305 0000042C AA                      	stosb				; store N
  1306 0000042D A4                      	movsb				; EOT
  1307 0000042E A4                      	movsb				; GPL
  1308 0000042F A4                      	movsb				; DTL = FF
  1309 00000430 8D76F1                  	lea	si,[rwv_cmd+bp]		; get command start
  1310 00000433 07901F905F              	popm	es,ds,di
  1311                                  
  1312 00000438 B88000                  	mov	ax,128			; minimum sector size
  1313 0000043B F666F0                  	mul	byte [rwv_AL+bp]	; times number of sectors to transfer
  1314 0000043E D3E0                    	shl	ax,cl			; shift by N_param
  1315 00000440 89C1                    	mov	cx,ax			; CX is byte count of transfer
  1316                                  
  1317 00000442 53                      	pushm	bx			; save DTAB pointer
  1318                                  
  1319 00000443 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1320 00000446 8CC3                    	mov	bx,es			; segment to AX
  1321 00000448 89DA                    	mov	dx,bx			; and to DX
  1322 0000044A C1EB0C                  	shr	bx,12			; high 4 bits of address
  1323 0000044D C1E204                  	shl	dx,4			; high part of offset from segment
  1324 00000450 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1325 00000452 83D300                  	adc	bx,0			; and carry into the high bits
  1326                                  
  1327 00000455 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1328                                  
  1329                                  .marker:
  1330                                  ;	BX:AX	transfer 20-bit address in memory
  1331                                  ;	CX	transfer byte count
  1332                                  ;	DX:SI	pointer to 9-byte FDC command
  1333                                  ;
  1334 00000457 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1335                                  
  1336 0000045C FF56FA                  	call	near [rwv_xfer+bp]		;call specific transfer function
  1337                                  
  1338 0000045F 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1339                                  ;;;	jc	.exit			; AH is set to error code
  1340                                  
  1341 00000460 E8CC03                  	call	Check_RW_Status		; get final return code
  1342                                  
  1343                                  .exit:
  1344 00000463 8D66FE                  	lea	sp,[rwv_return+bp]
  1345 00000466 C3                      	ret
  1346                                  
  1347                                  %if SOFT_DEBUG
  1348                                  end_rwv		equ	$
  1349                                  %endif
  1350                                  
  1351                                  
  1352                                  
  1353                                  ; Format stack layout
  1354                                  fmt_return	equ	-2			; return from fn05 call
  1355                                  fmt_dma		equ	fmt_return - 2
  1356                                  fmt_cmd		equ	fmt_dma - 6
  1357                                  fmt_stack	equ	-fmt_cmd		; stack size
  1358                                  
  1359                                  %if fmt_dma != rwv_dma
  1360                                  %error "fmt_dma != rwv_dma"
  1361                                  %endif
  1362                                  
  1363                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1364                                  ;  Function 05h         Format a Track
  1365                                  ;
  1366                                  ;  Precede with call to Function 18h (or 17h) to set the disk type
  1367                                  ;
  1368                                  ;  Enter with:
  1369                                  ;       AH = 05h
  1370                                  ;       CH = cylinder number
  1371                                  ;       DH = head number
  1372                                  ;       DL = drive 0 or 1
  1373                                  ;       ES:BX = segment/offset of address field list (C/H/R/N)
  1374                                  ;
  1375                                  ;  Return with:
  1376                                  ;       Carry clear if no error
  1377                                  ;       AH = 0
  1378                                  ;
  1379                                  ;       Carry set on error
  1380                                  ;       AH = error code
  1381                                  ;
  1382                                  ;       All other registers are preserved.
  1383                                  ;
  1384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1385                                  fn05:
  1386 00000467 83EC0A                  	sub	sp,fmt_stack		; allocate stack space
  1387 0000046A C746FCA617              	mov	word [fmt_dma+bp],FDC_DMA_FORMAT
  1388                                  
  1389 0000046F E81B01                  	call	check_DL		; sets DI
  1390 00000472 B401                    	mov	ah,ERR_invalid_command
  1391 00000474 7272                    	jc	.exit
  1392                                  
  1393 00000476 06                      	pushm	es		; save ES
  1394 00000477 6A00                    	push	0
  1395 00000479 0790                    	popm	es
  1396 0000047B 8CCB                    	mov	bx,cs		; get CS segment
  1397 0000047D 263B1E7A00                es	cmp	bx,[1Eh*4+2]	; check segment is CS
  1398 00000482 7564                    	jne	.exit		; (will restore stack)
  1399                                  
  1400 00000484 268B1E7800                es	mov	bx,[1Eh*4]	; get CS:BX as disk param table pointer
  1401 00000489 0790                    	popm	es     		; restore Stack
  1402                                  
  1403 0000048B E8A401                  	call	motor_on		; use DI to start motor
  1404                                  
  1405 0000048E E83A03                  	call	Seek			; use CH to seek to track
  1406                                  					; recalibrate is possible
  1407 00000491 7255                    	jc	.exit			; AH is error code
  1408                                  
  1409 00000493 E8EA01                  	call	make_head_unit		; AL is next byte
  1410 00000496 88C4                    	mov	ah,al			; save head/unit in AH
  1411                                  
  1412 00000498 571E06                  	pushm	es,ds,di
  1413                                  
  1414 0000049B 160E                    	pushm	cs,ss
  1415 0000049D 1F900790                	popm	ds,es
  1416 000004A1 8D7EF6                  	lea	di,[bp+fmt_cmd]
  1417 000004A4 8D7703                  	lea	si,[bx+DTAB_N_param]
  1418                                  
  1419 000004A7 B00D                    	mov	al,CMD_FORMAT_A_TRACK
  1420 000004A9 803C00                  	cmp	byte [si],0		; is N==0
  1421 000004AC 7402                    	je	.2
  1422 000004AE 0C40                    	or	al,CMD_MF		; MFM recording
  1423                                  .2:
  1424 000004B0 AB                      	stosw				; AH=head/unit, AL=format cmd
  1425 000004B1 A4                      	movsb				; set N
  1426 000004B2 AC                      	lodsb				; get SC
  1427 000004B3 88C1                    	mov	cl,al			; save SC in AL
  1428 000004B5 AA                      	stosb				; set SC
  1429 000004B6 83C602                  	add	si,2			; advance to GPL3
  1430 000004B9 A5                      	movsw				; set GPL3 and Fill
  1431                                  
  1432 000004BA 8D76F6                  	lea	si,[bp+fmt_cmd]
  1433 000004BD 07901F905F              	popm	es,ds,di    		; restore regs
  1434                                  
  1435 000004C2 30ED                    	xor	ch,ch			; CX = sector count
  1436 000004C4 C1E102                  	shl	cx,2			; CX = byte count of param table
  1437                                  
  1438 000004C7 53                      	pushm	bx			; save DTAB pointer
  1439                                  
  1440 000004C8 8B4608                  	mov	ax,[offset_BX+bp]	; get Xfer address offset
  1441 000004CB 8CC3                    	mov	bx,es			; segment to AX
  1442 000004CD 89DA                    	mov	dx,bx			; and to DX
  1443 000004CF C1EB0C                  	shr	bx,12			; high 4 bits of address
  1444 000004D2 C1E204                  	shl	dx,4			; high part of offset from segment
  1445 000004D5 01D0                    	add	ax,dx			; form low 16 bits of 20-bit address
  1446 000004D7 83D300                  	adc	bx,0			; and carry into the high bits
  1447                                  
  1448 000004DA 8CD2                    	mov	dx,ss			; DX:SI points at command start
  1449                                  
  1450                                  ;.marker:
  1451                                  ;	BX:AX	transfer 20-bit address in memory
  1452                                  ;	CX	transfer byte count
  1453                                  ;	DX:SI	pointer to 9-byte FDC command
  1454                                  ;
  1455 000004DC 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts received
  1456                                  
  1457 000004E1 E82E02                  	call	xfer_format_track	; format the track
  1458                                  
  1459 000004E4 5B                      	popm	bx				; restor DTAB pointer (CS:BX)
  1460                                  ;;;	jc	.exit			; AH is set to error code
  1461                                  
  1462 000004E5 E84703                  	call	Check_RW_Status		; get final return code
  1463                                  
  1464                                  
  1465                                  .exit:
  1466 000004E8 8D66FE                  	lea	sp,[rwv_return+bp]	; restore stack location
  1467 000004EB C3                      	ret
  1468                                  
  1469                                  
  1470                                  
  1471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1472                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1473                                  	global  dma0_interrupt
  1474                                  dma0_interrupt:
  1475 000004EC 1E5250                  	pushm   ax,dx,ds
  1476                                  
  1477 000004EF 6A40                    	push    bios_data_seg
  1478 000004F1 1F90                    	popm    ds
  1479                                  
  1480                                  %if SOFT_DEBUG
  1481 000004F3 800E3E0002              	or	byte [fdc_drv_calib],02h		;POST dma interrupt
  1482                                  %endif
  1483                                  
  1484                                  %if 0
  1485                                  	mov     dx,FDC_TC               ; Terminal Count
  1486                                  	in      al,dx                   ; pulse the line
  1487                                  %endif
  1488                                  
  1489                                  %if 0
  1490                                  	mov     dx,DMA0+DMACW           ; DMA0 control word
  1491                                  	in      ax,dx
  1492                                  	mov     [dma0_cw],ax            ; post the resulting CW
  1493                                  %endif
  1494                                  
  1495                                  ; signal EOI (End of Interrupt)
  1496 000004F8 BA22FF                  	mov     dx,PIC_EOI              ; EOI register
  1497 000004FB B80080                  	mov     ax,EOI_NSPEC            ; non-specific
  1498 000004FE EF                      	out     dx,ax                   ; signal it
  1499                                  
  1500 000004FF 585A1F90                	popm    ax,dx,ds
  1501 00000503 CF                      	iret
  1502                                  
  1503                                  
  1504                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1505                                  ;  Function 15h         Get Disk Type
  1506                                  ;
  1507                                  ;  Enter with:
  1508                                  ;       AH = 15h
  1509                                  ;       DL = drive 0 or 1
  1510                                  ;
  1511                                  ;  Return with:
  1512                                  ;       Carry clear if no error
  1513                                  ;       AH = drive type code
  1514                                  ;               0 = no drive present
  1515                                  ;               1 = floppy without change line support
  1516                                  ;               2 = floppy with change line support
  1517                                  ;               3 = fixed disk
  1518                                  ;
  1519                                  ;       Carry set on error
  1520                                  ;       AH = error code
  1521                                  ;
  1522                                  ;       All other registers are preserved.
  1523                                  ;
  1524                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1525                                  fn15:
  1526 00000504 30E4                    	xor	ah,ah			; No drive present
  1527 00000506 E88400                  	call	check_DL
  1528 00000509 7309                    	jnc	.ok
  1529 0000050B 83FFFF                  	cmp	di,-1
  1530 0000050E 7503E96DFB              	je	undefined		; DL is really bad
  1531 00000513 C3                      	ret				; AH=0, no drive present
  1532                                  					; carry will be cleared
  1533                                  .ok:
  1534 00000514 FEC4                    	inc	ah			; drive ok, no change line support
  1535 00000516 F8                      	clc
  1536 00000517 E935FB                  	jmp	exit_pops		;
  1537                                  
  1538                                  
  1539                                  
  1540                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1541                                  ;  Function 16h         Get Disk Change Status
  1542                                  ;
  1543                                  ;  Enter with:
  1544                                  ;       AH = 16h
  1545                                  ;       DL = drive 0 or 1
  1546                                  ;
  1547                                  ;  Return with:
  1548                                  ;       Carry clear
  1549                                  ;       AH = 0  disk not changed
  1550                                  ;
  1551                                  ;       Carry set
  1552                                  ;       AH = 6  disk has been changed
  1553                                  ;            0  error
  1554                                  ;
  1555                                  ;       All other registers are preserved.
  1556                                  ;
  1557                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1558                                  fn16:
  1559 0000051A E87000                  	call	check_DL
  1560 0000051D 7303E95EFB              	jc	undefined
  1561                                  
  1562 00000522 89F8                    	mov	ax,di			; AL = 0, 1	AH = 0
  1563                                  ; AH is now 0
  1564 00000524 FEC0                    	inc	al			; AL = 1, 2
  1565 00000526 C0C004                  	rol	al,4			; AL = MOEN1 or MOEN2
  1566 00000529 84063F00                	test	[fdc_motor_LDOR],al	; test if motor running
  1567 0000052D 7502                    	jnz     .on
  1568                                  
  1569 0000052F B406                    	mov     ah,ERR_disk_removed	; signal disk changed
  1570                                  .on:
  1571 00000531 C3                      	ret			; AH=6, Carry will be set
  1572                                  
  1573                                  
  1574                                  
  1575                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1576                                  ;  Function 17h		Set Disk Type for Format	(PC-AT)
  1577                                  ;
  1578                                  ;  Enter with:
  1579                                  ;	AH = 17h
  1580                                  ;	AL =	00h     not used
  1581                                  ;		01h     160, 180, 320, or 360Kb diskette in 360kb drive
  1582                                  ;		02h     360Kb diskette in 1.2Mb drive
  1583                                  ;		03h     1.2Mb diskette in 1.2Mb drive
  1584                                  ;		04h     720Kb diskette in 720Kb drive
  1585                                  ;	DL = drive number
  1586                                  ;
  1587                                  ;  Return with:
  1588                                  ;	AH = 0		success
  1589                                  ;	Carry clear
  1590                                  ;
  1591                                  ;	Carry set	error
  1592                                  ;	AH = error code
  1593                                  ;
  1594                                  ;  note 1) This function is probably enhanced for the PS/2 series to detect
  1595                                  ;	   1.44 in 1.44 and 720k in 1.44.
  1596                                  ;	2) This function is not supported for floppy disks on the PC or XT.
  1597                                  ;	3) If the change line is active for the specified drive, it is reset.
  1598                                  ;	4) The BIOS sets the data rate for the specified drive and media type.
  1599                                  ;	   The rate is 250k/sec for double-density media and 500k/sec for high
  1600                                  ;	   density media. The proper hardware is required.
  1601                                  ;	5) This function is used by DOS <= 3.1
  1602                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1603                                  ;fn17:
  1604                                  ;;;	ret
  1605                                  
  1606                                  
  1607                                  
  1608                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1609                                  ;  Function 18h		Set Media Type For Format  (diskette)   (AT, XT2, XT/286, PS/2)
  1610                                  ;
  1611                                  ;  Enter with:
  1612                                  ;	AH = 18h
  1613                                  ;	CH = max. cylinder number (80 or 40  minus  1)
  1614                                  ;	CL = number of sectors (9, 15, 18)
  1615                                  ;	DL = drive number
  1616                                  ;
  1617                                  ;  Return with:
  1618                                  ;	Carry clear -- no errors
  1619                                  ;	AH =	00h      if requested combination supported
  1620                                  ;	ES:DI	pointer to 13-byte parameter table
  1621                                  ;
  1622                                  ;	Carry set -- error
  1623                                  ;	AH =	01h      if function not available
  1624                                  ;		0Ch      if not suppported or drive type unknown
  1625                                  ;		80h      if there is no media in the drive
  1626                                  ;
  1627                                  ;  note 1) A floppy disk must be present in the drive.
  1628                                  ;	2) This function should be called prior to formatting a disk with Int 13h
  1629                                  ;	   Fn 05h so the BIOS can set the correct data rate for the media.
  1630                                  ;	3) If the change line is active for the specified drive, it is reset.
  1631                                  ;	4) This function is used by DOS >= 3.2
  1632                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1633                                  fn18:
  1634 00000532 E85800                  	call	check_DL		; check validity of drive no.
  1635 00000535 7303E946FB              	jc	undefined
  1636                                  
  1637 0000053A E86700                  	call	get_disk_type		; get disk type to AL
  1638 0000053D 3C0B                    	cmp	al,L_table
  1639 0000053F 7327                    	jnb	.alt
  1640 00000541 88C3                    	mov	bl,al
  1641 00000543 30FF                    	xor	bh,bh
  1642 00000545 D1E3                    	shl	bx,1
  1643 00000547 2E8B9F[B500]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1644 0000054C 85DB                    	test	bx,bx
  1645 0000054E 743A                    	jz	.errC
  1646 00000550 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1647 00000554 7512                      	jne	.alt			; try alternate
  1648 00000556 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1649 0000055A 750C                      	jne	.alt
  1650                                  .found:
  1651 0000055C E86000                         	call	set_media_pointer
  1652 0000055F 895E00                  	mov	[offset_DI+bp],bx
  1653 00000562 8C4E12                  	mov	[offset_ES+bp],cs	; return in ES:DI
  1654 00000565 30E4                    	xor	ah,ah
  1655 00000567 C3                      	ret
  1656                                  
  1657                                  .alt:
  1658 00000568 E84000                  	call	get_disk_alt_type	; get disk type to AL
  1659 0000056B 3C0B                    	cmp	al,L_table
  1660 0000056D 731B                    	jnb	.errC
  1661 0000056F 88C3                    	mov	bl,al
  1662 00000571 30FF                    	xor	bh,bh
  1663 00000573 D1E3                    	shl	bx,1
  1664 00000575 2E8B9F[B500]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1665 0000057A 85DB                    	test	bx,bx
  1666 0000057C 740C                    	jz	.errC
  1667 0000057E 2E384F04                  cs	cmp	[DTAB_EOT_nsect+bx],cl	; check number of sectors
  1668 00000582 7506                      	jne	.errC			; no match?
  1669 00000584 2E386F0B                  cs	cmp	[DTAB_max_cylinder+bx],ch  ; check number of cylinders
  1670 00000588 74D2                    	je	.found
  1671                                  
  1672 0000058A B40C                    .errC:	mov	ah,ERR_media_type_not_found
  1673 0000058C C3                      	ret
  1674                                  
  1675                                  
  1676                                  
  1677                                  
  1678                                  
  1679                                  check   cpu_xtal-0FFh
  1680                                  
  1681                                  
  1682                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1683                                  ;  check_DL -- check for valid disk #
  1684                                  ;
  1685                                  ;  Return:
  1686                                  ;	DI = 0 or 1 if DL is valid floppy
  1687                                  ;	Carry clear
  1688                                  ;
  1689                                  ;	DI not valid if DL is invalid
  1690                                  ;	Carry set
  1691                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1692                                  check_DL:
  1693 0000058D BFFFFF                  	mov	di,-1				; invalid DI
  1694 00000590 80FA02                  	cmp	dl,FLOPPY_MAX
  1695 00000593 730D                    	jnb	.err
  1696 00000595 89D7                    	mov	di,dx
  1697 00000597 83E701                  	and	di,FLOPPY_MAX-1			; clear the carry
  1698 0000059A F685F8000F              	test	byte [fdc_type+di],0Fh		; drive present?
  1699 0000059F 7401                    	jz	.err
  1700 000005A1 C3                      	ret					; carry is clear
  1701                                  
  1702 000005A2 F9                      .err:	stc
  1703 000005A3 C3                      	ret
  1704                                  
  1705                                  
  1706                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1707                                  ;  get_disk_type
  1708                                  ;
  1709                                  ;  Enter with:
  1710                                  ;	DI = drive no.
  1711                                  ;
  1712                                  ;  Return with:
  1713                                  ;	AL = drive type (0..4)
  1714                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1715                                  get_disk_type:
  1716 000005A4 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1717 000005A8 240F                    	and	al,0Fh			; mask low nibble
  1718 000005AA C3                      	ret
  1719                                  
  1720                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1721                                  ;  get_disk_alt_type
  1722                                  ;
  1723                                  ;  Enter with:
  1724                                  ;	DI = drive no.
  1725                                  ;
  1726                                  ;  Return with:
  1727                                  ;	AL = drive type (0..4)
  1728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1729                                  get_disk_alt_type:
  1730 000005AB 8A85F800                	mov	al,[fdc_type+di]	; get type byte
  1731 000005AF C0E804                  	shr	al,4
  1732 000005B2 C3                      	ret
  1733                                  
  1734                                  
  1735                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1736                                  ;  get_media
  1737                                  ;
  1738                                  ;  Call with:
  1739                                  ;	AL = disk type
  1740                                  ;
  1741                                  ;  Return with:
  1742                                  ;	CS:BX		pointer to 13-byte disk media table
  1743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1744                                  get_media:
  1745 000005B3 88C3                    	mov	bl,al
  1746 000005B5 30FF                    	xor	bh,bh
  1747 000005B7 D1E3                    	shl	bx,1
  1748 000005B9 2E8B9F[B500]              cs	mov	bx,[D_table+bx]		; get offset of DTAB entry
  1749 000005BE C3                        	ret
  1750                                  
  1751                                  
  1752                                  
  1753                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1754                                  ;  set_media_pointer
  1755                                  ;
  1756                                  ;  Call with:
  1757                                  ;	CS:BX	pointer to 13-byte disk media table
  1758                                  ;	DS	BIOS data area pointer
  1759                                  ;
  1760                                  ;  Return with:
  1761                                  ;	CS:BX		pointer to 13-byte disk media table
  1762                                  ;	Int 1Eh 	floppy media pointer set
  1763                                  ;
  1764                                  ;	Carry Set = new media pointer (needed Specify command)
  1765                                  ;	Carry Clear = same media pointer (Specify not needed)
  1766                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1767                                  set_media_pointer:
  1768 000005BF 0651                    	pushm	cx,es			; save for later
  1769 000005C1 6A00                    	push	0			; address interrupt vectors
  1770 000005C3 07                      	pop	es			; **
  1771 000005C4 8CC9                    	mov	cx,cs
  1772 000005C6 26391E7800                es	cmp	word [1Eh*4],bx
  1773 000005CB 7508                    	jne	.diff
  1774 000005CD 26390E7A00                es	cmp	word [1Eh*4+2],cx	; segment
  1775 000005D2 F8                      	clc
  1776 000005D3 7411                    	jz	.same
  1777                                  .diff:
  1778 000005D5 26891E7800                es	mov	word [1Eh*4],bx		; offset
  1779 000005DA 26890E7A00                es	mov	word [1Eh*4+2],cx	; segment
  1780 000005DF 8EC1                    	mov	es,cx
  1781 000005E1 90                      	cnop
  1782 000005E2 E80500                  	call	Specify			; ES:BX is table pointer
  1783 000005E5 F9                      	stc
  1784                                  .same:
  1785 000005E6 590790                  	popm	cx,es			; restore DS
  1786 000005E9 C3                      	ret
  1787                                  
  1788                                  
  1789                                  
  1790                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1791                                  ;  Specify		issue specify command to FDC
  1792                                  ;
  1793                                  ;  Call with:
  1794                                  ;	ES:BX		pointer to 13-byte disk table
  1795                                  ;	DS		BIOS data area pointer
  1796                                  ;
  1797                                  ;  Return with:
  1798                                  ;	Nothing
  1799                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1800                                  Specify:
  1801 000005EA 56525350                	pushm	ax,bx,dx,si
  1802 000005EE 83EC04                  	sub	sp,4			; allocate 4 bytes for command
  1803 000005F1 89E6                    	mov	si,sp
  1804                                  
  1805 000005F3 268A470C                  es	mov	al,[DTAB_control+bx]	; clock bits
  1806 000005F7 C0C002                    	rol	al,2
  1807 000005FA BA8504                  	mov	dx,FDC_LDCR		; Control Register
  1808 000005FD EE                      	out	dx,al
  1809                                  
  1810 000005FE B20C                    	mov	dl,12			; 12 usec delay  = T time
  1811 00000600 08C0                    	or	al,al			; test for hi (00) or lo (80) data rate
  1812 00000602 7502                    	jnz	.3
  1813 00000604 D0EA                    	shr	dl,1			; crystal has factor of 2 already
  1814                                  .3:
  1815 00000606 A0FF00                  	mov	al,[cpu_xtal]		; 2x clock frequency
  1816 00000609 F6E2                    	mul	dl			; AX = 2xClock * T or 2xclock * T/2 (80 or 00)
  1817 0000060B 83E82C                  	sub	ax,44			; overhead CPU clocks
  1818 0000060E B214                    	mov	dl,20			; loop clock count
  1819 00000610 F6F2                    	div	dl
  1820 00000612 FEC0                    	inc	al			; for good measure
  1821 00000614 A2AD00                  	mov	[wait12_count],al	; save count
  1822                                  
  1823 00000617 36C60403                  ss	mov	byte [si],CMD_SPECIFY
  1824 0000061B 268B07                    es	mov	ax,[DTAB_specify+bx]	; get two specify bytes
  1825 0000061E 36894401                  ss	mov	word [si+1],ax
  1826 00000622 8CD2                      	mov	dx,ss
  1827 00000624 B90300                  	mov	cx,3			; length of command = 3
  1828 00000627 E8B0FB                  	call	output_cmd_to_fdc
  1829 0000062A 83C404                  	add	sp,4
  1830 0000062D 585B5A5E                	popm	ax,bx,dx,si
  1831 00000631 C3                      	ret
  1832                                  
  1833                                  
  1834                                  
  1835                                  
  1836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1837                                  ;  motor_on			Start the drive motor & wait
  1838                                  ;
  1839                                  ;  Call with:
  1840                                  ;	DI = drive to start (0, 1)
  1841                                  ;	CS:BX = drive parameter table pointer
  1842                                  ;
  1843                                  ;  Return with:
  1844                                  ;	motor is running and startup delay has been taken
  1845                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1846                                  	global	motor_on
  1847                                  motor_on:
  1848 00000632 525150                  	pushm	ax,cx,dx
  1849 00000635 89F8                    	mov	ax,di			; drive # to AL
  1850 00000637 0401                    	add	al,MOEN1>>4		; form MOENx >> 4
  1851 00000639 C0E004                  	shl	al,4			; form MOENx bitmask
  1852 0000063C 88C4                    	mov	ah,al			; MOENx -> AH
  1853 0000063E 01F8                    	add	ax,di			; MOENx + DSELx -> AL
  1854                                  
  1855 00000640 B1B6                    	mov	cl,182				;10 seconds
  1856 00000642 880E4000                  	mov	byte [fdc_motor_ticks],cl	; set long timer = 10 seconds
  1857                                  
  1858 00000646 84263F00                	test	byte [fdc_motor_LDOR],ah	; motor already on?
  1859 0000064A 88C5                    	mov	ch,al
  1860 0000064C 750F                    	jnz	.its_on
  1861                                  
  1862                                  ; motor is not running
  1863 0000064E 2E8B470A                  cs	mov	ax,[DTAB_startup+bx]	; get startup delay in 1/8 seconds
  1864 00000652 98                        	cbw
  1865 00000653 6BC07D                    	imul	ax,125			; * 125 ms
  1866 00000656 B236                    	mov	dl,54
  1867 00000658 F6F2                    	div	dl			; divided by 54ms/tick
  1868 0000065A 40                      	inc	ax			; one more tick for good measure
  1869 0000065B 28C1                    	sub	cl,al			; CL is tick to wait for
  1870                                  
  1871                                  ; if motor was already running, then CL has not been changed
  1872                                  ; Do the select
  1873                                  .its_on:
  1874 0000065D 322E3F00                	xor	ch,[fdc_motor_LDOR]	; set selected bits
  1875 00000661 80E531                  	and	ch,(MOEN_MASK | DSEL_MASK)
  1876 00000664 302E3F00                	xor	[fdc_motor_LDOR],ch
  1877 00000668 E832FC                  	call	out_LDOR_mem		; Motor Starts here, or continues
  1878 0000066B EB01                    	jmp	.wait
  1879                                  
  1880 0000066D F4                      	hlt
  1881 0000066E 380E4000                .wait:	cmp	[fdc_motor_ticks],cl	; has tick counter expired?
  1882 00000672 77F9                    	ja	.wait-1
  1883                                  
  1884                                  ; reduce timer to turn-off delay time
  1885 00000674 2E8A4F02                  cs	mov	cl,[DTAB_turnoff_ticks+bx]	; 2 seconds
  1886 00000678 880E4000                  	mov	[fdc_motor_ticks],cl
  1887                                  
  1888 0000067C 58595A                  	popm	ax,cx,dx
  1889 0000067F C3                      	ret
  1890                                  
  1891                                  
  1892                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1893                                  ;  make_head_unit
  1894                                  ;
  1895                                  ;  Enter with:
  1896                                  ;	DH = head number
  1897                                  ;	DI = unit number
  1898                                  ;
  1899                                  ;  Return with:
  1900                                  ;	AL = 0000 0huu
  1901                                  ;	Carry clear
  1902                                  ;
  1903                                  ;	Carry is set on error
  1904                                  ;
  1905                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  1906                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1907                                  make_head_unit:
  1908 00000680 88F0                    	mov	al,dh			; head number to AL
  1909 00000682 A8FE                    	test	al, ~1			; check for head 0 or 1
  1910 00000684 F9                      	stc				; set to signal error
  1911 00000685 7507                    	jnz	.err
  1912 00000687 2401                    	and	al,1			; defensive programming
  1913 00000689 C0E002                  	shl	al,2			; shift H to position
  1914 0000068C 09F8                    	or	ax,di			; clear the carry
  1915 0000068E C3                      .err:	ret
  1916                                  
  1917                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1918                                  ;  dma_outd		output a double word to a DMA double word register
  1919                                  ;
  1920                                  ;  Call with:
  1921                                  ;	BX:AX	double word to put out
  1922                                  ;	DX	low port address in the DMA controller
  1923                                  
  1924                                  ;  Exit with:
  1925                                  ;	DX incremented by 4
  1926                                  ;
  1927                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1928                                  dma_outd:
  1929 0000068F EF                      	out	dx,ax
  1930 00000690 42                      	inc	dx
  1931 00000691 42                      	inc	dx
  1932 00000692 93                      	xchg	ax,bx
  1933 00000693 EF                      	out	dx,ax
  1934 00000694 42                      	inc	dx
  1935 00000695 42                      	inc	dx
  1936 00000696 C3                      	ret
  1937                                  
  1938                                  
  1939                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1940                                  ;  xfer_read_sector
  1941                                  ;
  1942                                  ;  Call with:
  1943                                  ;	BX:AX	transfer address in memory
  1944                                  ;	CX	transfer byte count
  1945                                  ;	DX:SI	pointer to 9-byte FDC command
  1946                                  ;
  1947                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1948                                  xfer_read_sector:
  1949 00000697 52                      	push	dx
  1950                                  
  1951                                  ;;;	and	byte [fdc_drv_calib],00h	;POST no interrupts
  1952                                  						; operation is not complete
  1953                                  
  1954                                  ;   BX:AX is the transfer destination address
  1955 00000698 BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  1956 0000069B E8F1FF                  	call	dma_outd
  1957                                  
  1958 0000069E 89C8                    	mov	ax,cx			; total byte count
  1959 000006A0 EF                      	out	dx,ax			; set terminal count
  1960                                  
  1961 000006A1 31DB                    	xor	bx,bx
  1962 000006A3 B88604                  	mov	ax,FDC_DACK
  1963                                  ;   BX:AX is the transfer source port
  1964 000006A6 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  1965 000006A9 E8E3FF                  	call	dma_outd
  1966                                  
  1967 000006AC 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  1968 000006AF BACAFF                  	mov	dx,DMA0+DMACW
  1969 000006B2 EF                      	out	dx,ax			; starts the DMA
  1970                                  
  1971 000006B3 5A                      	pop	dx		; reset DX:SI command pointer
  1972                                  
  1973 000006B4 B90900                  	mov	cx,9			; 9-byte FDC command
  1974 000006B7 E820FB                  	call	output_cmd_to_fdc
  1975                                  
  1976                                  
  1977 000006BA BBC0FF                  	mov	bx,DMA0+DMASPL
  1978 000006BD B98704                  	mov	cx,FDC_DACK_TC
  1979                                  
  1980                                  xfer_common_wait:
  1981 000006C0 BAC8FF                  	mov	dx,DMA0+DMATC
  1982                                  .loop1:
  1983 000006C3 803E400000              	cmp	byte [fdc_motor_ticks],0
  1984                                  ;;;	cmp	byte [fdc_motor_ticks],20h	; 2Fh - 0Fh in DTABx entries
  1985 000006C8 7625                    	jbe	.timeout
  1986                                  
  1987 000006CA E887FA                  	call	wait12
  1988 000006CD ED                      	in	ax,dx
  1989 000006CE 83F80C                  	cmp	ax,THRESHHOLD
  1990 000006D1 73F0                    	jae	.loop1
  1991                                  
  1992 000006D3 E85802                  	call	@disable
  1993                                  .loop2:
  1994 000006D6 90                      	nop
  1995 000006D7 90                      	nop
  1996 000006D8 ED                      	in	ax,dx
  1997 000006D9 83F801                  	cmp	ax,1
  1998 000006DC 77F8                    	ja	.loop2
  1999                                  
  2000 000006DE 89DA                    	mov	dx,bx	; Source low
  2001 000006E0 89C8                    	mov	ax,cx	; FDC_DACK_TC
  2002 000006E2 EF                      	out	dx,ax
  2003                                  
  2004 000006E3 E85902                  	call	@enable
  2005                                  
  2006                                  ;;;	mov	ax,100b			; stop the channel
  2007                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  2008                                  ;;;	out	dx,ax
  2009                                  
  2010 000006E6 E81100                  	call	wait_operation_complete
  2011 000006E9 720E                    	jc	.99
  2012                                  
  2013                                  ;;;	mov	ax,100b			; stop the channel
  2014                                  ;;;	mov	dx,DMA0+DMACW			; DMA control word
  2015                                  ;;;	out	dx,ax
  2016                                  
  2017 000006EB 30E4                    	Okay
  2018 000006ED EB0A                    	jmp	.99
  2019                                  
  2020                                  .timeout:
  2021                                  ;;;	call	@enable
  2022                                  ; add the following:
  2023 000006EF B80400                  	mov	ax,100b			; stop the channel
  2024 000006F2 BACAFF                  	mov	dx,DMA0+DMACW			; DMA control word
  2025 000006F5 EF                      	out	dx,ax
  2026                                  
  2027 000006F6 B485                    	mov	ah,ERR_85
  2028 000006F8 F9                      	Error
  2029 000006F9 C3                      .99:	ret
  2030                                  
  2031                                  
  2032                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2033                                  ;  wait_operation_complete		; wait for disk operation
  2034                                  ;					; to post a "complete" status
  2035                                  ;  Call with:
  2036                                  ;	DS = BIOS data area segment
  2037                                  ;
  2038                                  ;  Return with:
  2039                                  ;	CY = 0		success
  2040                                  ;	CY = 1		timed out, AH=error code
  2041                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2042                                  wait_operation_complete:
  2043 000006FA F6063E0001              .1:	test	byte [fdc_drv_calib],01h	; FDC interrupt posted "complete"?
  2044 000006FF 7509                    	jnz	.okay
  2045 00000701 803E400000              	cmp	byte [fdc_motor_ticks],0
  2046 00000706 75F2                    	jne	.1
  2047 00000708 EB04                    	jmp	.timeout
  2048                                  
  2049 0000070A 30E4                    .okay:	Okay
  2050 0000070C EB03                    	jmp	.99
  2051                                  
  2052                                  .timeout:
  2053 0000070E B488                    	mov	ah,ERR_88		; mark timeout
  2054 00000710 F9                      	Error
  2055 00000711 C3                      .99:	ret
  2056                                  
  2057                                  
  2058                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2059                                  ;  xfer_write_sector
  2060                                  ;  xfer_format_track	(only command count is different)
  2061                                  ;
  2062                                  ;  Call with:
  2063                                  ;	BX:AX	transfer address in memory
  2064                                  ;	CX	transfer byte count
  2065                                  ;	DX:SI	pointer to 9-byte FDC command
  2066                                  ;
  2067                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2068                                  xfer_format_track:
  2069                                  xfer_write_sector:
  2070 00000712 52                      	push	dx
  2071                                  
  2072                                  ;   BX:AX is the transfer source address
  2073 00000713 BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source address
  2074 00000716 E876FF                  	call	dma_outd
  2075                                  
  2076 00000719 31DB                    	xor	bx,bx
  2077 0000071B B88604                  	mov	ax,FDC_DACK
  2078                                  
  2079                                  ;   BX:AX is the transfer destination port
  2080 0000071E BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination port
  2081 00000721 E86BFF                  	call	dma_outd
  2082                                  
  2083 00000724 89C8                    	mov	ax,cx			; total byte count
  2084 00000726 EF                      	out	dx,ax			; set terminal count
  2085                                  
  2086 00000727 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2087 0000072A BACAFF                  	mov	dx,DMA0+DMACW
  2088 0000072D EF                      	out	dx,ax			; starts the DMA
  2089                                  
  2090 0000072E 5A                      	pop	dx		; reset DX:SI command pointer
  2091                                  
  2092 0000072F B90900                  	mov	cx,9			; 9-byte FDC command
  2093 00000732 36F60408                  ss	test	byte [si], 01000b	; test for FORMAT command
  2094 00000736 7403                      	jz	.4
  2095 00000738 B90600                  	mov	cx,6			; it is FORMAT
  2096                                  .4:
  2097 0000073B E89CFA                  	call	output_cmd_to_fdc
  2098                                  
  2099                                  
  2100 0000073E BBC4FF                  	mov	bx,DMA0+DMADPL		; Destination to be updated
  2101 00000741 B98704                  	mov	cx,FDC_DACK_TC
  2102                                  
  2103 00000744 E979FF                  	jmp	xfer_common_wait
  2104                                  
  2105                                  
  2106                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2107                                  ;  xfer_verify_sector
  2108                                  ;
  2109                                  ;  Call with:
  2110                                  ;	BX:AX	transfer address in memory
  2111                                  ;	CX	transfer byte count
  2112                                  ;	DX:SI	pointer to 9-byte FDC command
  2113                                  ;
  2114                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2115                                  xfer_verify_sector:
  2116 00000747 52                      	push	dx
  2117                                  
  2118 00000748 31DB                    	xor	bx,bx			; BX:AX is transfer address
  2119 0000074A B84204                  	mov	ax, (bios_data_seg<<4)+fdc_ctrl_status
  2120                                  
  2121                                  ;   BX:AX is the transfer destination address
  2122 0000074D BAC4FF                  	mov	dx,DMA0+DMADPL		; set low destination
  2123 00000750 E83CFF                  	call	dma_outd
  2124                                  
  2125 00000753 89C8                    	mov	ax,cx			; total byte count
  2126 00000755 EF                      	out	dx,ax			; set terminal count
  2127                                  
  2128 00000756 31DB                    	xor	bx,bx
  2129 00000758 B88604                  	mov	ax,FDC_DACK
  2130                                  ;   BX:AX is the transfer source port
  2131 0000075B BAC0FF                  	mov	dx,DMA0+DMASPL		; set low source pointer
  2132 0000075E E82EFF                  	call	dma_outd
  2133                                  
  2134 00000761 8B46FC                  	mov	ax,[rwv_dma+bp]		; get Control register
  2135 00000764 BACAFF                  	mov	dx,DMA0+DMACW
  2136 00000767 EF                      	out	dx,ax			; starts the DMA
  2137                                  
  2138 00000768 5A                      	pop	dx		; reset DX:SI command pointer
  2139                                  
  2140 00000769 B90900                  	mov	cx,9			; 9-byte FDC command
  2141 0000076C E86BFA                  	call	output_cmd_to_fdc
  2142                                  
  2143                                  
  2144 0000076F BBC0FF                  	mov	bx,DMA0+DMASPL
  2145 00000772 B98704                  	mov	cx,FDC_DACK_TC
  2146                                  
  2147 00000775 E948FF                  	jmp	xfer_common_wait
  2148                                  
  2149                                  
  2150                                  
  2151                                  
  2152                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2153                                  ;  recalibrate
  2154                                  ;
  2155                                  ;  Enter with:
  2156                                  ;	DI = drive number
  2157                                  ;	CS:BX = parameter area pointer
  2158                                  ;	DS = BIOS data area pointer
  2159                                  ;
  2160                                  ;  Return with:
  2161                                  ;	Carry = 0 -- okay
  2162                                  ;
  2163                                  ;	Carry = 1 -- error
  2164                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2165                                  recalibrate:
  2166 00000778 565251                  	pushm   cx,dx,si
  2167                                  
  2168                                  ;;;	call    motor_on
  2169                                  
  2170 0000077B 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2171                                  
  2172 00000780 B001                    	mov	al,ST0_US	; mask to 2 drives
  2173 00000782 21F8                    	and	ax,di		; unit number to AL
  2174 00000784 86C4                    	xchg    al,ah		; AH is second byte of command
  2175 00000786 B007                    	mov     al,CMD_RECALIBRATE
  2176 00000788 50                      	push    ax		; push 2 byte command
  2177 00000789 89E6                    	mov     si,sp           ; form command pointer
  2178 0000078B 8CD2                    	mov     dx,ss           ; DX:SI points at command
  2179 0000078D B90200                  	mov     cx,2
  2180 00000790 E847FA                  	call    output_cmd_to_fdc	; output the command
  2181 00000793 7231                    	jc      .7
  2182                                  
  2183 00000795 E862FF                  	call	wait_operation_complete
  2184 00000798 722C                    	jc	.7
  2185                                  
  2186 0000079A E808FB                  	call    fdc_wait_seek_done
  2187 0000079D 7227                    	jc      .7
  2188                                  
  2189 0000079F 58                      	pop     ax		; get unit # to AH
  2190 000007A0 B004                    	mov     al,CMD_SENSE_DRIVE_STATUS
  2191 000007A2 50                      	push    ax		; push 2 byte command again
  2192 000007A3 B90200                  	mov     cx,2
  2193 000007A6 89E6                    	mov     si,sp
  2194 000007A8 8CD2                    	mov     dx,ss		; DX:SI points at the 2 byte command
  2195 000007AA E82DFA                  	call    output_cmd_to_fdc
  2196 000007AD 7217                    	jc      .7
  2197                                  
  2198 000007AF E818FA                  	call    input_byte_from_fdc	; get ST3
  2199 000007B2 7212                    	jc      .7
  2200 000007B4 88859000                	mov     [fdc_disk_state+di],al	; save ST3 for drive
  2201 000007B8 B487                    	mov	ah,ERR_87		; not on track 0
  2202 000007BA A810                    	test    al,ST3_TR00
  2203 000007BC F9                      	Error				; signal error
  2204 000007BD 7407                    	jz      .7                      ; Not on Track 00, C=1 error
  2205                                  
  2206 000007BF C685940000              	mov	byte [fdc_cylinder+di],0	; set present cylinder
  2207                                  
  2208                                  %if SOFT_DEBUG > 1
  2209                                  	push    -1
  2210                                  	call    lites
  2211                                  %endif
  2212 000007C4 30E4                    	Okay			;
  2213                                  
  2214 000007C6 5E                      .7:     pop     si		; Command is still in the stack
  2215 000007C7 595A5E                  	popm    cx,dx,si	; restore
  2216 000007CA C3                      	ret
  2217                                  
  2218                                  
  2219                                  
  2220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2221                                  ;  Seek			seek to proper cylinder
  2222                                  ;
  2223                                  ;  Call with:
  2224                                  ;	CH = cylinder to which to position heads
  2225                                  ;	CS:BX = disk parameter area
  2226                                  ;	DI = unit number
  2227                                  ;	DS = BIOS data area pointer
  2228                                  ;
  2229                                  ;  Return with:
  2230                                  ;	Carry = 0	success
  2231                                  ;
  2232                                  ;	Carry = 1	error
  2233                                  ;
  2234                                  ;  Assumes "motor_on" has done the real unit select in the LDOR (operations register)
  2235                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2236                                  Seek:
  2237 000007CB 565251                  	pushm	cx,dx,si
  2238                                  
  2239                                  ; check for a recalibration needed
  2240 000007CE 8A859400                	mov	al,[fdc_cylinder+di]	; get present cylinder (0FFh forces recalibrate)
  2241 000007D2 2E3A470B                 cs	cmp	al,[DTAB_max_cylinder+bx]	; compare to maximum
  2242 000007D6 760E                    	jbe	.no_recal
  2243                                  
  2244 000007D8 BE0200                  	mov	si,2			; two recalibrates max.
  2245                                  .rerecal:
  2246 000007DB E89AFF                  	call	recalibrate
  2247 000007DE 7306                    	jnc	.no_recal
  2248 000007E0 4E                      	dec	si
  2249 000007E1 F9                      	Error
  2250 000007E2 7442                    	jz	.exit			; two have failed
  2251 000007E4 EBF5                    	jmp	.rerecal		; try again
  2252                                  
  2253                                  .no_recal:
  2254 000007E6 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; sought : present cylinder
  2255 000007EA 7438                    	je	.okay
  2256                                  
  2257                                  ; we are not on the cylinder we want
  2258                                  
  2259 000007EC 2E3A6F0B                  cs	cmp	ch,[DTAB_max_cylinder+bx]  ; validate cylinder number
  2260 000007F0 7738                    	ja	.invalid
  2261                                  
  2262                                  .valid:
  2263 000007F2 80263E0000              	and	byte [fdc_drv_calib],00h	;POST no interrupts
  2264                                  
  2265 000007F7 86CD                    	xchg	cl,ch			; cylinder to CL
  2266 000007F9 51                      	push	cx			; CL = sought cylinder
  2267 000007FA E883FE                  	call	make_head_unit
  2268 000007FD B40F                    	mov	ah,CMD_SEEK		; command byte
  2269 000007FF 86C4                    	xchg	al,ah			; command byte must be first in stack
  2270 00000801 50                      	push	ax			; push 3 byte command
  2271 00000802 89E6                    	mov	si,sp
  2272 00000804 8CD2                    	mov	dx,ss			; DX:SI points at command
  2273 00000806 B90300                  	mov	cx,3			; 3 byte command
  2274 00000809 E8CEF9                  	call	output_cmd_to_fdc
  2275 0000080C 5E59                    	popm	si,cx			; fix stack; get CL=seek to cylinder
  2276 0000080E 86CD                    	xchg	cl,ch			; CH=seek to cylinder
  2277 00000810 7214                    	jc	.exit
  2278                                  
  2279 00000812 E8E5FE                  	call	wait_operation_complete
  2280 00000815 720F                    	jc	.exit
  2281                                  
  2282                                  ;;;	mov	[fdc_cylinder+di],ch	; set new cylinder number
  2283                                  
  2284 00000817 E88BFA                  	call	fdc_wait_seek_done	; AH=error code if C=1
  2285 0000081A 720A                    	jc	.exit
  2286                                  
  2287                                  %if 0
  2288                                  ; probably have to skip the following during Format
  2289                                  	call	read_track_id		; just to be sure
  2290                                  	jc	.exit
  2291                                  %endif
  2292                                  
  2293 0000081C B440                    	mov	ah,ERR_seek_failed
  2294 0000081E 3AAD9400                	cmp	ch,[fdc_cylinder+di]	; PCN filled in
  2295 00000822 7508                    	jne	.err
  2296                                  ;;;	mov	ah,ERR_8A
  2297                                  ;;;	cmp	ch,[fdc_ctrl_status+3]	; read cylinder number
  2298                                  ;;;	jne	.err
  2299                                  
  2300                                  
  2301                                  .okay:
  2302 00000824 30E4                    	Okay
  2303                                  .exit:
  2304 00000826 595A5E                  	popm	cx,dx,si
  2305 00000829 C3                      	ret
  2306                                  
  2307                                  .invalid:
  2308                                  ; error -- the cylinder requested is invalid for this drive
  2309 0000082A B486                    	mov	ah,ERR_86
  2310 0000082C F9                      .err:	Error
  2311 0000082D EBF7                    	jmp	.exit		  	; jump WAY out
  2312                                  
  2313                                  
  2314                                  
  2315                                  
  2316                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2317                                  ;  Check_RW_Status		check ST0 & ST1 error bits
  2318                                  ;
  2319                                  ;  Call with:
  2320                                  ;	CY = 0,1	needs to be examined
  2321                                  ;
  2322                                  ;  Return with:
  2323                                  ;	CY = 0, AH = 0		no error detected
  2324                                  ;
  2325                                  ;	CY = 1, AH = final error code	error in status bits
  2326                                  ;
  2327                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2328                                   	global	Check_RW_Status
  2329                                  Check_RW_Status:
  2330 0000082F 061E56525153            	pushm	bx,cx,dx,si,ds,es
  2331                                  
  2332                                  %if SOFT_DEBUG & DUMP
  2333 00000835 86C4                    	xchg	al,ah			; error code to AL
  2334 00000837 9F                      	lahf				; flags to AH
  2335 00000838 50                      	push	ax
  2336                                  
  2337 00000839 30E4                    	xor	ah,ah			; zero hi-byte
  2338 0000083B B90700                  	mov	cx,7
  2339 0000083E BE4800                  	mov	si,fdc_ctrl_status+6	; byte to start
  2340 00000841 FD                      .1	std
  2341 00000842 AC                      	lodsb
  2342 00000843 50                        	push	ax			; push argument
  2343 00000844 E2FB                    	loop	.1
  2344 00000846 FC                      	cld
  2345 00000847 0E                      	push	cs
  2346 00000848 68[9808]                	push	fcrw
  2347 0000084B E8(0000)                	call	_cprintf
  2348 0000084E 83C412                  	add	sp,18
  2349                                  
  2350 00000851 58                      	pop	ax
  2351 00000852 9E                      	sahf				; restore flags
  2352 00000853 86C4                    	xchg	al,ah			; restore error code to AH
  2353                                  %endif
  2354                                  
  2355                                  %if 1
  2356 00000855 7309                    	jnc	.no_err
  2357                                  
  2358 00000857 C6460E00                	mov	byte [offset_AL+bp],0	; say nothing transferred
  2359                                  
  2360                                  ; Carry is set, what happened?
  2361 0000085B 80FC81                  	cmp	ah,ERR_81		; first of our new error codes
  2362                                  	;;;
  2363 0000085E EB2E                    	jmp	.error		; for now
  2364                                  %endif
  2365                                  
  2366                                  
  2367                                  .no_err:
  2368 00000860 8A264200                	mov	ah,[fdc_ctrl_status]	; get ST0 to AH
  2369 00000864 88E0                    	mov	al,ah			; retain copy in AL
  2370 00000866 80E4C0                  	and	ah,ST0_IC		; check interrupt code
  2371 00000869 7424                    	jz	.exit	; Okay is set
  2372                                  
  2373 0000086B B420                    	mov	ah,ERR_controller_failure
  2374 0000086D A810                    	test	al,ST0_EC
  2375 0000086F 751D                    	jnz	.error
  2376                                  
  2377 00000871 A04300                  	mov	al,[fdc_ctrl_status+1]	; get ST1 to AL
  2378 00000874 B402                    	mov	ah,ERR_address_mark_not_found
  2379 00000876 A801                    	test	al,ST1_MA		; test Missing Address mark
  2380 00000878 7514                    	jnz	.error
  2381                                  
  2382 0000087A FEC4                    	inc	ah			; Write Protect
  2383 0000087C A802                    	test	al,ST1_NW		;
  2384 0000087E 750E                    	jnz	.error
  2385                                  
  2386 00000880 FEC4                    	inc	ah			; Sector not Found
  2387 00000882 A804                    	test	al,ST1_ND		; No Data
  2388 00000884 7508                    	jnz	.error
  2389                                  
  2390 00000886 B410                    	mov	ah,ERR_uncorrectable_CRC_error
  2391 00000888 A820                    	test	al,ST1_DE
  2392 0000088A 7502                    	jnz	.error
  2393                                  
  2394 0000088C B48F                    	mov	ah,ERR_unknown		; may be in ST2
  2395                                  
  2396 0000088E F9                      .error:	Error				; code is in AH
  2397                                  .exit:
  2398 0000088F 5B595A5E1F900790        	popm	bx,cx,dx,si,ds,es
  2399 00000897 C3                      	ret
  2400                                  
  2401                                  
  2402                                  %if SOFT_DEBUG & DUMP
  2403 00000898 0A5354302025303278-     fcrw	db	NL,"ST0 %02x  ST1 %02x  ST2 %02x  C+ %02x  H+ %02x  S+ %02x  N %x", 0
  2403 000008A1 202053543120253032-
  2403 000008AA 782020535432202530-
  2403 000008B3 32782020432B202530-
  2403 000008BC 32782020482B202530-
  2403 000008C5 32782020532B202530-
  2403 000008CE 327820204E20257800 
  2404 000008D7 0A4158202530347820-     rwvc	db	NL,"AX %04x  CHS %02x:%02x:%02x  DL %02x  ES:BX %04x:%04x", 0
  2404 000008E0 204348532025303278-
  2404 000008E9 3A253032783A253032-
  2404 000008F2 782020444C20253032-
  2404 000008FB 78202045533A425820-
  2404 00000904 253034783A25303478-
  2404 0000090D 00                 
  2405 0000090E 0A4148202530327820-     fnret	db	NL,"AH %02x  CY %d  CMD %02x %02x",NL, 0
  2405 00000917 204359202564202043-
  2405 00000920 4D4420253032782025-
  2405 00000929 3032780A00         
  2406                                  %endif
  2407                                  
  2408                                  
  2409                                  
  2410                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2411                                  ;  @enable / @disable		Interrupt enable/disable
  2412                                  ;
  2413                                  ;  On a @disable, increment the lock counter and CLI
  2414                                  ;  On an @enable, decrement the lock counter and if it goes to zero, STI
  2415                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2416                                  	global	@enable, @disable
  2417                                  @disable:
  2418 0000092E 1E50                    	pushm	ax,ds
  2419 00000930 9F                      	lahf				; save user flags
  2420 00000931 6A40                    	push	bios_data_seg		; universal addressing
  2421 00000933 1F90                    	popm	ds
  2422 00000935 FA                      	cli				; guarantee locked operation
  2423 00000936 FE06AE00                	inc	byte [lock_count]
  2424 0000093A 9E                      	sahf				; restore user flags
  2425 0000093B 581F90                  	popm	ax,ds
  2426 0000093E C3                      	ret
  2427                                  
  2428                                  @enable:
  2429 0000093F 1E50                    	pushm	ax,ds
  2430 00000941 9F                      	lahf				; save user flags
  2431 00000942 6A40                    	push	bios_data_seg
  2432 00000944 1F90                    	popm	ds
  2433 00000946 FE0EAE00                	dec	byte [lock_count]	; test the lock count
  2434 0000094A 7501                    	jnz	.5
  2435 0000094C FB                      	sti				; lock count went to zero, re-enable
  2436                                  .5:
  2437 0000094D 9E                      	sahf				; restore user flags
  2438 0000094E 581F90                  	popm	ax,ds
  2439 00000951 C3                      	ret
  2440                                  
  2441                                  
  2442                                  
  2443                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2444                                  ;  read_track_id			; read address mark information
  2445                                  ;
  2446                                  ;  Call with:
  2447                                  ;	DS = BIOS data segment
  2448                                  ;	DI = unit number
  2449                                  ;	DH = head number
  2450                                  ;
  2451                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2452                                  read_track_id:
  2453 00000952 525156                  	pushm	si,cx,dx
  2454                                  
  2455 00000955 C6063E0000              	mov	byte [fdc_drv_calib],0	; clear interrupt flags
  2456                                  
  2457 0000095A E823FD                  	call	make_head_unit		; head/un
  2458 0000095D 88C4                    	mov	ah,al			; move to AH (second byte of command)
  2459 0000095F B04A                    	mov	al,CMD_READ_ID | CMD_MF
  2460 00000961 50                      	push	ax			; push the 2-byte command
  2461 00000962 89E6                    	mov	si,sp
  2462 00000964 8CD2                    	mov	dx,ss			; DX:SI points at command
  2463 00000966 B90200                  	mov	cx,2			; 2 bytes to READ_ID
  2464 00000969 E86EF8                  	call 	output_cmd_to_fdc	; issue the command
  2465 0000096C 58                      	pop	ax			; discard word in stack
  2466                                  
  2467 0000096D E88AFD                  	call	wait_operation_complete
  2468                                  
  2469 00000970 5E595A                  	popm	si,cx,dx
  2470 00000973 C3                      	ret
