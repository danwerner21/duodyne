     1                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2                                  ; SDcard.ASM -- Basic I/O routines for the Dual SDcard add-on board
     3                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     4                                  ;
     5                                  ;   This version is for assembly by  NASM 0.98.39 or later
     6                                  ;
     7                                  ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
     8                                  ; Provided for hobbyist use on the N8VEM SBC-188 board.
     9                                  ;
    10                                  ; This program is free software: you can redistribute it and/or modify
    11                                  ; it under the terms of the GNU General Public License as published by
    12                                  ; the Free Software Foundation, either version 3 of the License, or
    13                                  ; (at your option) any later version.
    14                                  ;
    15                                  ; This program is distributed in the hope that it will be useful,
    16                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    17                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    18                                  ; GNU General Public License for more details.
    19                                  ;
    20                                  ; You should have received a copy of the GNU General Public License
    21                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    22                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    23                                  %include	"config.asm"
    24                              <1> ;/*
    25                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                              <1> ; ANSI.CFG
    27                              <1> ;   Copied to CONFIG.ASM for general release.
    28                              <1> ;
    29                              <1> ;       Modify the parameters below to reflect your system
    30                              <1> ;
    31                              <1> ;
    32                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    33                              <1> ;
    34                              <1> ;   Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    35                              <1> ;   Provided for hobbyist use on the N8VEM SBC-188 board.
    36                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    37                              <1> ;
    38                              <1> ; Define the serial terminal that the Video BIOS must emulate
    39                              <1> ; Set one of the following to 1
    40                              <1> ; If you have no idea what to choose, set TTY to 1
    41                              <1> TTY     equ     0       ; hardcopy -- cannot position the cursor
    42                              <1> DUMB    equ     0       ; dumb CRT -- ^H, ^J, ^K, ^L can move the cursor
    43                              <1> ANSI    equ     1       ; very smart, like a VT-100
    44                              <1> WYSE    equ     0       ; very smart Wyse series (30, 50, ...)
    45                              <1> ; others may get added in the future
    46                              <1> ;  ONE OF THE ABOVE must BE SET TO 1!!!!!
    47                              <1> ;
    48                              <1> ; Define the UART startup bit rate - 1200-19200 are most common
    49                              <1> ;UART_RATE	equ	0		; 1200
    50                              <1> ;UART_RATE	equ	1		; 2400
    51                              <1> ;UART_RATE	equ	2		; 4800
    52                              <1> UART_RATE	equ	3		; 9600
    53                              <1> ;UART_RATE	equ	4		; 19200
    54                              <1> ;UART_RATE	equ	5		; 38400
    55                              <1> ;UART_RATE	equ	6		; 57600
    56                              <1> ;UART_RATE	equ	7		; 115200
    57                              <1> 
    58                              <1> ; Does the serial terminal use the DSR/DTR protocol for flow control?
    59                              <1> ;UART_DSR_PROTOCOL	equ		1	; Yes!
    60                              <1> UART_DSR_PROTOCOL       equ             WYSE    ; Wyse always uses it
    61                              <1> 						; but not ANSI
    62                              <1> ; Define the size of the ROM image on the system in Kilobytes
    63                              <1> ; It may be smaller than the actual EPROM in use.
    64                              <1> ; The following sizes are supported:  32, 64, 128, and 256
    65                              <1> %ifndef ROM
    66                              <1> ROM             equ     32              ; 64 is the default
    67                              <1> %endif
    68                              <1> 
    69                              <1> ; Define the number of Wait States at which the ROM operates
    70                              <1> ROM_WS          equ     1               ; 0..3  (1 is the default)
    71                              <1> 
    72                              <1> ; Define the size in Kilobytes of DOS RAM (low SRAM plus EMM allocate RAM)
    73                              <1> ; This is a desired size and will only be present if a 4MEM board is added
    74                              <1> RAM_DOS         equ     640
    75                              <1> 
    76                              <1> ; Define the size of the low SRAM on the system in Kilobytes
    77                              <1> ; the default is 512 kilobytes
    78                              <1> RAM             equ     512             ; (512 is the default)
    79                              <1> 
    80                              <1> ; Define the number of Wait States at which the RAM operates
    81                              <1> RAM_WS          equ     0               ; 0..3  (0 is the default)
    82                              <1> 
    83                              <1> ; Define the number of Wait States for Local Peripheral devices (600-7FF)
    84                              <1> LCL_IO_WS       equ     1               ; 0..3  (1 is the default)
    85                              <1> 
    86                              <1> ; Define the number of Wait States for ECB BUS peripheral devices (4xx)
    87                              <1> BUS_IO_WS       equ     3               ; 0..3  (3 is the default)
    88                              <1> 
    89                              <1> ; Define the time zone in which we build the Relocatable BIOS
    90                              <1> %ifndef TIMEZONE
    91                              <1> %define TIMEZONE "CST"
    92                              <1> %endif
    93                              <1> 
    94                              <1> ; Has the REDBUG debugger been loaded?
    95                              <1> %ifndef SOFT_DEBUG
    96                              <1> %define SOFT_DEBUG 0
    97                              <1> %endif
    98                              <1> 
    99                              <1> ; Should the BIOS include "Tiny BASIC" in the image?
   100                              <1> %ifndef TBASIC
   101                              <1> TBASIC          equ     1		; default is 1
   102                              <1> %endif
   103                              <1> 
   104                              <1> ; Should the BIOS include the Floating Point Emulator?  The 80188 does
   105                              <1> ; not allow a floating point co-processor, so this is probably a good idea.
   106                              <1> %ifndef FPEM
   107                              <1> FPEM            equ     1               ; default is 1
   108                              <1> %endif
   109                              <1> 
   110                              <1> ; Define the maximum number of EMM (4MEM) boards supported
   111                              <1> EMM_BOARDS      equ     0
   112                              <1> 
   113                              <1> ; Should the Floating Point Emulator use temporary storage in the EBDA
   114                              <1> ; or at locations 0280h..3FFh in low memory?
   115                              <1> %if SOFT_DEBUG
   116                              <1> FPEM_USE_EBDA   equ     FPEM            ; default is 0
   117                              <1> %else
   118                              <1> FPEM_USE_EBDA   equ     0; FPEM            ; default is 0
   119                              <1> %endif
   120                              <1> 
   121                              <1> ; Define the size of the EPROM that is to be installed on the system
   122                              <1> ; It may be larger than the actual ROM image to be generated.
   123                              <1> %ifndef CHIP
   124                              <1> CHIP            equ     64
   125                              <1> %endif
   126                              <1> 
   127                              <1> ; Does the SBC-188 00.4 board have the LS138/LS08 piggyback fix
   128                              <1> ; Set to 1 for the SBC-188 v1.0 and later production boards
   129                              <1> ;FDC_PIGGYBACK_FIX       equ     0       ; Fix not installed
   130                              <1> FDC_PIGGYBACK_FIX       equ     1       ; fix  IS  installed
   131                              <1> 
   132                              <1> ; On SBC-188 rev 00.4 board, there is a published hardware fix (2010-09-18).
   133                              <1> ; If the wiring update is installed, or you have a later board, then
   134                              <1> ; set this to 0.  If you are using the software workaround, then set this
   135                              <1> ; to 1.  The rev 1.0 board has this fix already.
   136                              <1> NEED_TIMER_FIX  equ     0               ; have revised hardware
   137                              <1> ;NEED_TIMER_FIX  equ     1               ; use workaround
   138                              <1> 
   139                              <1> ; Define the UART oscillator speed
   140                              <1> UART_OSC        equ     1843200         ; 1.8432 Mhz is specified
   141                              <1> 
   142                              <1> 
   143                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   144                              <1> ; end of the User configuration
   145                              <1> ;       Do Not modify anything below this point
   146                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   147                              <1> 
   148                              <1> ; Define existence of any uart chip
   149                              <1> UART		equ	TTY+DUMB+ANSI+WYSE
   150                              <1> startuplength   equ     512                     ; may be up to 1024
   151                              <1> startseg        equ     0FFFFh - (ROM*64) + 1
   152                              <1> highrom         equ     (ROM*400h)&0FFFFh
   153                              <1> startupseg      equ     0FFFFh - (startuplength>>4) + 1
   154                              <1> bios_data_seg   equ     040h            ; segment of BIOS data area
   155                              <1> 
   156                              <1> 
   157                              <1> %define ARG(n) [bp+2+(n)*2]
   158                              <1> 
   159                              <1> %macro  check   1.nolist
   160                              <1>  %if (%1)
   161                              <1>    %error Check Failure: %1
   162                              <1>  %endif
   163                              <1> %endm
   164                              <1> %macro  range   3.nolist
   165                              <1>  %if (%1)<(%2)
   166                              <1>    %error Out of Range: %1
   167                              <1>  %elif (%1)>(%3)
   168                              <1>    %error Out of Range: %1
   169                              <1>  %endif
   170                              <1> %endm
   171                              <1> _terminal equ UART
   172                              <1>  check   RAM_DOS&15
   173                              <1>  check   RAM&(RAM-1)
   174                              <1>  check   ROM&(ROM-1)
   175                              <1>  range   RAM,32,512
   176                              <1>  range   ROM,32,256
   177                              <1>  range   RAM_WS,0,3
   178                              <1>  range   ROM_WS,0,3
   179                              <1>  range   RAM_DOS,RAM,(1024-ROM)
   180                              <1>  range   LCL_IO_WS,0,3
   181                              <1>  range   BUS_IO_WS,0,3
   182                              <1>  range   UART_OSC,500000,16000000
   183                              <1>  range   UART_RATE,0,7
   184                              <1>  range	 UART,0,1
   185                              <1>  range	 _terminal,1,2
   186                              <1> 
   187                              <1> %ifndef SOFT_DEBUG
   188                              <1> %define SOFT_DEBUG 0
   189                              <1> %endif
   190                              <1> 
   191                              <1> %ifndef TRACE
   192                              <1> %define TRACE 0
   193                              <1> %endif
   194                              <1> 
   195                              <1> %ifdef MAKE_OBJECT_FILE
   196                              <1>         segment _DATA WORD PUBLIC CLASS=DATA
   197                              <1>         export _ROMsize
   198                              <1>         export _CHIPsize
   199                              <1> _ROMsize        dw      ROM
   200                              <1> _CHIPsize       dw      CHIP
   201                              <1> %endif
   202                              <1> ; end of the Hardware configuration file
   203                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   204                              <1> ;*/
    24                                  %include	"cpuregs.asm"
    25                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    26                              <1> ; CPUREGS.ASM
    27                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    28                              <1> ;
    29                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    30                              <1> ;
    31                              <1> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    32                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    33                              <1> ;
    34                              <1> ; This program is free software: you can redistribute it and/or modify
    35                              <1> ; it under the terms of the GNU General Public License as published by
    36                              <1> ; the Free Software Foundation, either version 3 of the License, or
    37                              <1> ; (at your option) any later version.
    38                              <1> ;
    39                              <1> ; This program is distributed in the hope that it will be useful,
    40                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    41                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    42                              <1> ; GNU General Public License for more details.
    43                              <1> ;
    44                              <1> ; You should have received a copy of the GNU General Public License
    45                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    46                              <1> ;
    47                              <1> ; Updated for the Duodyne 80c188 SBC
    48                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    49                              <1> %include	"macros.inc"
    50                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    51                              <2> ; MACROS.INC  
    52                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <2> ;
    54                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    55                              <2> ;
    56                              <2> ; Copyright (C) 2010,2011 John R. Coffman.  All rights reserved.
    57                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    58                              <2> ;
    59                              <2> ; This program is free software: you can redistribute it and/or modify
    60                              <2> ; it under the terms of the GNU General Public License as published by
    61                              <2> ; the Free Software Foundation, either version 3 of the License, or
    62                              <2> ; (at your option) any later version.
    63                              <2> ;
    64                              <2> ; This program is distributed in the hope that it will be useful,
    65                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    66                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    67                              <2> ; GNU General Public License for more details.
    68                              <2> ;
    69                              <2> ; You should have received a copy of the GNU General Public License
    70                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    71                              <2> ;
    72                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    73                              <2> 
    74                              <2> ; general macros for the SBC188 BIOS ASSEMBLY
    75                              <2> ;
    76                              <2> ;
    77                              <2> %ifndef __MACROS_DEFINED_
    78                              <2> %define __MACROS_DEFINED_ 1
    79                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    80                              <2> ;
    81                              <2> ; some useful macros:
    82                              <2> ;
    83                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    84                              <2> ;
    85                              <2> 	cpu	186
    86                              <2> 
    87                              <2> %imacro setloc  1.nolist
    88                              <2>  times   (%1-($-$$)) db 0FFh
    89                              <2> %endm
    90                              <2> 
    91                              <2> %imacro db_lo   1
    92                              <2>  db (%1)&255
    93                              <2> %endm
    94                              <2> 
    95                              <2> %imacro cnop    0.nolist
    96                              <2> %if SOFT_DEBUG
    97                              <2>         nop
    98                              <2> %endif
    99                              <2> %endm
   100                              <2> 
   101                              <2> %imacro popm 1-*.nolist
   102                              <2> %rep %0
   103                              <2> %ifidni %1,ALL
   104                              <2>  popa
   105                              <2> %elifidni %1,F
   106                              <2>  popf
   107                              <2> %else
   108                              <2>  pop %1
   109                              <2> %ifidni %1,DS
   110                              <2>  cnop
   111                              <2> %elifidni %1,ES
   112                              <2>  cnop
   113                              <2> %endif
   114                              <2> %endif
   115                              <2> %rotate 1
   116                              <2> %endrep
   117                              <2> %endm
   118                              <2> 
   119                              <2> %imacro pushm 1-*.nolist
   120                              <2> %rep %0
   121                              <2> %rotate -1
   122                              <2> %ifidni %1,ALL
   123                              <2>  pusha
   124                              <2> %elifidni %1,F
   125                              <2>  pushf
   126                              <2> %else
   127                              <2>  push %1
   128                              <2> %endif
   129                              <2> %endrep
   130                              <2> %endm
   131                              <2> 
   132                              <2> ;
   133                              <2> ; added from the 386EX project
   134                              <2> ;
   135                              <2> 
   136                              <2> ; call arguments
   137                              <2> %define ARG(n) [bp+2+(n)*2]
   138                              <2> 
   139                              <2> ;
   140                              <2> ; format of the BYTE initialization table:  address, byte
   141                              <2> ;
   142                              <2> %imacro  binit 2
   143                              <2>         dw      %1
   144                              <2>         db      %2
   145                              <2> %endmacro
   146                              <2> ; end with DW -1
   147                              <2> 
   148                              <2> ;
   149                              <2> ; format of the WORD initialization table:  address, word
   150                              <2> ;
   151                              <2> %imacro  winit 2
   152                              <2>         dw      %1
   153                              <2>         dw      %2
   154                              <2> %endmacro
   155                              <2> ; end with DW -1
   156                              <2> 
   157                              <2> 
   158                              <2> ; get the BIOS Data Area segment pointer to a [segment] register
   159                              <2> %imacro get_bda	1.nolist
   160                              <2> 	push	0x0040
   161                              <2> 	pop	%1
   162                              <2> 	cnop
   163                              <2> %endm
   164                              <2> 
   165                              <2> 
   166                              <2> %endif
    50                              <1> 
    51                              <1> 	cpu     186
    52                              <1> ;
    53                              <1> ;
    54                              <1> ; IBM model byte -- must be less than a 286
    55                              <1> ;
    56                              <1> ;MODEL_BYTE		equ	0FEh	; PC-XT
    57                              <1> ;SUBMODEL_BYTE		equ	0FFh	; not used
    58                              <1> 
    59                              <1> MODEL_BYTE		equ	0FEh	; PC-XT
    60                              <1> SUBMODEL_BYTE		equ	00h	;  "
    61                              <1> 
    62                              <1> 
    63                              <1> ; 80188 peripheral control register block address
    64                              <1> CPU_CSCR	        equ	0FF00h
    65                              <1> 
    66                              <1> ; Compatible Mode registers
    67                              <1> 
    68                              <1> cpu_relocation          equ     CPU_CSCR+0FEh
    69                              <1> 
    70                              <1> ; The memory and peripheral chip select register offsets from 0FF00h
    71                              <1> 
    72                              <1> cpu_umcs                equ     CPU_CSCR+0A0h          ; Upper memory select
    73                              <1> cpu_lmcs                equ     CPU_CSCR+0A2h          ; Lower memory select
    74                              <1> cpu_pacs                equ     CPU_CSCR+0A4h          ; Peripheral select
    75                              <1> cpu_mmcs                equ     CPU_CSCR+0A6h          ; Middle memory base
    76                              <1> cpu_mpcs                equ     CPU_CSCR+0A8h          ; Mid mem. & peripherals
    77                              <1> 
    78                              <1> ; Enhanced Mode registers
    79                              <1> 
    80                              <1> cpu_mdram               equ     CPU_CSCR+0E0h          ; memory partition reg.
    81                              <1> cpu_cdram               equ     CPU_CSCR+0E2h          ; clock prescaler
    82                              <1> cpu_edram               equ     CPU_CSCR+0E4h          ; Enable refresh reg.
    83                              <1> cpu_pdcon               equ     CPU_CSCR+0F0h          ; Power-Save control
    84                              <1> 
    85                              <1> 
    86                              <1> ; On-board internal peripheral equates
    87                              <1> ; Programmable Interrupt Controller
    88                              <1> PIC	        equ	CPU_CSCR+020H
    89                              <1> PIC_EOI	        equ	PIC+2           ; End Of Interrupt
    90                              <1> PIC_POLLR	equ	PIC+4
    91                              <1> PIC_POLLSR	equ	PIC+6
    92                              <1> PIC_IMASK	equ	PIC+8
    93                              <1> PIC_PMREG	equ	PIC+0AH
    94                              <1> PIC_SRVR	equ	PIC+0CH
    95                              <1> PIC_IRQR	equ	PIC+0EH
    96                              <1> PIC_IRQSR	equ	PIC+10H
    97                              <1> PIC_TCR	        equ	PIC+12H
    98                              <1> PIC_DMA0CR	equ	PIC+14H
    99                              <1> PIC_DMA1CR	equ	PIC+16H
   100                              <1> PIC_I0CON	equ	PIC+18H
   101                              <1> PIC_I1CON	equ	PIC+1AH
   102                              <1> PIC_I2CON	equ	PIC+1CH
   103                              <1> PIC_I3CON	equ	PIC+1EH
   104                              <1> 
   105                              <1> EOI_NSPEC       equ     8000h           ; Non-Specific EOI
   106                              <1> 
   107                              <1> ; Interrupt masks (Master Mode)
   108                              <1> ;
   109                              <1> mask_timer_all          equ     0001h
   110                              <1> mask_dma0               equ     0004h
   111                              <1> mask_dma1               equ     0008h
   112                              <1> mask_int0               equ     0010h
   113                              <1> mask_int1               equ     0020h
   114                              <1> mask_int2               equ     0040h
   115                              <1> mask_int3               equ     0080h
   116                              <1> 
   117                              <1> 
   118                              <1> 
   119                              <1> ; Timers
   120                              <1> TIM0	        equ	CPU_CSCR+050H
   121                              <1> TIM1	        equ	CPU_CSCR+058H
   122                              <1> TIM2	        equ	CPU_CSCR+060H
   123                              <1> 
   124                              <1> TCNT	        equ	0	; count register
   125                              <1> CMPA	        equ	2	; max count A
   126                              <1> CMPB	        equ	4	; max count B (not present on TIM2)
   127                              <1> TCON	        equ	6	; mode/control word
   128                              <1> 
   129                              <1> ; Timer control bits:
   130                              <1> tc_EN           equ     8000h   ; Enable bit
   131                              <1> tc_nINH         equ     4000h   ; not Inhibit Enable
   132                              <1> tc_INT          equ     2000h   ; Interrupt Enable
   133                              <1> tc_RIU          equ     1000h   ; Register A/B (0/1) in Use
   134                              <1> tc_MC           equ     0020h   ; Maximum Count reached
   135                              <1> tc_RTG          equ     0010h   ; Retrigger (internal source)
   136                              <1> tc_P            equ     0008h   ; Prescale internal clock (timers 0 & 1 only)
   137                              <1> tc_EXT          equ     0004h   ; External clock
   138                              <1> tc_ALT          equ     0002h   ; Alternate between A & B max count registers
   139                              <1> tc_CONT         equ     0001h   ; Continuous: continue after max count
   140                              <1> 
   141                              <1> 
   142                              <1> 
   143                              <1> 
   144                              <1> ; DMA
   145                              <1> DMA0	        equ	CPU_CSCR+0C0H
   146                              <1> DMA1	        equ	CPU_CSCR+0D0H
   147                              <1> DMASPL	        equ	0	; source pointer low
   148                              <1> DMASPU	        equ	2	; source pointer high
   149                              <1> DMADPL	        equ	4	; destination pointer low
   150                              <1> DMADPU	        equ	6	; destination pointer high
   151                              <1> DMATC	        equ	8	; terminal count
   152                              <1> DMACW	        equ	0AH	; control word
   153                              <1> 
   154                              <1> 
   155                              <1> 
   156                              <1> 
   157                              <1> 
   158                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   159                              <1> ;
   160                              <1> ;       SBC-188 external devices
   161                              <1> ;
   162                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   163                              <1> 
   164                              <1> IO_BASE			equ	0400h
   165                              <1> 
   166                              <1> 
   167                              <1> 
   168                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   169                              <1> ; The UART registers (Duodyne SBC 80c188 Console port)
   170                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   171                              <1> 
   172                              <1> uart_base               equ     IO_BASE+0280h
   173                              <1> uart_rbr                equ     uart_base       ;Rcvr Buffer / read only
   174                              <1> uart_thr                equ     uart_base       ;Transmit Holding / write only
   175                              <1> uart_ier                equ     uart_base+1     ;Interrupt Enable
   176                              <1> uart_iir                equ     uart_base+2     ;Interrupt Ident / read only
   177                              <1> uart_fcr                equ     uart_base+2     ;FIFO Control / write only
   178                              <1> uart_lcr                equ     uart_base+3     ;Line Control
   179                              <1> uart_mcr                equ     uart_base+4     ;Modem Control
   180                              <1> uart_lsr                equ     uart_base+5     ;Line Status
   181                              <1> uart_msr                equ     uart_base+6     ;Modem Status
   182                              <1> uart_sr			equ	uart_base+7	;Scratch
   183                              <1> 
   184                              <1> uart_dll                equ     uart_base       ;Divisor Latch LS Byte
   185                              <1> uart_dlm                equ     uart_base+1     ;Divisor Latch MS Byte
   186                              <1> 
   187                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   188                              <1> ; CONTROL LS259 PORT  (DuoDyne 80C188)
   189                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   190                              <1> CTRL259		equ	IO_BASE+0238H
   191                              <1> ; LEDS are at addresses 0..3
   192                              <1> ; other control ports on 4..7
   193                              <1> LED0		equ	CTRL259+0
   194                              <1> LED1		equ	LED0+1
   195                              <1> LED2		equ	LED0+2
   196                              <1> LED3		equ	LED0+3
   197                              <1> T1OSC18		equ	CTRL259+4	; ON=1.8432mhz, OFF="1" (for use of TIMER2)
   198                              <1> ;unused		equ	CTRL259+5
   199                              <1> ;unused		equ	CTRL259+6
   200                              <1> ;unused		equ	CTRL259+7
   201                              <1> 
   202                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   203                              <1> ; Front Panel Connector  (DuoDyne 80C188)
   204                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   205                              <1> FRONT_PANEL_LED	equ	IO_BASE+0230H
   206                              <1> 
   207                              <1> 
   208                              <1> 
   209                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   210                              <1> ; Floppy controller (Duodyne Disk IO)
   211                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   212                              <1> FDC	        equ	IO_BASE+0080H
   213                              <1> FDC_MSR         equ     FDC
   214                              <1> FDC_DATA        equ     FDC+1
   215                              <1> FDC_TC	        equ	FDC+2
   216                              <1> FDC_RES	        equ	FDC+3
   217                              <1> FDC_LDCR	equ	FDC+5
   218                              <1> FDC_LDOR	equ	FDC+6
   219                              <1> FDC_DACK        equ	FDC+6
   220                              <1> FDC_DACK_TC     equ     FDC+7
   221                              <1> 
   222                              <1> 
   223                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   224                              <1> ;DS1302 RTC (Duodyne Ram/ROM Card)
   225                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   226                              <1> RTC	equ	IO_BASE+0094H
   227                              <1> 
   228                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   229                              <1> ; PIO 82C55 I/O  (Duodyne Disk IO)
   230                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   231                              <1> PPI	        equ	IO_BASE+0088H
   232                              <1> 
   233                              <1> PIO_A	        equ	PPI+0	; (OUTPUT)
   234                              <1> PIO_B	        equ	PPI+1	; (INPUT)
   235                              <1> PIO_C	        equ	PPI+2	; (CENTRONICS control low nibble)
   236                              <1> PIO_CTRL	equ	PPI+3	; CONTROL BYTE PIO 82C55
   237                              <1> 
   238                              <1> portA           equ     PPI+0   ;
   239                              <1> portB           equ     PPI+1   ;
   240                              <1> portC           equ     PPI+2   ;
   241                              <1> 
   242                              <1> ; end CPUREGS.ASM
    25                                  %include	"equates.asm"
    26                              <1> ;========================================================================
    27                              <1> ; EQUATES.ASM -- Lots of Defintions for Relocatable BIOS
    28                              <1> ;========================================================================
    29                              <1> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    30                              <1> ;
    31                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    32                              <1> ;
    33                              <1> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    34                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    35                              <1> ;
    36                              <1> ; This program is free software: you can redistribute it and/or modify
    37                              <1> ; it under the terms of the GNU General Public License as published by
    38                              <1> ; the Free Software Foundation, either version 3 of the License, or
    39                              <1> ; (at your option) any later version.
    40                              <1> ;
    41                              <1> ; This program is distributed in the hope that it will be useful,
    42                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    43                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    44                              <1> ; GNU General Public License for more details.
    45                              <1> ;
    46                              <1> ; You should have received a copy of the GNU General Public License
    47                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    48                              <1> ;
    49                              <1> ;========================================================================
    50                              <1> 
    51                              <1>         global  FPEM_segment
    52                              <1> 
    53                              <1> 
    54                              <1> %include "segdef.asm"
    55                              <2> ;========================================================================
    56                              <2> ; SEGDEF.ASM -- Lots of Defintions for Relocatable BIOS
    57                              <2> ;========================================================================
    58                              <2> ;   for the N8VEM SBC-188 v.00.4 and 00.5
    59                              <2> ;
    60                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    61                              <2> ;
    62                              <2> ; Copyright (C) 2010 John R. Coffman.  All rights reserved.
    63                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    64                              <2> ;
    65                              <2> ; This program is free software: you can redistribute it and/or modify
    66                              <2> ; it under the terms of the GNU General Public License as published by
    67                              <2> ; the Free Software Foundation, either version 3 of the License, or
    68                              <2> ; (at your option) any later version.
    69                              <2> ;
    70                              <2> ; This program is distributed in the hope that it will be useful,
    71                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    72                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    73                              <2> ; GNU General Public License for more details.
    74                              <2> ;
    75                              <2> ; You should have received a copy of the GNU General Public License
    76                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    77                              <2> ;
    78                              <2> ;========================================================================
    79                              <2> 
    80                              <2> %ifndef __SEGDEF_
    81                              <2> %define __SEGDEF_
    82                              <2> 
    83                              <2> 	SEGMENT  _TEXT ALIGN=2 PUBLIC CLASS=CODE
    84                              <2>         SEGMENT  CONST ALIGN=2 PUBLIC CLASS=DATA
    85                              <2>         SEGMENT  CONST2 ALIGN=2 PUBLIC CLASS=DATA
    86                              <2> 	SEGMENT  _DATA ALIGN=16 PUBLIC CLASS=DATA
    87                              <2> 	SEGMENT  _BSS  ALIGN=2 PUBLIC CLASS=BSS
    88                              <2> ;;;        SEGMENT  _BASIC ALIGN=16 PUBLIC CLASS=BASIC
    89                              <2> 
    90                              <2> 	GROUP	DGROUP CONST CONST2 _DATA _BSS
    91                              <2> 
    92                              <2> %endif
    93                              <2> 
    55                              <1> %include "ascii.asm"
    56                              <2> ; ascii.asm
    57                              <2> ;
    58                              <2> CTRL            equ     1Fh     ; masks a character to CTRL-x
    59                              <2> 
    60                              <2> NUL     equ     00h
    61                              <2> BEL     equ     (CTRL & 'G')
    62                              <2> BS      equ     08h		; ^H
    63                              <2> HT      equ     09h		; ^I
    64                              <2> LF	equ	0Ah		; ^J
    65                              <2> NL      equ     LF
    66                              <2> VT	equ	0Bh		; ^K
    67                              <2> FWD	equ	0Ch		; ^L
    68                              <2> CR	equ	0Dh
    69                              <2> XON     equ     (CTRL & 'Q')
    70                              <2> XOFF    equ     (CTRL & 'S')
    71                              <2> DC1     equ     XON
    72                              <2> DC3     equ     XOFF
    73                              <2> ESC     equ	1Bh
    74                              <2> 
    75                              <2> 
    56                              <1> 
    57                              <1> 
    58                              <1> ; POST error codes. Presently one byte but can expand to word.
    59                              <1> ER_BIOS equ	01h		; Bad ROM bios checksum, patch last byte
    60                              <1> ER_RAM	equ	02h		; Bad RAM in main memory, replace
    61                              <1> ER_CRT	equ	04h		; Bad RAM in video card, replace
    62                              <1> ER_FDC	equ	08h		; Bad FDC
    63                              <1> ER_UNK1	equ	10h		; {unassigned}
    64                              <1> ER_MEM	equ	20h		; Bad RAM in vector area, replace
    65                              <1> ER_ROM	equ	40h		; Bad ROM in expansion area, bad checksum
    66                              <1> ER_UNK2	equ	80h		; {unassigned}
    67                              <1> 
    68                              <1> 
    69                              <1> 
    70                              <1> ;; ************************ BIOS Data Segment ******************************
    71                              <1> ;; BIOS data segment - not all will  be used
    72                              <1> ;                struc   BIOS_DATA_AREA  ; at 0040:0000
    73                              <1> %include "bda.inc"
    74                              <2> ;/*======================================================================
    75                              <2> ; bda.inc -- BIOS data area definitions
    76                              <2> ;========================================================================
    77                              <2> ;   for the N8VEM SBC-188
    78                              <2> ;
    79                              <2> ;   This version is for assembly by  NASM 0.98.39 or later
    80                              <2> ;
    81                              <2> ; Copyright (C) 2013 John R. Coffman.  All rights reserved.
    82                              <2> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    83                              <2> ;
    84                              <2> ; This program is free software: you can redistribute it and/or modify
    85                              <2> ; it under the terms of the GNU General Public License as published by
    86                              <2> ; the Free Software Foundation, either version 3 of the License, or
    87                              <2> ; (at your option) any later version.
    88                              <2> ;
    89                              <2> ; This program is distributed in the hope that it will be useful,
    90                              <2> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    91                              <2> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    92                              <2> ; GNU General Public License for more details.
    93                              <2> ;
    94                              <2> ; You should have received a copy of the GNU General Public License
    95                              <2> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    96                              <2> ;
    97                              <2> ;========================================================================
    98                              <2> 
    99                              <2> 			;*/ extern				/*
   100                              <2> 	ABSOLUTE  0	;*/ struct BDA {			/*
   101 00000000 ????????????????    <2> serial_ports    resw    4	;*/	word	serial_ports[4];	/*
   102 00000008 ????????????????    <2> parallel_ports  resw    4	;*/	word	parallel_ports[4];	/*
   103 00000010 ????                <2> equipment_flag  resw    1	;*/	EQFL	equipment_flag;		/*
   104                              <2> ;	dw	?		; 40:10 	; Equipment present word
   105                              <2> ;  						;  = (1 iff floppies) *     1.
   106                              <2> ;                                               ;  + (1 iff 187     ) *     2.
   107                              <2> ;  						;  + (#+1 64K sys ram) *    4.
   108                              <2> ;  						;  + (init crt mode ) *    16.
   109                              <2> ;  						;  + (# of floppies ) *    64.
   110                              <2> ;  						;  + (# serial ports) *   512.
   111                              <2> ;  						;  + (1 iff toy port) *  4096.
   112                              <2> ;                                               ;  + (1 iff modem   ) *  8192.
   113                              <2> ;  						;  + (# parallel LPT) * 16384.
   114 00000012 ??                  <2> mfg_test_flags  resb    1	;*/	byte	mfg_test_flags;	/* 40:12 unused by us
   115 00000013 ????                <2> memory_size     resw    1	;*/	word	memory_size;	/* 40:13 kilobytes
   116                              <2> uart_kbd_ctrl_R	equ	$	;*/				/*** JRC: count of ctrl-R's for reboot
   117 00000015 ??                  <2> IPL_errors      resb    1	;*/	byte	IPL_errors;	/* 40:15 IPL errors<-table/scratchpad
   118 00000016 ??                  <2> sbc188_rev       resb    1	;*/	byte	sbc188_rev;	/* was 'unused_01' before BIOS047
   119                              <2> ;;---------------[Keyboard data area]------------;
   120 00000017 ????                <2> keyboard_flags_0 resw   1	;*/	word	keyboard_flags_0;  /* 40:17 Shift/Alt/etc. keyboard flags
   121                              <2> keyboard_flags_1 equ	$-1	;     2nd byte	keyboard_flags_1;  
   122 00000019 ??                  <2> keypad_char	resb	1	;*/	byte	keypad_char;	/* 40:19 Alt-KEYPAD char. goes here
   123 0000001A ????                <2> kbd_buffer_head resw    1	;*/	word	kbd_buffer_head;   /* 40:1A --> keyboard buffer head
   124 0000001C ????                <2> kbd_buffer_tail resw    1	;*/	word	kbd_buffer_tail;   /* 40:1C --> keyboard buffer tail
   125 0000001E <res 20h>           <2> kbd_buffer      resw    16	;*/	word	kbd_buffer[16];	/* 40:1E Keyboard Buffer (Scan,Value)
   126                              <2> kbd_buffer_last	equ	$	;*/				/*
   127                              <2> ;;---------------[Diskette data area]------------;
   128 0000003E ??                  <2> fdc_drv_calib   resb    1	;*/	byte	fdc_drive_calib;   /* 40:3E
   129 0000003F ??                  <2> fdc_motor_LDOR  resb    1	;*/	byte	fdc_motor_LDOR;	   /* 40:3F Motor, DMA, select control
   130 00000040 ??                  <2> fdc_motor_ticks resb    1	;*/	byte	fdc_motor_ticks;   /* 40:40 ticks til motor off
   131 00000041 ??                  <2> fdc_status      resb    1	;*/	byte	fdc_status;	   /* 40:41
   132                              <2> ;				Floppy return code stat byte
   133                              <2> ;				;  1 = bad ic 765 command req.
   134                              <2> ;				;  2 = address mark not found
   135                              <2> ;				;  3 = write to protected disk
   136                              <2> ;				;  4 = sector not found
   137                              <2> ;				;  8 = data late (DMA overrun)
   138                              <2> ;				;  9 = DMA failed 64K page end
   139                              <2> ;				; 16 = bad CRC on floppy read
   140                              <2> ;				; 32 = bad NEC 765 controller
   141                              <2> ;				; 64 = seek operation failed
   142                              <2> ;				;128 = disk drive timed out
   143 00000042 ??????????????      <2> fdc_ctrl_status resb    7	;*/	byte	fdc_ctrl_status[7];  /* 40:42 Status bytes from NEC 765
   144                              <2> ;;---------------[Video display area]------------;
   145 00000049 ??                  <2> video_mode      resb    1	;*/	byte	video_mode;	/* 40:49
   146                              <2> ;			 	; Current CRT mode  (software)
   147                              <2> ;				;  0 = 40 x 25 text (no color)
   148                              <2> ;				;  1 = 40 x 25 text (16 color)
   149                              <2> ;				;  2 = 80 x 25 text (no color)
   150                              <2> ;				;  3 = 80 x 25 text (16 color)
   151                              <2> ;				;  4 = 320 x 200 grafix 4 color
   152                              <2> ;				;  5 = 320 x 200 grafix 0 color
   153                              <2> ;				;  6 = 640 x 200 grafix 0 color
   154                              <2> ;				;  7 = 80 x 25 text (mono card)
   155 0000004A ????                <2> video_columns   resw    1	;*/	word video_columns;	/* 40:4A Columns on CRT screen
   156 0000004C ????                <2> video_regen_bytes  resw 1	;*/	word video_regen_bytes;	/* 40:4C Bytes in the regen region
   157 0000004E ????                <2> video_regen_offset resw 1	;*/	word video_regen_offset;/* 40:4E Byte offset in regen region
   158 00000050 <res 10h>           <2> video_cursor_pos  resw  8	;*/	word video_cursor_pos[8];  /* 40:50 Cursor pos for up to 8 pages
   159 00000060 ????                <2> video_cursor_mode resw  1	;*/	word video_cursor_mode;	/* 40:60 Current cursor mode setting
   160 00000062 ??                  <2> video_page      resb    1	;*/	byte video_page;	/* 40:62 Current page on display
   161 00000063 ????                <2> video_base_seg  resw    1	;*/	word video_base_seg;	/* 40:63 Base address (B000h or B800h)
   162 00000065 ??                  <2> video_hw_mode   resb    1	;*/	byte video_hw_mode;	/* 40:65 ic 6845 mode reg. (hardware)
   163 00000066 ??                  <2> video_cga_palette resb  1	;*/	byte video_cga_palette;	/* 40:66 Current CGA palette
   164                              <2> ;;---------------[Used to setup ROM]-------------;
   165 00000067 ????????            <2> eprom_address   resd    1	;*/	dword eprom_address;	/* 40:67 Eprom base Offset,Segment
   166 0000006B ??                  <2> spurious_irq    resb    1	;*/	byte spurious_irq;	/* 40:6B Last spurious interrupt IRQ
   167                              <2> ;;---------------[Timer data area]---------------;
   168 0000006C ????????            <2> timer_ticks     resd    1	;*/	dword timer_ticks;	/* 40:6C Ticks since midnight (lo,hi)
   169 00000070 ??                  <2> timer_new_day   resb    1	;*/	byte timer_new_day;	/* 40:70 Non-zero if new day
   170                              <2> ;;---------------[System data area]--------------;
   171 00000071 ??                  <2> break_flag      resb    1	;*/	byte break_flag;	/* 40:71 Sign bit set iff break
   172 00000072 ????                <2> warm_boot       resw    1	;*/	word warm_boot;		/* 40:72 Warm boot iff==1234h
   173                              <2> ;;---------------[Hard disk scratchpad]----------;
   174 00000074 ????????            <2> hdd_scratch     resd    1	;*/	word hdd_scratch[2];	/* 40:74
   175                              <2> ;;---------------[Timout areas/PRT/LPT]----------;
   176 00000078 ????????            <2> lpt_timeout     resb    4	;*/	byte lpt_timeout[4];	/* 40:78 Ticks for LPT 1-4 timeouts
   177 0000007C ????????            <2> com_timeout     resb    4	;*/	byte com_timeout[4];	/* 40:7C Ticks for COM 1-4 timeouts
   178                              <2> ;;---obsolete----[Keyboard buf start/end]---jrc--;
   179 00000080 ????                <2> kbd_buffer_start resw   1	;*/	word kbd_buffer_start;	/* 40:80 KBD buffer head (PC/AT)
   180 00000082 ????                <2> kbd_buffer_end  resw    1	;*/	word kbd_buffer_end;	/* 40:82 KBD buffer tail (PC/AT)
   181                              <2> ;;---------------[EGA stuff]---------------------;
   182 00000084 ??????????????      <2> EGA_stuff	resb	7	;*/	byte EGA_stuff[7];	/* 40:84 Unspecified EGA data
   183                              <2> ;;---------------[Floppy/Fixed Media Info]-------------;
   184 0000008B ??                  <2> fdc_last_rate	resb	1	;*/	byte fdc_last_rate;	/* 40:8B Last floppy step rate/data rate?
   185 0000008C ????????            <2> fx_misc_unused	resb	4	;*/	byte fx_misc_unused[4];	/* 40:8C Fixed disk miscellaneous ???
   186 00000090 ????                <2> fdc_disk_state	resb	2	;*/	byte fdc_disk_state[2];	/* 40:90 Floppy disk state
   187 00000092 ????                <2> fdc_op_start	resb	2	;*/	byte fdc_op_start[2];	/* 40:92 Floppy operation start state machine
   188 00000094 ????                <2> fdc_cylinder	resb	2	;*/	byte fdc_cylinder[2];	/* 40:94 Floppy present cylinder
   189                              <2> ;;---------------[Additional KBD flags]----------------;
   190 00000096 ??                  <2> kbd_flag_3	resb	1	;*/	byte kbd_flag_3;	/* 40:96 kbd ???
   191 00000097 ??                  <2> kbd_flag_2	resb	1	;*/	byte kbd_flag_2;	/* 40:97 kbd ???
   192                              <2> ;;---------------[RTC/timer1 data]---------------------;
   193 00000098 ????????            <2> user_semaphore	resw	2	;*/	byte *user_semaphore;	/* 40:98 User semaphore in (bit 7)
   194 0000009C ????????            <2> rtc_count	resd	1	;*/	dword rtc_count;	/* 40:9C RTC tick counter
   195 000000A0 ??                  <2> rtc_wait_active	resb	1	;*/	byte rtc_wait_active;	/* 40:A0 Busy=01, Posted=80h, 
   196                              <2> ;;---------------[Cassette I/O stuff]------------------;
   197 000000A1 ??                  <2> last_val	resb	1	;*/	byte last_val;		/* 40:A1 Last byte read value
   198 000000A2 ????                <2> crc_reg		resw	1	;*/	word crc_reg;		/* 40:A2 CRC accumulation area
   199                              <2> ;									Post Acknowleged=00;
   200 000000A4 ??                  <2> EGA_data	resb	1	;*/	byte EGA_data;		/* 40:A4 Various usage
   201 000000A5 ????                <2> SDstatus	resb	2	;*/	byte SDstatus[2];	/* 40:A5 Status byte from command
   202 000000A7 ????                <2> SDcardtype	resb	2	;*/	byte SDcardtype[2];	/* 40:A7 SDcard type SDSC=2, HC=3, ...
   203                              <2> ;
   204 000000A9 ????????            <2> fixed_disk_tab	resb	4	;*/	byte fixed_disk_tab[4];	/* dispatch table to fixed disk drivers
   205 000000AD ??                  <2> wait12_count	resb	1	;*/	byte wait12_count;	/* 40:AD 12usec CX count
   206 000000AE ??                  <2> lock_count	resb	1	;*/	byte lock_count;	/* 40:AE lock level counter
   207 000000AF ??                  <2> EMS_start       resb    1	;*/	byte EMS_start;		/* start EMS allocation from here
   208                              <2> fx80		equ	$	;*/	struct EDD_disk fx80;	/* fixed disk parameter area 0
   209 000000B0 ????                <2> fx_log_cylinders resw   1	;	word fx_log_cylinders;	 logical number of cylinders
   210 000000B2 ??                  <2> fx_log_heads    resb    1	;	byte fx_log_heads;	 logical number of heads
   211 000000B3 ??                  <2> fx_signature	resb	1	;	byte fx_signature;	 A0h signature = translated geom
   212 000000B4 ??                  <2> fx_phys_sectors	resb    1       ;	byte fx_phys_sectors;	 physical number of sectors per track
   213 000000B5 ????                <2> fx_LBA_high     resw    1       ;	word fx_LBA_high;	 high word of LBA28 number of sectors
   214 000000B7 ??                  <2> fx_reserved	resb	1	;	byte fx_reserved;	 reserved for future use
   215 000000B8 ??                  <2> fx_drive_control resb   1       ;	byte fx_drive_control;	 flag bits for IDE head register
   216 000000B9 ????                <2> fx_phys_cylinders resw	1	;	word fx_phys_cylinders;	 physical number of cylinders
   217 000000BB ??                  <2> fx_phys_heads	resb	1	;	byte fx_phys_heads;	 physical number of heads
   218 000000BC ????                <2> fx_LBA_low	resw	1	;	word fx_LBA_low;	 low word of LBA28 number of sectors
   219 000000BE ??                  <2> fx_log_sectors	resb	1	;	byte fx_log_sectors;	 logical number of sectors per track
   220 000000BF ??                  <2> fx_checksum	resb	1	;	byte fx_checksum;	 checksum, dunno how to compute
   221 000000C0 <res 10h>           <2> fx81            resb    16	;*/	struct EDD_disk fx81;	/* fixed disk parameter area 1
   222 000000D0 <res 10h>           <2> fx82            resb    16	;*/	struct EDD_disk fx82;	/* fixed disk parameter area 2
   223 000000E0 <res 10h>           <2> fx83            resb    16	;*/	struct EDD_disk fx83;	/* fixed disk parameter area 3
   224                              <2> ;
   225                              <2> ;
   226                              <2> 
   227 000000F0 ????                <2> FPEM_segment    resw    1       ;*/	word FPEM_segment;	/* FPEM data segment
   228                              <2> 
   229 000000F2 ????                <2> EBDA_paragraph  resw    1       ;*/	word EBDA_paragraph;	/* lowest EBDA paragraph
   230                              <2> 
   231 000000F4 ????                <2> dma0_cw         resw    1       ;*/	word dma0_cw;		/* end of dma control word
   232 000000F6 ????                <2> dma1_cw         resw    1       ;*/	word dma1_cw;		/*   ditto
   233                              <2> 
   234 000000F8 ????                <2> fdc_type	resb	2	;*/	byte fdc_type[2];	/* disk type in low nibble, alternate in hi nib 
   235                              <2> 
   236 000000FA ????????            <2> debug_static_ptr  resw	2	;*/	void *debug_static_ptr;	/* pointer to debug static area
   237                              <2> 
   238 000000FE ??                  <2> n_fixed_disks   resb    1       ;*/	byte n_fixed_disks;	/* number of fixed disks
   239                              <2> 
   240 000000FF ??                  <2> cpu_xtal        resb    1       ;*/	byte cpu_xtal;		/* CPU crystal frequency in Mhz 
   241                              <2> ;								   CPU clock is half of this
   242                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   243                              <2> ;
   244                              <2> ;  System configuration stuff below
   245                              <2> ;	c.f., CONFIG.ASM (ANSI.CFG, CVDU.CFG, etc.), User configuration stuff
   246                              <2> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                              <2> %if 0				;*/
   248                              <2> #define FIXED_DISK_MAX 4		/*
   249                              <2> %else
   250                              <2> %define FIXED_DISK_MAX 4
   251                              <2> %endif
   252                              <2> %if 0				;*/
   253                              <2> #define PPIDE_driver 1		/*
   254                              <2> %else
   255                              <2> %define PPIDE_driver 1
   256                              <2> %endif
   257                              <2> %if 0				;*/
   258                              <2> #define DIDE_driver 0		/*
   259                              <2> %else
   260                              <2> %define DIDE_driver 0
   261                              <2> %endif
   262                              <2> %if 0				;*/
   263                              <2> #define DISKIO_driver 1		/*
   264                              <2> %else
   265                              <2> %define DISKIO_driver 1
   266                              <2> %endif
   267                              <2> %if 0				;*/
   268                              <2> #define MFPIC_driver 1		/*
   269                              <2> %else
   270                              <2> %define MFPIC_driver 1
   271                              <2> %endif
   272                              <2> %if 0				;*/
   273                              <2> #define DSD_driver 1		/*
   274                              <2> %else
   275                              <2> %define DSD_driver 1
   276                              <2> %endif
   277                              <2> %if 0				;*/
   278                              <2> #define V3IDE8_driver (SBC188==3)		/*
   279                              <2> %else
   280                              <2> %define V3IDE8_driver (SBC188==3)
   281                              <2> %endif
   282                              <2> 				;*/
    74                              <1> 
    75                              <1> ;  this must be the same in EQUATES.H */
    76                              <1> %if SOFT_DEBUG
    77                              <1> %define NBREAK  8
    78                              <1> %endif
    79                              <1> 
    80                              <1> 
    81                              <1> %if 0
    82                              <1>         segment _TEXT
    83                              <1> ;; *************************************************************************
    84                              <1> 
    85                              <1> 
    86                              <1> 
    87                              <1> 
    88                              <1> ;; ************************ DOS Data Segment *******************************
    89                              <1> ;dosdir	SEGMENT at 50h				; Boot disk directory from IPL
    90                              <1> ;xerox	label	byte				;  0 if Print Screen idle
    91                              <1> ;						;  1 if PrtSc xeroxing screen
    92                              <1> ;						;255 if PrtSc error in xerox
    93                              <1> ;						;  ...non-grafix PrtSc in bios
    94                              <1> ;	db	200h dup(?)			; PC-DOS bootstrap procedure
    95                              <1> ;						;  ...IBMBIO.COM buffers the
    96                              <1> ;						;  ...directory of the boot
    97                              <1> ;						;  ...device here at IPL time
    98                              <1> ;						;  ...when locating the guts
    99                              <1> ;						;  ...of the operating system
   100                              <1> ;						;  ...filename "IBMDOS.COM"
   101                              <1> ;dosdir	ends
   102                              <1> ;; *************************************************************************
   103                              <1> ;; ************************ DOS IPL Segment ********************************
   104                              <1> ;dosseg	SEGMENT at 70h				; "Kernel" of PC-DOS op sys
   105                              <1> ;;IBMBIO.COM file loaded by boot block. Device Drivers/Bootstrap. CONTIGUOUS<---
   106                              <1> ;;IBMDOS.COM operating system nucleus immediately follows IBMBIO.COM and       !
   107                              <1> ;;     doesn`t have to be contiguous.  The IBMDOS operating system nucleus     !
   108                              <1> ;;     binary image is loaded by transient code in IBMBIO binary image	      !
   109                              <1> ;dosseg	ends					;			      !
   110                              <1> ;iplseg	SEGMENT at 0h				; Segment for boot block      !
   111                              <1> ;;The following boot block is loaded with 512 bytes on the first sector of     !
   112                              <1> ;;the bootable device by code resident in the ROM-resident bios.  Control is   !
   113                              <1> ;;then transferred to the first word 0000:7C00 of the disk-resident bootstrap  !
   114                              <1> ;	ORG	07C00h				;  ..offset for boot block    !
   115                              <1> ;boot	db	200h dup(?)			;  ..start disk resident boot--
   116                              <1> ;iplseg	ends
   117                              <1> 
   118                              <1> %endif
    26                                  
    27                                  %define QUICK_VERIFY 1
    28                                  %define DEBUG 0
    29                                  %include	"sdcard.inc"
    30                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    31                              <1> ; SDcard.INC -- include file for Basic I/O routines for the Dual SDcard
    32                              <1> ;		add-on board
    33                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    34                              <1> ;
    35                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
    36                              <1> ;
    37                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
    38                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
    39                              <1> ;
    40                              <1> ; This program is free software: you can redistribute it and/or modify
    41                              <1> ; it under the terms of the GNU General Public License as published by
    42                              <1> ; the Free Software Foundation, either version 3 of the License, or
    43                              <1> ; (at your option) any later version.
    44                              <1> ;
    45                              <1> ; This program is distributed in the hope that it will be useful,
    46                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    47                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    48                              <1> ; GNU General Public License for more details.
    49                              <1> ;
    50                              <1> ; You should have received a copy of the GNU General Public License
    51                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    52                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    53                              <1> ;
    54                              <1> ;;;	cpu	186
    55                              <1> 
    56                              <1> %define	dev_SDcard	08h		; Dual SD card board device code
    57                              <1> 
    58                              <1> %define Z80	1
    59                              <1> %define SBC188	2
    60                              <1> %define M68K	3
    61                              <1> 
    62                              <1> %define TRUE	1
    63                              <1> %define FALSE	0
    64                              <1> 
    65                              <1> %if 0
    66                              <1>  %define CPU	SBC188
    67                              <1> 
    68                              <1>  %if	CPU==Z80
    69                              <1>   IO_BASE		equ	0
    70                              <1>  %elif	CPU==SBC188
    71                              <1>   IO_BASE		equ	0400h
    72                              <1>  %elif	CPU=M68K
    73                              <1>   IO_BASE		equ	0FFFF8000h
    74                              <1>  %else
    75                              <1>   IO_BASE		equ	0
    76                              <1>  %endif
    77                              <1> %endif
    78                              <1> 
    79                              <1> 
    80                              <1> SDoperation	equ	dev_SDcard + IO_BASE
    81                              <1> SDselect	equ	SDoperation + 1
    82                              <1> 
    83                              <1> 
    84                              <1> 
    85                              <1> ; Operation register bits
    86                              <1> CardDetect	equ	20h		; read-only
    87                              <1> WrProt		equ	10h		; read-only
    88                              <1> ChipSelect	equ	04h		; bit 2 (through an inverter)
    89                              <1> Clock		equ	02h		; bit 1
    90                              <1> DataIn		equ	01h
    91                              <1> DataOut		equ	01h		; all Data I/O through bit 0
    92                              <1> 
    93                              <1> ; Select register bits
    94                              <1> Unit		equ	01h		; read/write
    95                              <1> UnitMask	equ	Unit
    96                              <1> 
    97                              <1> WrProt0		equ	04h		; read-only
    98                              <1> WrProt1		equ	08h		; read-only
    99                              <1> 
   100                              <1> CardDetect0	equ	10h		; read/write	(ChangeBit must be set)
   101                              <1> CardDetect1	equ	20h		; read/write	( ditto )
   102                              <1> 
   103                              <1> IntEnable	equ	40h		; write-only	(ChangeBit must be set)
   104                              <1> ChangeBit	equ	80h		; write-only
   105                              <1> Pend0		equ	40h		; read-only
   106                              <1> Pend1		equ	80h		; read-only
   107                              <1> PendMask	equ	Pend0 | Pend1
   108                              <1> 
   109                              <1> CDupdateMask	equ	CardDetect1 | CardDetect0 | UnitMask
   110                              <1> 
   111                              <1> 
   112                              <1> ; Card types:
   113                              <1> SDtypeUnk	equ	0		; unknown card type
   114                              <1> SDtypeMMC	equ	1		; old MMC card
   115                              <1> SDtypeSDSC 	equ	2		; standard card
   116                              <1> SDtypeSDHC	equ	3		; HC card
   117                              <1> 
   118                              <1> 
   119                              <1> %if 1
   120                              <1> ; for the Tiny, Small, or Compact models:
   121                              <1> %define ARG(n) [bp+2+(n)*2]
   122                              <1> %endif
    30                                  
    31                                  ; Do we use CRC's with commands and data transfers?
    32                                  %define USE_CRCs	TRUE
    33                                  
    34                                          global  SDcard_BIOS_call_13h
    35                                          extern  @mulLS
    36                                          extern  microsecond
    37                                  
    38                                  	SEGMENT	_TEXT
    39                                  
    40                                  Zero:
    41                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    42                                  ;  BIOS call entry for Dual SD Card driver
    43                                  ;       int  13h
    44                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
    45                                  SDcard_BIOS_call_13h:           ; SDcard driver entry
    46 00000000 FB                              sti                     ; Enable interrupts
    47 00000001 061E60                          pushm   all,ds,es       ; Standard register save
    48 00000004 89E5                            mov     bp,sp           ; establish stack addressing
    49 00000006 6A40                            push    bios_data_seg
    50 00000008 1F                              popm    ds              ; establish addressability
    51 00000009 FC                              cld
    52                                  ; above done in general Fixed disk entry point
    53                                  
    54                                  
    55                                  	global	DSD_entry
    56                                  DSD_entry:
    57                                  %if SOFT_DEBUG & 0
    58                                  	int 5
    59                                  %endif
    60 0000000A 30FF                            xor     bh,bh           ; zero extend byte
    61 0000000C 88E3                            mov     bl,ah           ; set to index into dispatch table
    62 0000000E 80FC19                          cmp     ah,max/2
    63 00000011 7307                            jae     try_extended
    64 00000013 D1E3                            shl     bx,1            ; index words
    65                                  
    66 00000015 2EFFA7[3F00]                cs  jmp     near [dispatch+bx]
    67                                  
    68                                  try_extended:
    69 0000001A 80EB41                          sub     bl,41h          ; start of extended calls
    70 0000001D 80FB0E                          cmp     bl,max41/2
    71 00000020 7307                            jae     undefined
    72 00000022 D1E3                            shl     bx,1            ; index word addresses
    73 00000024 2EFFA7[7100]                cs  jmp     near [dispatch41+bx]
    74                                  
    75                                  
    76                                  ;fn00:           ; Reset Disk System
    77                                  fn01:           ; Get Disk System Status
    78                                  ;fn02:           ; Read Sector
    79                                  ;fn03:           ; Write Sector
    80                                  ;fn04:           ; Verify Sector
    81                                  fn05:           ; Format Track
    82                                  fn06:           ; Format Bad Track (fixed disk) [PC]
    83                                  fn07:           ; Format Drive (fixed disk)     [PC]
    84                                  ;fn08:           ; Get Drive Parameters
    85                                  fn09:           ; Initialize Fixed Disk Characteristics [PC,AT,PS/2]
    86                                  fn0A:           ; Read Sector Long (fixed disk) [PC,AT,PS/2]
    87                                  fn0B:           ; Write Sector Long (fixed disk) [PC,AT,PS/2]
    88                                  fn0C:           ; Seek (fixed disk)
    89                                  fn0D:           ; Reset Fixed Disk System
    90                                  fn0E:           ; Read Sector Buffer (fixed disk) [PC only]
    91                                  fn0F:           ; Write Sector Buffer (fixed disk) [PC only]
    92                                  fn10:           ; Get Drive Status (fixed disk)
    93                                  fn11:           ; Recalibrate Drive (fixed disk)
    94                                  fn12:           ; Controller RAM Diagnostic (fixed disk) [PC/XT]
    95                                  fn13:           ; Controller Drive Diagnostic (fixed disk) [PC/XT]
    96                                  fn14:           ; Controller Internal Diagnostic (fixed disk) [PC,AT,PS/2]
    97                                  ;fn15:           ; Get Disk Type                 [AT]
    98                                  fn16:           ; Get Disk Change Status (floppy)
    99                                  fn17:           ; Set Disk Type (floppy)
   100                                  fn18:           ; Set Media Type for Format (floppy)
   101                                  
   102                                  ;fn41:           ; Check Extensions Present
   103                                  ;fn42:           ; Extended Read
   104                                  ;fn43:           ; Extended Write
   105                                  ;fn44:           ; Extended Verify
   106                                  fn45:           ; Lock/Unlock Drive
   107                                  fn46:           ; Eject Drive
   108                                  ;fn47:           ; Extended Seek
   109                                  ;fn48:           ; Get Drive Parameters
   110                                  fn49:           ; Get Extended Disk Change Status
   111                                  ;fn4E:           ; Set Hardware Configuration
   112                                  
   113                                  undefined:
   114                                  %if SOFT_DEBUG & 0
   115                                          int 5
   116                                  %endif
   117 00000029 B401                            mov     ah,ERR_invalid_command     ; Invalid command
   118 0000002B EB06                    	jmp	error_exit
   119                                  
   120                                  good_exit:
   121 0000002D 30E4                    	xor	ah,ah			; clear the carry, AH=0
   122                                  exit_sequence:
   123 0000002F 08E4                            or      ah,ah
   124 00000031 7401                            jz     exit_pops
   125                                  error_exit:
   126 00000033 F9                      	stc				; set the carry
   127                                  exit_pops:
   128 00000034 88660F                          mov     [bp+offset_AH],ah          ; set the error code
   129 00000037 89EC                            mov     sp,bp			; deallocate any variables
   130 00000039 611F07                          popm    ALL,ds,es
   131                                  %if SOFT_DEBUG & 0
   132                                  	int 5
   133                                  %endif
   134 0000003C CA0200                          retf	2			; rather than IRET
   135                                  
   136                                  
   137                                  dispatch:
   138 0000003F [E907]                          dw      fn00    ; Reset Disk System
   139 00000041 [2900]                          dw      fn01    ; 
   140 00000043 [F407]                          dw      fn02
   141 00000045 [F407]                          dw      fn03
   142 00000047 [F407]                          dw      fn04
   143 00000049 [2900]                          dw      fn05
   144 0000004B [2900]                          dw      fn06
   145 0000004D [2900]                          dw      fn07
   146 0000004F [4008]                          dw      fn08
   147 00000051 [2900]                          dw      fn09
   148 00000053 [2900]                          dw      fn0A
   149 00000055 [2900]                          dw      fn0B
   150 00000057 [2900]                          dw      fn0C
   151 00000059 [2900]                          dw      fn0D
   152 0000005B [2900]                          dw      fn0E
   153 0000005D [2900]                          dw      fn0F
   154 0000005F [2900]                          dw      fn10
   155 00000061 [2900]                          dw      fn11
   156 00000063 [2900]                          dw      fn12
   157 00000065 [2900]                          dw      fn13
   158 00000067 [2900]                          dw      fn14
   159 00000069 [6908]                          dw      fn15
   160 0000006B [2900]                          dw      fn16
   161 0000006D [2900]                          dw      fn17
   162 0000006F [2900]                          dw      fn18
   163                                  max     equ     $-dispatch
   164                                  
   165                                  dispatch41:
   166 00000071 [8C08]                          dw      fn41
   167 00000073 [B308]                          dw      fn42
   168 00000075 [B308]                          dw      fn43
   169 00000077 [B308]                          dw      fn44
   170 00000079 [2900]                          dw      fn45
   171 0000007B [2900]                          dw      fn46
   172 0000007D [B308]                          dw      fn47
   173 0000007F [F008]                          dw      fn48
   174 00000081 [2900]                          dw      fn49
   175 00000083 [2900]                          dw      undefined       ; 4A
   176 00000085 [2900]                          dw      undefined       ; 4B
   177 00000087 [2900]                          dw      undefined       ; 4C
   178 00000089 [2900]                          dw      undefined       ; 4D
   179 0000008B [6509]                          dw      fn4E
   180                                  max41   equ     $-dispatch41
   181                                  
   182                                  
   183                                  
   184                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   185                                  ; SDsetunit	set the selected unit (0 or 1) in DI and in SDselect reg.
   186                                  ;
   187                                  ;  Enter with:
   188                                  ;	DS =	Bios Data Area pointer is set
   189                                  ;	DL =	hard drive specifier (80h..83h)
   190                                  ;
   191                                  ;  Return with:
   192                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   193                                  ;	All other registers preserved, including AX
   194                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   195                                  SDsetunit:
   196 0000008D 89D7                    	mov	di,dx			; device code to DI
   197 0000008F 83E703                  	and	di,FIXED_DISK_MAX-1	; mask device code
   198 00000092 8BBDA900                	mov	di,[fixed_disk_tab+di]	; only the low byte matters
   199 00000096 83E701                  	and	di,UnitMask
   200 00000099 52                      	push	dx   			; save DX
   201 0000009A 97                      	xchg	ax,di			; save AX and DI
   202 0000009B BA0904                  	mov	dx,SDselect		; unit selection register
   203 0000009E EE                      	out	dx,al			; select unit 0 or 1
   204 0000009F 97                      	xchg	ax,di			; restore AX and DI
   205 000000A0 5A                      	pop	dx			; restore DX
   206 000000A1 C3                      	ret
   207                                  
   208                                  
   209                                  
   210                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   211                                  ; SDgetunit	get the selected unit# in DI
   212                                  ;
   213                                  ;  Enter with:
   214                                  ;	Nothing
   215                                  ;
   216                                  ;  Return with:
   217                                  ;	DI = 	unit number selected in the h/w (0 or 1)
   218                                  ;	DX =	Operation Register device code
   219                                  ;	All other registers preserved, including AX
   220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   221                                  SDgetunit:
   222 000000A2 97                      	xchg	ax,di		; save AX in DI
   223 000000A3 BA0904                  	mov	dx,SDselect	; get Select register device code
   224 000000A6 EC                      	in	al,dx
   225 000000A7 83E001                  	and	ax,UnitMask
   226 000000AA 97                      	xchg	ax,di		; set DI, restore AX
   227 000000AB 4A                      	dec	dx		; set Operation Register device code
   228 000000AC C3                      	ret
   229                                  
   230                                  
   231                                  
   232                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   233                                  ; SDputchar	Put a byte to DATIN on the SD card
   234                                  ;
   235                                  ;  Enter with:
   236                                  ;	AL = byte to put out
   237                                  ;	DX = SDoperation register I/O device code
   238                                  ;  Assume:
   239                                  ;	Chip Select is already asserted
   240                                  ;	Clock may be high or low
   241                                  ;
   242                                  ;  Return with:
   243                                  ;	AX is trashed
   244                                  ;	Clock is deasserted, Chip Select is asserted
   245                                  ;
   246                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   247                                  	global	SDputchar
   248                                  SDputchar:
   249 000000AD 51                      	pushm	cx
   250                                  
   251 000000AE 88C4                    	mov	ah,al			; move character to AH
   252 000000B0 B90800                  	mov	cx,8			; count 8 bits
   253                                  
   254 000000B3 B002                    .1:	mov	al, ChipSelect / 2	; will shift it, no clock yet
   255 000000B5 D1C0                    	rol	ax,1			; rotate bit into register
   256 000000B7 EE                      	out	dx,al			; output data, no clock
   257 000000B8 0C02                    	or	al, Clock		; rising clock edge
   258 000000BA EE                      	out	dx,al			; 
   259 000000BB E2F6                    	loop	.1
   260                                  
   261 000000BD 24FD                    	and	al,~Clock
   262 000000BF EE                      	out	dx,al			; set clock low
   263                                  
   264 000000C0 59                      	popm	cx
   265 000000C1 C3                      	ret
   266                                  
   267                                  
   268                                  
   269                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   270                                  ; SDgetchar	Get a byte from DATOUT on the SD card
   271                                  ;
   272                                  ;  Enter with:
   273                                  ;	DX = SDoperation register I/O device code
   274                                  ;  Assume:
   275                                  ;	Chip Select is already asserted
   276                                  ;	Clock is low
   277                                  ;
   278                                  ;  Return with:
   279                                  ;	AL = the byte received
   280                                  ;	AH = copy of AL
   281                                  ;	Clock is low, Chip Select is still asserted
   282                                  ;
   283                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   284                                  	global	SDgetchar
   285                                  SDgetchar:
   286 000000C2 51                      	push	cx
   287                                  
   288 000000C3 B005                    	mov	al, ChipSelect | DataIn
   289 000000C5 EE                      	out	dx,al			; set clock low
   290                                  
   291 000000C6 B90800                  	mov	cx,8			; count 8 bits
   292 000000C9 EC                      .1:	in	al,dx			; get input bit
   293 000000CA D0E8                    	shr	al,1
   294 000000CC D0D4                    	rcl	ah,1			; bit into AH
   295 000000CE B007                    	mov	al,ChipSelect | Clock | DataIn
   296 000000D0 EE                      	out	dx,al			; acknowledge receipt of bit
   297 000000D1 B005                    	mov	al, ChipSelect | DataIn		; no clock
   298 000000D3 EE                      	out	dx,al
   299 000000D4 E2F3                    	loop	.1
   300                                  
   301 000000D6 88E0                    	mov	al,ah			; return byte in AL
   302 000000D8 59                      	pop	cx
   303 000000D9 C3                      	ret
   304                                  
   305                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   306                                  ; spin		apply clock pulses to the SD card
   307                                  ;
   308                                  ;  Enter with:
   309                                  ;	CX = character count to spin
   310                                  ;
   311                                  ;  Exit with:
   312                                  ;	AX is trashed
   313                                  ;	CX = 0
   314                                  ;	DX = SDoperation register I/O device code
   315                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   316                                  spin:
   317 000000DA BA0804                  	mov	dx,SDoperation
   318 000000DD B0FF                    .1:	mov	al,-1
   319 000000DF E8CBFF                  	call	SDputchar
   320 000000E2 E2F9                      	loop	.1
   321 000000E4 C3                       	ret
   322                                  
   323                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   324                                  ; SDsendclks	send clock transitions to the card
   325                                  ;
   326                                  ;  Enter with:
   327                                  ;	AL = initial state of bits to bang
   328                                  ;	CX = transition count
   329                                  ;	DX = card Operation Register device code
   330                                  ;
   331                                  ;  Return with:
   332                                  ;	AL modified
   333                                  ;	CX = 0
   334                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   335                                  SDsendclks:
   336 000000E5 EE                      .1:	out	dx,al		; put out state of bits specified
   337 000000E6 3402                    	xor	al,Clock
   338 000000E8 E2FB                    	loop	.1
   339 000000EA EE                      	out	dx,al		; put out last transition
   340 000000EB C3                      	ret
   341                                  
   342                                  
   343                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   344                                  ; SDdone	complete a transaction
   345                                  ;
   346                                  ;  Enter with:
   347                                  ;	DX = Operation Register device code
   348                                  ;
   349                                  ;  Return with:
   350                                  ;	All registers are preserved
   351                                  ;	Flags are preserved, too
   352                                  ;
   353                                  ;	The card is deselected!!!
   354                                  ;
   355                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   356                                  SDdone:
   357 000000EC 9C5150                  	pushm	ax,cx,f
   358                                  
   359 000000EF B001                    	mov	al,DataIn	; no ChipSelect or Clock
   360 000000F1 B91000                  	mov	cx,16
   361 000000F4 E8EEFF                  	call	SDsendclks
   362                                  
   363 000000F7 58599D                  	popm	ax,cx,f
   364 000000FA C3                      	ret
   365                                  
   366                                  
   367                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   368                                  ; SDwaitrdy	wait for card to become ready
   369                                  ;
   370                                  ;  Enter with:
   371                                  ;	DX = Operation Register device code
   372                                  ;
   373                                  ;  Return with:
   374                                  ;	Carry = 0	Clear means no error	(AL = 0)
   375                                  ;	Carry = 1	Set means error		(AL = 0xFF)
   376                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   377                                  SDwaitrdy:
   378 000000FB 51                      	pushm	cx
   379                                  
   380 000000FC B005                    	mov	al, ChipSelect | DataIn
   381 000000FE EE                      	out	dx,al		; set clock to 0
   382                                  
   383 000000FF B9FF7F                  	mov	cx,7FFFh
   384                                  .1:
   385 00000102 E8BDFF                  	call	SDgetchar
   386 00000105 FEC0                    	inc	al		; 0FFh -> 00h
   387 00000107 7407                    	jz	.9
   388 00000109 E2F7                    	loop	.1
   389                                  
   390 0000010B FEC8                    	dec	al		; return error byte
   391 0000010D F9                      	stc			; flag error
   392 0000010E EB01                    	jmp	.99		; error exit
   393                                  
   394 00000110 F8                      .9:	clc			; clear the carry
   395 00000111 98                      .99:	cbw			; extend byte to full word
   396 00000112 59                      	popm	cx
   397 00000113 C3                      	ret
   398                                  	
   399                                  
   400                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   401                                  ; SDgoidle	put card in the idle state
   402                                  ;
   403                                  ;  Enter with:
   404                                  ;	DX	Operation register device code
   405                                  ;
   406                                  ;  Return with:
   407                                  ;	AX	response to CMD0
   408                                  ;	Zero flag is set by compare to '01'
   409                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   410                                  SDgoidle:
   411 00000114 B98813                  	mov	cx,5000		; about 5 milliseconds
   412 00000117 90                      .0:	nop
   413 00000118 E2FD                    	loop	.0
   414                                  
   415 0000011A BE[7002]                	mov	si,CMD0
   416 0000011D 0E                      	pushm	cs
   417 0000011E 07                      	popm	es
   418 0000011F E81D02                  	call	cmd_R1
   419                                  
   420 00000122 E8C7FF                  	call	SDdone
   421 00000125 7402                    	jz	.5
   422 00000127 3C01                    	cmp	al,01h
   423                                  .5:
   424 00000129 C3                      	ret
   425                                  
   426                                  
   427                                  
   428                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   429                                  ; SDcmdset	set up a command with parameters
   430                                  ;
   431                                  ;  Enter with:
   432                                  ;	BL	command byte (40h | ??)
   433                                  ;	DX:AX	4-byte parameter, DH is ms-byte, AL is ls-byte
   434                                  ;
   435                                  ;  Exit with:
   436                                  ;	SP	decreased by 6 bytes
   437                                  ;	ES:SI	(or SS:SP) points at command in the stack
   438                                  ;	AX,BX,CX  are all trashed
   439                                  ;	DX	is reset to Operation register device code
   440                                  ;
   441                                  ;  After the command is executed, the stack is cleared with
   442                                  ;	ADD	SP,6
   443                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   444                                  SDcmdset:
   445 0000012A 59                      	pop	cx		; pop return address
   446                                  
   447                                  ;  bl:dh:dl:ah:al:FF
   448 0000012B 86D3                    	xchg	dl,bl
   449                                  ;  dl:dh:bl:ah:al:FF
   450 0000012D 86C3                    	xchg	al,bl
   451                                  ;  dl:dh:al:ah:bl:FF
   452                                  ;;;	mov	bh,0FFh
   453                                  ;  dl:dh:al:ah:bl:bh
   454 0000012F 53                      	push	bx
   455 00000130 50                      	push	ax
   456 00000131 52                      	push	dx
   457 00000132 89E6                    	mov	si,sp
   458 00000134 16                      	pushm	ss
   459 00000135 07                      	popm	es
   460 00000136 51                      	push	cx		; reset return address
   461                                  %if USE_CRCs
   462 00000137 B90500                  	mov	cx,5		; CRC7 for 5 bytes
   463 0000013A E8F201                  	call	calcCRC7
   464 0000013D 268804                    es	mov	[si],al		; store the CRC7
   465 00000140 83EE05                  	sub	si,5		; reset SI to point at CMD string
   466                                  %endif
   467 00000143 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   468 00000146 C3                      	ret
   469                                  
   470                                  
   471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   472                                  ; SDcmdset0	set up a command with no parameters
   473                                  ;
   474                                  ;  Enter with:
   475                                  ;	AL	command code
   476                                  ;
   477                                  ;  Return with:
   478                                  ;	SP	decreased by 6 bytes
   479                                  ;	ES:SI	(or SS:SP) points at command in the stack
   480                                  ;	DX	is reset to Operation register device code
   481                                  ;	AX	is destroyed
   482                                  ;
   483                                  ;  After the command is executed, the stack is cleared with
   484                                  ;	ADD	SP,6
   485                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   486                                  SDcmdset0:
   487 00000147 5A                      	pop	dx		; save return address
   488 00000148 6A00                    	push	0		; push 0,CRC
   489 0000014A 6A00                    	push	0		; push 0,0
   490 0000014C 30E4                    	xor	ah,ah
   491 0000014E 50                      	push	ax		; push CMDx,0
   492                                  	
   493 0000014F 89E6                    	mov	si,sp		; set DS:SI to point at command
   494 00000151 16                      	pushm	ss
   495 00000152 07                      	popm	es
   496 00000153 52                      	push	dx		; push return address
   497                                  
   498                                  %if USE_CRCs
   499 00000154 5651                    	pushm	cx,si
   500 00000156 B90500                  	mov	cx,5		; CRC7 for 5 bytes
   501 00000159 E8D301                  	call	calcCRC7
   502 0000015C 8804                    	mov	[si],al		; store the CRC7
   503 0000015E 595E                    	popm	cx,si		; DS:SI set, DX=Oper. reg
   504                                  %endif
   505 00000160 BA0804                  	mov	dx,SDoperation	; set for Operation Register device code
   506 00000163 C3                      	ret
   507                                  
   508                                  
   509                                  
   510                                  
   511                                  
   512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   513                                  ; SDinit	initialize card status to "init required"
   514                                  ;
   515                                  ;  Enter with:
   516                                  ;	nothing
   517                                  ;
   518                                  ;  Return with:
   519                                  ;	nothing
   520                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   521                                  	global	@SDinit		; C-fastcall
   522                                  @SDinit:
   523                                  SDinit:
   524 00000164 1E                      	push	ds
   525 00000165 6A40                    	push	bios_data_seg
   526 00000167 1F                      	pop	ds
   527 00000168 C706A500FFFF            	mov	word [SDstatus], -1	; zap both status bytes to 0FFh
   528 0000016E 1F                      	pop	ds
   529 0000016F C3                      	ret
   530                                  
   531                                  
   532                                  
   533                                  
   534                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   535                                  ; SDinitcard	initialize a newly inserted SD card
   536                                  ;
   537                                  ;  Enter with:
   538                                  ;	AX = card selection (0 or 1)
   539                                  ;
   540                                  ;  Return with:
   541                                  ;	AX = status	(0 means success)
   542                                  ;	Zero flag reflects status
   543                                  ;
   544                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   545                                  	global	@SDinitcard		; C-fastcall
   546                                  @SDinitcard:
   547 00000170 1E525153                	pushm	bx,cx,dx,ds
   548 00000174 6A40                    	push	bios_data_seg		; get BDA on a C-call
   549 00000176 1F                      	pop	ds
   550 00000177 E80500                  	call	SDinitcard
   551 0000017A 5B595A1F                	popm	bx,cx,dx,ds
   552 0000017E C3                      	ret
   553                                  
   554                                  SDinitcard:
   555 0000017F 065756                  	pushm	si,di,es
   556                                  
   557 00000182 A9FEFF                  	test	ax,~UnitMask		; bits must not be set
   558 00000185 7403E9E000              	jnz	.error1
   559                                  
   560 0000018A BA0904                  	mov	dx,SDselect
   561 0000018D EE                      	out	dx,al			; select card  1 or 0
   562 0000018E 4A                      	dec	dx			; set to Operation Register
   563 0000018F 89C7                    	mov	di,ax			; set Unit Index
   564                                  
   565                                  ; Check for card present
   566 00000191 EC                      	in	al,dx			; read Operation register
   567 00000192 A820                    	test	al,20h			; test for Card Detect bit
   568 00000194 B8FCFF                  	mov	ax,-4			; error code for No Card inserted
   569 00000197 8885A500                	mov	[SDstatus + di],al	; say there is no card
   570 0000019B 7503E9C700              	jz	.error			; set error code & return
   571                                   
   572 000001A0 E849FF                  	call	SDdone			; seems to help some cards
   573                                  
   574 000001A3 B005                    	mov	al,ChipSelect | DataIn	; DataIn is into the SDcard
   575 000001A5 B90001                  	mov	cx,256			; 256 clock transitions
   576 000001A8 E83AFF                  	call	SDsendclks
   577                                  
   578 000001AB E84DFF                  	call	SDwaitrdy		; wait for card to go ready
   579 000001AE 7303E9AC00              	jc	.rdytimeout
   580                                  
   581                                  ;;;	call	SDgoidle
   582                                  ;;;	je	.okay
   583 000001B3 E85EFF                  	call	SDgoidle		; only 1 needed
   584                                  ;;	mov	ah,$-Zero
   585 000001B6 7403E9AC00              	jne	.error			; SDsendclks glitch fixed
   586                                  
   587 000001BB 0E                      	pushm	cs
   588 000001BC 07                      	popm	es
   589 000001BD BE[7602]                	mov	si,CMD8			; v.2 cards require CMD8
   590 000001C0 E87C01                  	call	cmd_R1
   591 000001C3 A8FE                    	test	al,~01h			; any error bits set (v.1 card)
   592 000001C5 750C                    	jnz	.0
   593 000001C7 E8F8FE                  	call	SDgetchar		; v.2 card returns 4 more bytes
   594 000001CA E8F5FE                  	call	SDgetchar
   595 000001CD E8F2FE                  	call	SDgetchar
   596 000001D0 E8EFFE                  	call	SDgetchar
   597                                  .0:
   598 000001D3 E816FF                  	call	SDdone
   599                                  
   600 000001D6 B9FF7F                  	mov	cx,7FFFh	; init try counter
   601                                  .1:
   602 000001D9 51                      	pushm	cx
   603 000001DA B98813                  	mov	cx,5000		; about 5 milliseconds
   604 000001DD 90                      .11:	nop
   605 000001DE E2FD                    	loop	.11		; delay loop
   606 000001E0 59                      	popm	cx
   607                                  
   608 000001E1 0E                      	pushm	cs
   609 000001E2 07                      	popm	es
   610 000001E3 BE[8E02]                	mov	si,CMD55
   611 000001E6 E85601                  	call	cmd_R1
   612 000001E9 E800FF                  	call	SDdone
   613 000001EC 7579                    	jnz	.error
   614 000001EE A8FE                    	test	al,~01h		; only 0 and 1 are okay responses
   615                                  ;;	mov	ah,$-Zero
   616 000001F0 7575                    	jnz	.error
   617                                  
   618 000001F2 BE[9402]                	mov	si,ACMD41
   619 000001F5 E84701                  	call	cmd_R1
   620 000001F8 E8F1FE                  	call	SDdone
   621 000001FB 08C0                    	or	al,al		; test for zero
   622 000001FD 7408                    	jz	.2
   623 000001FF FEC8                    	dec	al		; test for 1
   624                                  ;;	mov	ah,$-Zero
   625 00000201 7564                    	jnz	.error
   626 00000203 E2D4                    	loop	.1
   627                                  
   628 00000205 EB5D                    	jmp	.timeout
   629                                  
   630                                  .2:
   631                                  
   632 00000207 BE[9A02]                	mov	si,CMD58
   633 0000020A E83201                  	call	cmd_R1
   634 0000020D 754B                    	jnz	.err58			; must respond with a 00h
   635 0000020F E8B0FE                  	call	SDgetchar		; get command response
   636 00000212 B402                    	mov	ah,SDtypeSDSC		; assume standard card
   637 00000214 A840                    	test	al,40h			; test bit 30 of response
   638 00000216 7402                    	jz	.21
   639 00000218 B403                    	mov	ah,SDtypeSDHC		; set HC card type
   640 0000021A E885FE                  .21:	call	SDgetunit
   641 0000021D 88A5A700                	mov	[SDcardtype + di],ah	; set card type
   642                                  
   643 00000221 E89EFE                  	call	SDgetchar		; discard rest of the response
   644 00000224 E89BFE                  	call	SDgetchar		; 
   645 00000227 E898FE                  	call	SDgetchar		; 
   646 0000022A E8BFFE                  	call	SDdone
   647                                  
   648                                  %if USE_CRCs
   649 0000022D B80100                  	mov	ax,1			; turn on CRC checking
   650 00000230 31D2                    	xor	dx,dx
   651 00000232 B37B                    	mov	bl, 40h | 59		; CMD59 (CRC on/off)
   652 00000234 E8F3FE                  	call	SDcmdset
   653 00000237 E80501                  	call	cmd_R1
   654 0000023A 89F4                    	mov	sp,si			; clear command from stack
   655 0000023C E8ADFE                  	call	SDdone
   656                                  ;;	mov	ah,$-Zero
   657 0000023F 7526                    	jnz	.error
   658                                  %endif
   659                                  
   660                                  ; set the desired block length -- CMD16(512)
   661 00000241 0E                      	pushm	cs
   662 00000242 07                      	popm	es
   663 00000243 BE[8802]                	mov	si,CMD16
   664 00000246 E8F600                  	call	cmd_R1
   665 00000249 E8A0FE                  	call	SDdone
   666                                  ;;	mov	ah,$-Zero
   667 0000024C 7519                    	jnz	.error
   668                                  
   669 0000024E 31C0                    .okay:	xor	ax,ax			; clear the carry, too
   670                                  
   671                                  .exitstatus:
   672 00000250 8885A500                	mov	[SDstatus + di], al	; save SD card status
   673                                  .exit:
   674 00000254 5E5F07                  	popm	si,di,es
   675 00000257 08C0                    	or	al,al			; set the Z-flag
   676 00000259 C3                      	ret
   677                                  
   678                                  .err58:
   679 0000025A E88FFE                  	call	SDdone
   680                                  ;;	mov	ah,$-Zero
   681 0000025D EB08                    	jmp	.error
   682                                  .rdytimeout:
   683 0000025F B8FEFF                  	mov	ax,-2
   684 00000262 EB03                    	jmp	.error
   685                                  .timeout:
   686 00000264 B8FFFF                  	mov	ax,-1
   687                                  ;;;	jmp	.error
   688                                  .error:	
   689 00000267 F9                      	stc
   690 00000268 EBE6                    	jmp	.exitstatus
   691                                  
   692                                  .error1:			; caution here, DI is not set up
   693 0000026A B8FDFF                  	mov	ax,-3
   694 0000026D F9                      	stc
   695 0000026E EBE4                    	jmp	.exit
   696                                  
   697                                  
   698                                  
   699                                  
   700                                  
   701                                  CRC_unknown	equ	0FFh
   702                                  
   703                                  ;ResetCommand:
   704 00000270 400000000095            CMD0		db	40h | 0, 0, 0, 0, 0, 95h
   705 00000276 48000001AA87            CMD8		db	40h | 8, 0, 0, 01h, 0AAh, 87h
   706 0000027C 4900000000AF            CMD9		db	40h | 9, 0, 0, 0, 0, 0AFh
   707 00000282 4A000000001B            CMD10:		db	40h | 10, 0, 0, 0, 0, 01Bh
   708 00000288 500000020015            CMD16:		db	40h | 16, 0, 0, 512>>8, 512&0xFF, 015h
   709 0000028E 770000000065            CMD55		db	40h | 55, 0, 0, 0, 0, 065h
   710 00000294 694000000077            ACMD41		db	40h | 41, 40h, 0, 0, 0, 077h
   711 0000029A 7A00000000FD            CMD58		db	40h | 58, 0, 0, 0, 0, 0FDh
   712                                  
   713                                  
   714                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   715                                  ;  DSDgetInfo	C-callable routine to get OCR, CSD, & CID
   716                                  ;
   717                                  ;	byte DSDgetInfo(int unit, byte buffer[36]);
   718                                  ;
   719                                  ;  Return:
   720                                  ;	buffer filled with OCR, CSD, CID
   721                                  ;
   722                                  ;  Errors:
   723                                  ;	No Error	0
   724                                  ;	get OCR		1
   725                                  ;	get CSD		2
   726                                  ;	get CID		3
   727                                  ;
   728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   729                                  	global	_DSDgetInfo
   730                                  _DSDgetInfo:
   731 000002A0 55                              push    bp
   732 000002A1 89E5                            mov     bp,sp
   733 000002A3 065657525153            	pushm	bx,cx,dx,di,si,es
   734                                  
   735 000002A9 8B4604                  	mov	ax,ARG(1)
   736 000002AC BA0804                  	mov	dx,SDoperation
   737 000002AF EE                      	out	dx,al
   738                                  
   739 000002B0 E848FE                  	call	SDwaitrdy	; wait for card to go ready
   740 000002B3 C45E06                  	les	bx,ARG(2)
   741                                  
   742                                  ; get the OCR
   743 000002B6 06                      	push	es
   744 000002B7 0E                      	pushm	cs
   745 000002B8 07                      	pop	es
   746 000002B9 BE[9A02]                	mov	si,CMD58
   747 000002BC E88000                  	call	cmd_R1
   748 000002BF 07                      	pop	es
   749 000002C0 B80101                  	mov	ax,0101h		; AH=1, AL=1
   750 000002C3 750E                          	jnz	.ocr2			; error if not Zero
   751 000002C5 B90400                  	mov	cx,4
   752 000002C8 E8F7FD                  .ocr	call	SDgetchar		; discard rest of the response
   753 000002CB 268807                    es	mov	[bx],al
   754 000002CE 43                        	inc	bx
   755 000002CF E2F7                    	loop	.ocr
   756 000002D1 31C0                    	xor	ax,ax			; set the Z flag
   757                                  .ocr2:
   758 000002D3 E816FE                  	call	SDdone
   759 000002D6 7532                    	jnz	.error
   760                                  
   761                                  ; get the Card Specific Data (CSD) register contents
   762 000002D8 06                      	push	es
   763 000002D9 0E                      	pushm	cs
   764 000002DA 07                      	pop	es
   765 000002DB BE[7C02]                	mov	si,CMD9
   766 000002DE E85E00                  	call	cmd_R1
   767 000002E1 07                      	pop	es
   768 000002E2 B91000                  	mov	cx,16
   769 000002E5 E8B400                  	call	SDgetdata
   770 000002E8 E801FE                  	call	SDdone
   771 000002EB B80202                  	mov	ax,0202h		; AH=2, AL=2
   772 000002EE 751A                    	jnz	.error
   773                                  
   774                                  
   775                                  ; get the Card Identification Data (CID) register contents
   776 000002F0 06                      	push	es
   777                                  
   778 000002F1 0E                      	pushm	cs
   779 000002F2 07                      	pop	es
   780 000002F3 BE[8202]                	mov	si,CMD10
   781 000002F6 E84600                  	call	cmd_R1
   782 000002F9 07                      	pop	es
   783                                  
   784 000002FA B91000                  	mov	cx,16
   785 000002FD E89C00                  	call	SDgetdata
   786 00000300 E8E9FD                  	call	SDdone
   787 00000303 B80303                  	mov	ax,0303h		; AH=3, AL=3
   788 00000306 7502                    	jnz	.error
   789                                  
   790 00000308 31C0                    	xor	ax,ax		; signal No Error
   791                                  .error:
   792                                  
   793 0000030A 5B595A5F5E07            	popm	bx,cx,dx,di,si,es
   794 00000310 89EC                    	mov	sp,bp
   795 00000312 5D                      	pop	bp
   796 00000313 C3                      	ret
   797                                  
   798                                  
   799                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   800                                  ; stepCRC7	include a byte in a CRC7 polynomial
   801                                  ;
   802                                  ;  Enter with:
   803                                  ;	DL = partial CRC calculation
   804                                  ;	AL = character to add into the calculation
   805                                  ;
   806                                  ;  Return with:
   807                                  ;	DL = updated CRC calculation
   808                                  ;	AX is trashed
   809                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   810                                  CRC7poly	equ	00001001b
   811                                  CRC7poly2	equ	CRC7poly*2	; 7 bits only
   812                                  
   813                                  	 global stepCRC7, @stepCRC7
   814                                  stepCRC7:
   815                                  @stepCRC7:
   816 00000314 51                      	push	cx
   817                                  
   818 00000315 B90800                  	mov	cx,8 			; 8 bits in AL
   819                                  .1:	
   820 00000318 88D4                    	mov	ah,dl			; copy CRC to AH
   821 0000031A 30C4                    	xor	ah,al			; Sign bit is 0 or 1
   822 0000031C D1E0                    	shl	ax,1
   823 0000031E 18E4                    	sbb	ah,ah			; AH is 0 or -1
   824 00000320 D0E2                    	shl	dl,1			; shift polynomial
   825 00000322 80E412                  	and	ah,CRC7poly2		; get bits to add into the CRC
   826 00000325 30E2                    	xor	dl,ah			; update the polynomial
   827 00000327 E2EF                    	loop	.1
   828                                  	
   829 00000329 88D0                    	mov	al,dl			; return in AX also
   830 0000032B 30E4                    	xor	ah,ah
   831 0000032D 59                      	pop	cx
   832 0000032E C3                      	ret
   833                                  	
   834                                  
   835                                  
   836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   837                                  ; calcCRC7	calculate a CRC7 polynomial (for a command)
   838                                  ;
   839                                  ;  Enter with:
   840                                  ;	ES:SI	points at a string of bytes
   841                                  ;	CX	count of bytes in the string
   842                                  ;	direction flag clear
   843                                  ;
   844                                  ;  Return with:
   845                                  ;	ES:SI	point at next byte beyond end of string
   846                                  ;	CX = 0
   847                                  ;	AL = CRC7 polynomial byte
   848                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   849                                  calcCRC7:
   850 0000032F 52                      	push	dx
   851 00000330 31D2                    	xor	dx,dx		; start CRC7 at zero
   852                                  .1:
   853 00000332 26AC                      es	lodsb
   854 00000334 E8DDFF                  	call	stepCRC7
   855 00000337 E2F9                    	loop	.1
   856                                  
   857 00000339 88D0                    	mov	al,dl		; final CRC7 to AL
   858 0000033B 0C01                    	or	al,01h		; set the low bit
   859 0000033D 5A                      	pop	dx
   860 0000033E C3                      	ret
   861                                  
   862                                  
   863                                  
   864                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   865                                  ; cmd_R1	issue command and get R1 response
   866                                  ;
   867                                  ;  Enter with:
   868                                  ;	ES:SI	far pointer to command string
   869                                  ;	DX	device code for Operation register
   870                                  ;
   871                                  ;  Exit with:
   872                                  ;	byte value of response to the command
   873                                  ;	-1 if error (such as no response)
   874                                  ;
   875                                  ;	SI	is incremented by 6, the length of a command
   876                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   877                                  cmd_R1:
   878 0000033F 51                      	pushm	cx
   879 00000340 B90600                  	mov	cx,6		; all commands are 6 bytes
   880                                  .1:
   881 00000343 26AC                      es	lodsb
   882 00000345 E865FD                  	call	SDputchar
   883 00000348 E2F9                    	loop	.1
   884                                  %if DEBUG>=4
   885                                  	pushm	bx,di,es
   886                                  
   887                                  	mov	bx,-1
   888                                  	mov	cx,lbuf
   889                                  	pushm	cs
   890                                  	popm	es
   891                                  	mov	di,buffer
   892                                  .2:
   893                                  	call	SDgetchar
   894                                  	stosb				; save for debug
   895                                  	test	al,80h
   896                                  	jz	.3
   897                                  	mov	bl,al
   898                                  	loop	.2
   899                                  	mov	ax,bx 
   900                                  .3:
   901                                  	popm	bx,di,es
   902                                  %else
   903 0000034A B90900                  	mov	cx,9			; response must come within 8 chars
   904 0000034D E872FD                  .2:	call	SDgetchar
   905 00000350 A880                    	test	al,80h			; check high bit for zero
   906 00000352 7405                    	jz	.4			; 0xxx xxxxb is result byte
   907 00000354 E2F7                    	loop	.2
   908                                  %endif
   909 00000356 98                      	cbw				; extend to whole word
   910 00000357 08C0                    	or	al,al			; clear zero flag
   911                                  .4:				; Zero flag set if jumped here
   912 00000359 59                      	popm	cx
   913 0000035A C3                      	ret
   914                                  
   915                                  
   916                                  
   917                                  %if USE_CRCs
   918                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   919                                  ; crc_step	one step in CRC calculation
   920                                  ;
   921                                  ;  Enter with:
   922                                  ;	AL	byte to be added to the CRC computation
   923                                  ;	CX,DX	not to be touched
   924                                  ;	SI	partial CRC computation
   925                                  ;
   926                                  ;  Return with:
   927                                  ;	CX,DX	preserved
   928                                  ;	BX	is destroyed
   929                                  ;	SI	updated CRC computation
   930                                  ;
   931                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   932                                  crc_step:
   933 0000035B 87CE                    	xchg	cx,si		; preserve CX in SI
   934                                  .2:
   935 0000035D 88EB                    	mov	bl,ch		; form index into table
   936 0000035F 30FF                    	xor	bh,bh		; zap BH
   937 00000361 30C3                    	xor	bl,al		; use current byte in AL
   938                                  
   939 00000363 88CD                      	mov	ch,cl		; update CRC16
   940 00000365 30C9                    	xor	cl,cl
   941 00000367 D1E3                    	shl	bx,1
   942 00000369 2E338F[3505]              cs	xor	cx,[crc16tab + bx]
   943                                  
   944 0000036E 87CE                    	xchg	cx,si		; put new crc back in SI
   945 00000370 C3                      	ret
   946                                  %endif
   947                                  
   948                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   949                                  ; SDtestdata	test crc on a block of data
   950                                  ;
   951                                  ;  Enter with:
   952                                  ;	CX	count of data bytes to get
   953                                  ;	DX	set to Operation register device code
   954                                  ;
   955                                  ;  Return with:
   956                                  ;    Good return:
   957                                  ;	CX =	CRC16 returned by the call
   958                                  ;	AX =	0
   959                                  ;	Zero flag is set
   960                                  ;
   961                                  ;    Error return:
   962                                  ;	BX	not changed
   963                                  ;	CX	not changed
   964                                  ;	AX =	error code
   965                                  ;	Zero flag is clear
   966                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   967                                  SDtestdata:
   968 00000371 5653                    	pushm	bx,si			; save BX, SI
   969                                  
   970 00000373 51                      	pushm	cx			; save byte count
   971                                  
   972 00000374 B9FF7F                  	mov	cx,7FFFh		; timeout count
   973                                  .1:
   974 00000377 E848FD                  	call	SDgetchar		; get an input byte
   975 0000037A 3CFF                    	cmp	al,0FFh			; any return yet?
   976 0000037C 7502                    	jne	.2			;
   977 0000037E E2F7                    	loop	.1
   978                                  .2:
   979 00000380 59                      	popm	cx			; restore data count
   980                                  
   981 00000381 3CFE                    	cmp	al,0FEh			; timeout or start of data?
   982 00000383 7511                    	jne	.4			; jump if timeout
   983                                  
   984 00000385 31F6                    	xor	si,si			; start CRC at zero
   985 00000387 83C102                  	add	cx,2			; 
   986 0000038A E835FD                  .3:	call	SDgetchar
   987                                  %if USE_CRCs
   988 0000038D E8CBFF                  	call	crc_step		; update the CRC in SI
   989                                  %endif
   990 00000390 E2F8                    	loop	.3			; get all the bytes
   991                                  
   992                                  .99:
   993 00000392 89F1                    	mov	cx,si			; CRC to CX
   994 00000394 31C0                    	xor	ax,ax			; good return
   995                                  .4:				; error return
   996 00000396 98                      	cbw
   997 00000397 08C0                    	or	al,al
   998 00000399 5B5E                    	popm	bx,si			; restore regs
   999 0000039B C3                      	ret
  1000                                  	global	verify_crc
  1001                                  verify_crc	equ	.99
  1002                                  
  1003                                  
  1004                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1005                                  ; SDgetdata	get a block of data
  1006                                  ;
  1007                                  ;  Enter with:
  1008                                  ;	ES:BX	points at buffer to receive data
  1009                                  ;	CX	count of data bytes to get
  1010                                  ;	DX	set to Operation register device code
  1011                                  ;
  1012                                  ;  Return with:
  1013                                  ;    Good return:
  1014                                  ;	CX =	CRC16 returned by the call
  1015                                  ;	AX =	0
  1016                                  ;	Zero flag is set
  1017                                  ;
  1018                                  ;    Error return:
  1019                                  ;	ES:BX	not changed
  1020                                  ;	CX	not changed
  1021                                  ;	AX =	error code
  1022                                  ;	Zero flag is clear
  1023                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1024                                  SDgetdata:
  1025 0000039C 51                      	pushm	cx			; save byte count
  1026                                  
  1027 0000039D B9FF7F                  	mov	cx,7FFFh		; timeout count
  1028                                  .1:
  1029 000003A0 E81FFD                  	call	SDgetchar		; get an input byte
  1030 000003A3 3CFF                    	cmp	al,0FFh			; any return yet?
  1031 000003A5 7502                    	jne	.2			;
  1032 000003A7 E2F7                    	loop	.1
  1033                                  .2:
  1034 000003A9 59                      	popm	cx			; restore data count
  1035 000003AA 3CFE                    	cmp	al,0FEh			; timeout or start of data?
  1036 000003AC 7515                    	jne	.4			; jump if timeout
  1037                                  
  1038 000003AE E811FD                  .3:	call	SDgetchar
  1039 000003B1 268807                    es	mov	[bx],al			; store data read
  1040 000003B4 43                        	inc	bx
  1041 000003B5 E2F7                    	loop	.3			; get all the bytes
  1042                                  
  1043 000003B7 E808FD                  	call	SDgetchar		; get first CRC16 byte
  1044 000003BA 88C5                    	mov	ch,al
  1045 000003BC E803FD                  	call	SDgetchar
  1046 000003BF 88C1                    	mov	cl,al			; low order CRC16 byte
  1047                                  
  1048 000003C1 31C0                    	xor	ax,ax
  1049                                  .4:				; error return
  1050 000003C3 98                      	cbw
  1051 000003C4 08C0                    	or	al,al
  1052 000003C6 C3                      	ret
  1053                                  
  1054                                  
  1055                                  
  1056                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1057                                  ; SDputdata	put out the data block
  1058                                  ;
  1059                                  ;  Enter with:
  1060                                  ;	AX	CRC16 bytes to send
  1061                                  ;	ES:BX	pointer to the data block to put out
  1062                                  ;	CX	count of data bytes to send
  1063                                  ;	DX	device code of Operation register
  1064                                  ;
  1065                                  ;  Return with:
  1066                                  ;	ES:BX	points beyond end of data
  1067                                  ;	CX	is trash
  1068                                  ;
  1069                                  ;	AX = 0, Z=1  means a good return
  1070                                  ;   or	Z=0, AX = error return byte
  1071                                  ;
  1072                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1073                                  SDputdata:
  1074 000003C7 50                      	pushm	ax			; save CRC16 bytes
  1075                                  
  1076 000003C8 B0FE                    	mov	al,0FEh			; start of data packet
  1077 000003CA E8E0FC                  	call	SDputchar
  1078                                  .1:
  1079 000003CD 268A07                    es	mov	al,[bx]			; get data byte
  1080 000003D0 43                        	inc	bx
  1081 000003D1 E8D9FC                  	call	SDputchar
  1082 000003D4 E2F7                    	loop	.1
  1083                                  
  1084 000003D6 59                      	popm	cx			; get CRC bytes
  1085 000003D7 88E8                    	mov	al,ch			; put out hi-CRC16
  1086 000003D9 E8D1FC                  	call	SDputchar
  1087 000003DC 88C8                    	mov	al,cl			; put out lo-CRC16
  1088 000003DE E8CCFC                  	call	SDputchar
  1089                                  
  1090 000003E1 B9FF7F                  	mov	cx,7FFFh		; timeout count
  1091                                  .2:
  1092 000003E4 E8DBFC                  	call	SDgetchar		; get byte != FF
  1093 000003E7 3CFF                    	cmp	al,0FFh
  1094 000003E9 7502                    	jne	.3
  1095 000003EB E2F7                    	loop	.2
  1096                                  .3:
  1097 000003ED 241F                    	and	al,1Fh			; mask return acknowledge
  1098 000003EF 98                      	cbw
  1099 000003F0 3C05                    	cmp	al,05h
  1100 000003F2 7502                           	jne	.error			; Z=0
  1101 000003F4 31C0                    	xor	ax,ax			; Z=1, AX=0
  1102                                  .error:
  1103 000003F6 C3                      	ret
  1104                                  
  1105                                  
  1106                                  %if SOFT_DEBUG
  1107                                  	global	SD_put_return
  1108                                  SD_put_return equ  .3
  1109                                  %endif
  1110                                  
  1111                                  
  1112                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1113                                  ; SDcheck	check for drive readable/writeable
  1114                                  ;
  1115                                  ;  Enter with:
  1116                                  ;	AH = 2	check for card readable
  1117                                  ;	AH = 3	check for card writeable
  1118                                  ;
  1119                                  ;  Return with:
  1120                                  ;	AX =	error code (0 means okay)
  1121                                  ;	Zero flag is set/reset per AX
  1122                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1123                                  SDcheck:
  1124 000003F7 E8A8FC                  	call	SDgetunit		; set up DX, DI
  1125                                  
  1126 000003FA EC                      	in	al,dx			; check HW status
  1127 000003FB A820                    	test	al,CardDetect		; card inserted?
  1128 000003FD 741B                    	jz	.nocard
  1129 000003FF F6C401                  	test	ah,1			; test LSB of AH
  1130 00000402 7404                    	jz	.0			; read test
  1131 00000404 A810                    	test	al,WrProt		; writeable?
  1132 00000406 7517                    	jnz	.wrprot			; not writeable
  1133                                  .0:
  1134 00000408 80BDA50000              	cmp	byte [SDstatus + di], 0	; check for unit initialized
  1135 0000040D 7407                    	je	.1
  1136 0000040F 89F8                    	mov	ax,di
  1137 00000411 E86BFD                  	call	SDinitcard
  1138 00000414 750E                    	jne	.ret			; return if error on init
  1139                                  .1:
  1140 00000416 31C0                    	xor	ax,ax			; good return
  1141 00000418 EB0A                    	jmp	.ret
  1142                                  
  1143                                  .nocard:
  1144 0000041A B8FAFF                  	mov	ax,-6			; no card inserted
  1145 0000041D EB03                    	jmp	.exit
  1146                                  .wrprot:
  1147 0000041F B8F9FF                  	mov	ax,-7			; card is write protected
  1148                                  
  1149 00000422 09C0                    .exit:	or	ax,ax
  1150 00000424 C3                      .ret:	ret
  1151                                  
  1152                                  
  1153                                  
  1154                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1155                                  ; SDsetaddr	set up card sector address
  1156                                  ;
  1157                                  ;  Enter with:
  1158                                  ;	DX:AX	sector address (512 byte sectors)
  1159                                  ;	DI	unit number
  1160                                  ;
  1161                                  ;  Return with:
  1162                                  ;	DX:AX	byte address for SDSC cards
  1163                                  ;		unchanged for SDHC cards
  1164                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1165                                  SDsetaddr:
  1166 00000425 80BDA70003              	cmp	byte [SDcardtype + di], SDtypeSDHC
  1167 0000042A 730C                    	jae	.6
  1168                                  ; SDSC cards and below use byte addressing
  1169                                  ; multiply DX:AX by 512
  1170 0000042C 88D6                    	mov	dh,dl		; shift by 8
  1171 0000042E 88E2                    	mov	dl,ah
  1172 00000430 88C4                    	mov	ah,al
  1173 00000432 30C0                    	xor	al,al		; **
  1174 00000434 D1E0                    	shl	ax,1		; double shift by one more
  1175 00000436 D1D2                    	rcl	dx,1
  1176                                  				; all shifted by 9 (2**9 == 512)
  1177                                  .6:
  1178 00000438 C3                      	ret
  1179                                  
  1180                                  
  1181                                  
  1182                                  
  1183                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1184                                  ; SDread1sec	Read a single sector (of 512 bytes)
  1185                                  ;
  1186                                  ;  Enter with:
  1187                                  ;	DX:AX	sector number to read
  1188                                  ;	ES:BX	buffer to receive data
  1189                                  ;
  1190                                  ;  Return with:
  1191                                  ;	CL	error code (0 means success)
  1192                                  ;	DX:AX	preserved
  1193                                  ;	ES:BX	preserved
  1194                                  ;	SI, DI, CH are preserved
  1195                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1196                                  SDread1sec:
  1197 00000439 5756525350              	pushm	ax,bx,dx,si,di
  1198 0000043E 51                      	pushm	cx
  1199                                  
  1200 0000043F 0653                    	pushm	bx,es		; save buffer address
  1201 00000441 5250                    	pushm	ax,dx		; save sector number
  1202                                  
  1203 00000443 B402                    	mov	ah,2		; show it is a read check
  1204 00000445 E8AFFF                  	call	SDcheck
  1205 00000448 753C                    	jnz	.err2
  1206                                  
  1207 0000044A E8AEFC                  	call	SDwaitrdy	; wait for card to go ready
  1208 0000044D 7237                    	jc	.err2
  1209                                  
  1210 0000044F 585A                    	popm	ax,dx		; get sector address
  1211 00000451 E8D1FF                  	call	SDsetaddr	; set up card address in DX:AX
  1212                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1213 00000454 B351                    	mov	bl, 40h | 17	; CMD17 = read one sector
  1214 00000456 E8D1FC                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1215 00000459 E8E3FE                  	call	cmd_R1		; execute the command
  1216 0000045C 89F4                    	mov	sp,si		; purge command from the stack
  1217 0000045E 7405                    	jz	.3
  1218 00000460 E889FC                  	call	SDdone		; done if error
  1219 00000463 EB23                          	jmp	.err1		; exit on error
  1220                                  .3:
  1221 00000465 5B07                    	popm	bx,es		; restore data pointer
  1222 00000467 B90002                  	mov	cx,512		; read 512 bytes
  1223 0000046A E82FFF                  	call	SDgetdata	; **
  1224 0000046D E87CFC                  	call	SDdone		; end of command
  1225                                  %if USE_CRCs
  1226 00000470 7518                    	jnz	.exit
  1227 00000472 51                      	pushm	cx		; save CRC16 read in
  1228 00000473 B90002                  	mov	cx,512		; check 512 bytes
  1229 00000476 29CB                    	sub	bx,cx		; set ES:BX
  1230 00000478 31C0                    	xor	ax,ax		; start CRC16 at zero
  1231 0000047A E89C00                  	call	crc16
  1232 0000047D 59                      	popm	cx
  1233 0000047E 29C1                    	sub	cx,ax		; compare the two CRC16's
  1234 00000480 7408                    	jz	.exit
  1235 00000482 B1F8                    	mov	cl,-8		; CRC error on read
  1236                                  %endif
  1237 00000484 EB04                    	jmp	.exit		; exit with error code
  1238                                  
  1239                                  .err2:
  1240 00000486 5E5F                    	popm	si,di		; clear sector number
  1241                                  .err1:
  1242 00000488 5E5F                    	popm	si,di		; clear buffer address
  1243                                  .exit:
  1244 0000048A 58                      	popm	ax		; get CX saved
  1245 0000048B 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1246 0000048D 585B5A5E5F              	popm	ax,bx,dx,si,di
  1247 00000492 08C9                    	or	cl,cl		; set the Z flag
  1248 00000494 C3                      	ret
  1249                                  
  1250                                  
  1251                                  	
  1252                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1253                                  ; SDwrite1sec	write a sector
  1254                                  ;
  1255                                  ;  Enter with:
  1256                                  ;	DX:AX	sector number to write
  1257                                  ;	ES:BX	data buffer from which to write
  1258                                  ;
  1259                                  ;  Return with:
  1260                                  ;	CL	error code (0 means success)
  1261                                  ;	DX:AX	preserved
  1262                                  ;	ES:BX	preserved
  1263                                  ;	SI, DI, CH are preserved
  1264                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1265                                  SDwrite1sec:
  1266 00000495 5756525350              	pushm	ax,bx,dx,si,di
  1267 0000049A 51                      	pushm	cx
  1268                                  
  1269 0000049B 0653                    	pushm	bx,es		; save buffer address
  1270 0000049D 5250                    	pushm	ax,dx		; save sector number
  1271                                  
  1272 0000049F B403                    	mov	ah,3		; show it is a write check
  1273 000004A1 E853FF                  	call	SDcheck
  1274 000004A4 7532                    	jnz	.err2
  1275                                  
  1276 000004A6 E852FC                  	call	SDwaitrdy	; wait for card to go ready
  1277 000004A9 722D                    	jc	.err2
  1278                                  
  1279 000004AB 585A                    	popm	ax,dx		; get sector address
  1280 000004AD E875FF                  	call	SDsetaddr	; set up card address in DX:AX
  1281                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1282 000004B0 B358                    	mov	bl, 40h | 24	; CMD24 = write one sector
  1283 000004B2 E875FC                  	call	SDcmdset	; CMD24 (DX:AX) crc
  1284 000004B5 E887FE                  	call	cmd_R1		; execute the command
  1285 000004B8 89F4                    	mov	sp,si		; purge command from the stack
  1286 000004BA 7405                    	jz	.3
  1287 000004BC E82DFC                  	call	SDdone		; done if error
  1288 000004BF EB19                          	jmp	.err1		; exit on error
  1289                                  .3:
  1290 000004C1 5B07                    	popm	bx,es		; restore data pointer
  1291                                  %if USE_CRCs
  1292 000004C3 31C0                    	xor	ax,ax		; start CRC16 at zero
  1293 000004C5 B90002                  	mov	cx,512		; write 512 bytes
  1294 000004C8 E84E00                  	call	crc16
  1295 000004CB B90002                  	mov	cx,512		; write 512 bytes
  1296 000004CE 29CB                    	sub	bx,cx		; restore data pointer
  1297                                  %else
  1298                                  	mov	ax,0FFFFh	; dummy CRC16 
  1299                                  	mov	cx,512		; write 512 bytes
  1300                                  %endif
  1301 000004D0 E8F4FE                  	call	SDputdata	; **
  1302 000004D3 E816FC                  	call	SDdone		; end of command
  1303 000004D6 EB04                    	jmp	.exit
  1304                                  
  1305                                  .err2:
  1306 000004D8 5E5F                    	popm	si,di		; clear sector number
  1307                                  .err1:
  1308 000004DA 5E5F                    	popm	si,di		; clear buffer address
  1309                                  .exit:
  1310 000004DC 88C1                    	mov	cl,al		; move error code to CL
  1311 000004DE 58                      	popm	ax		; get CX saved
  1312 000004DF 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1313 000004E1 585B5A5E5F              	popm	ax,bx,dx,si,di
  1314 000004E6 08C9                    	or	cl,cl		; set the Z flag
  1315 000004E8 C3                      	ret
  1316                                  
  1317                                  
  1318                                  
  1319                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1320                                  ; SDverify1sec	Verify a single sector (of 512 bytes)
  1321                                  ;
  1322                                  ;  Enter with:
  1323                                  ;	DX:AX	sector number to read
  1324                                  ;
  1325                                  ;  Return with:
  1326                                  ;	CL	error code (0 means success)
  1327                                  ;	DX:AX	preserved
  1328                                  ;	ES:BX	preserved
  1329                                  ;	SI, DI, CH are preserved
  1330                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1331                                  SDverify1sec:
  1332 000004E9 5756525350              	pushm	ax,bx,dx,si,di
  1333 000004EE 51                      	pushm	cx
  1334                                  
  1335 000004EF 5250                    	pushm	ax,dx		; save sector number
  1336                                  
  1337 000004F1 B402                    	mov	ah,2		; show it is a read check
  1338 000004F3 E801FF                  	call	SDcheck
  1339 000004F6 7512                    	jnz	.err2
  1340                                  
  1341 000004F8 E800FC                  	call	SDwaitrdy	; wait for card to go ready
  1342 000004FB 720D                    	jc	.err2
  1343 000004FD 585A                    	popm	ax,dx		; get sector address
  1344                                  
  1345                                  %if QUICK_VERIFY
  1346 000004FF 31C9                    	xor	cx,cx
  1347                                  %else
  1348                                  	call	SDsetaddr	; set up card address in DX:AX
  1349                                  ; DX:AX is byte address (SDSC) or sector address (SDHC)
  1350                                  	mov	bl, 40h | 17	; CMD17 = read one sector
  1351                                  	call	SDcmdset	; CMD17 (DX:AX) crc
  1352                                  	call	cmd_R1		; execute the command
  1353                                  	mov	sp,si		; purge command from the stack
  1354                                  	jz	.3
  1355                                  	call	SDdone		; done if error
  1356                                        	jmp	.err1		; exit on error
  1357                                  .3:
  1358                                  	mov	cx,512		; read 512 bytes
  1359                                  	call	SDtestdata	; **
  1360                                  %endif
  1361 00000501 E8E8FB                  	call	SDdone		; end of command
  1362                                  
  1363 00000504 08E9                    	or	cl,ch		; is CRC zero, create error code
  1364 00000506 7406                    	jz	.exit
  1365                                  
  1366 00000508 B110                    	mov	cl, ERR_uncorrectable_CRC_error
  1367                                  .err2:
  1368 0000050A 5E5F                    	popm	si,di		; clear sector number
  1369                                  .err1:
  1370                                  ;;;	popm	si,di		; clear buffer address
  1371 0000050C 88E1                    	mov	cl,ah		; error code to CL
  1372                                  .exit:
  1373 0000050E 58                      	popm	ax		; get CX saved
  1374 0000050F 88E5                    	mov	ch,ah		; restore CH, CL is error code
  1375 00000511 585B5A5E5F              	popm	ax,bx,dx,si,di
  1376 00000516 08C9                    	or	cl,cl		; set the Z flag
  1377 00000518 C3                      	ret
  1378                                  
  1379                                  
  1380                                  	
  1381                                  
  1382                                  %if USE_CRCs
  1383                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1384                                  ; crc16		add data to the input CRC16 calculation
  1385                                  ;
  1386                                  ;  Enter with:
  1387                                  ;	ES:BX	data pointer
  1388                                  ;	CX	count of bytes
  1389                                  ;	AX	partial CRC16 sum
  1390                                  ;
  1391                                  ;  Return with:
  1392                                  ;	ES:BX	updated data pointer
  1393                                  ;	CX = 0
  1394                                  ;	AX	updated CRC16 sum
  1395                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1396                                  	global	crc16
  1397                                  crc16:
  1398 00000519 56                      	pushm	si		; save SI
  1399                                  
  1400 0000051A 89DE                    	mov	si,bx		; use ES:SI to address data
  1401                                  .2:
  1402 0000051C 88E3                    	mov	bl,ah		; form index into table
  1403 0000051E 30FF                    	xor	bh,bh		; zap BH
  1404 00000520 26321C                    es	xor	bl,[si]		; form table index
  1405 00000523 46                        	inc	si
  1406 00000524 88C4                      	mov	ah,al		; update CRC16
  1407 00000526 30C0                    	xor	al,al
  1408 00000528 D1E3                    	shl	bx,1
  1409 0000052A 2E3387[3505]              cs	xor	ax,[crc16tab + bx]
  1410 0000052F E2EB                      	loop	.2
  1411                                  
  1412 00000531 89F3                    	mov	bx,si		; updated BX value
  1413 00000533 5E                      	popm	si
  1414 00000534 C3                      	ret
  1415                                  
  1416                                  
  1417                                  %include "crc16tab.inc"
  1418                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1419                              <1> ; crc16tab.inc
  1420                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1421                              <1> ;
  1422                              <1> ;   This version is for assembly by  NASM 0.98.39 or later
  1423                              <1> ;
  1424                              <1> ; Copyright (c) 2013 John R. Coffman.  All rights reserved.
  1425                              <1> ; Provided for hobbyist use on the N8VEM SBC-188 board.
  1426                              <1> ;
  1427                              <1> ; This program is free software: you can redistribute it and/or modify
  1428                              <1> ; it under the terms of the GNU General Public License as published by
  1429                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1430                              <1> ; (at your option) any later version.
  1431                              <1> ;
  1432                              <1> ; This program is distributed in the hope that it will be useful,
  1433                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1434                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1435                              <1> ; GNU General Public License for more details.
  1436                              <1> ;
  1437                              <1> ; You should have received a copy of the GNU General Public License
  1438                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1439                              <1> ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1440                              <1> 
  1441                              <1> crc16tab:
  1442 00000535 000021104220633084- <1>   dw	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7
  1442 0000053E 40A550C660E770      <1>
  1443 00000545 088129914AA16BB18C- <1>   dw	0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF
  1443 0000054E C1ADD1CEE1EFF1      <1>
  1444 00000555 3112100273325222B5- <1>   dw	0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6
  1444 0000055E 529442F772D662      <1>
  1445 00000565 399318837BB35AA3BD- <1>   dw	0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE
  1445 0000056E D39CC3FFF3DEE3      <1>
  1446 00000575 6224433420040114E6- <1>   dw	0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485
  1446 0000057E 64C774A4448554      <1>
  1447 00000585 6AA54BB528850995EE- <1>   dw	0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D
  1447 0000058E E5CFF5ACC58DD5      <1>
  1448 00000595 5336722611163006D7- <1>   dw	0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4
  1448 0000059E 76F6669556B446      <1>
  1449 000005A5 5BB77AA719973887DF- <1>   dw	0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC
  1449 000005AE F7FEE79DD7BCC7      <1>
  1450 000005B5 C448E5588668A77840- <1>   dw	0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823
  1450 000005BE 08611802282338      <1>
  1451 000005C5 CCC9EDD98EE9AFF948- <1>   dw	0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B
  1451 000005CE 8969990AA92BB9      <1>
  1452 000005D5 F55AD44AB77A966A71- <1>   dw	0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12
  1452 000005DE 1A500A333A122A      <1>
  1453 000005E5 FDDBDCCBBFFB9EEB79- <1>   dw	0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A
  1453 000005EE 9B588B3BBB1AAB      <1>
  1454 000005F5 A66C877CE44CC55C22- <1>   dw	0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41
  1454 000005FE 2C033C600C411C      <1>
  1455 00000605 AEED8FFDECCDCDDD2A- <1>   dw	0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49
  1455 0000060E AD0BBD688D499D      <1>
  1456 00000615 977EB66ED55EF44E13- <1>   dw	0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70
  1456 0000061E 3E322E511E700E      <1>
  1457 00000625 9FFFBEEFDDDFFCCF1B- <1>   dw	0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78
  1457 0000062E BF3AAF599F788F      <1>
  1458 00000635 8891A981CAB1EBA10C- <1>   dw	0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F
  1458 0000063E D12DC14EF16FE1      <1>
  1459 00000645 8010A100C230E32004- <1>   dw	0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067
  1459 0000064E 50254046706760      <1>
  1460 00000655 B9839893FBA3DAB33D- <1>   dw	0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E
  1460 0000065E C31CD37FE35EF3      <1>
  1461 00000665 B1029012F322D23235- <1>   dw	0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256
  1461 0000066E 42145277625672      <1>
  1462 00000675 EAB5CBA5A89589856E- <1>   dw	0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D
  1462 0000067E F54FE52CD50DC5      <1>
  1463 00000685 E234C324A014810466- <1>   dw	0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405
  1463 0000068E 74476424540544      <1>
  1464 00000695 DBA7FAB79987B8975F- <1>   dw	0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C
  1464 0000069E E77EF71DC73CD7      <1>
  1465 000006A5 D326F2369106B01657- <1>   dw	0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634
  1465 000006AE 66767615463456      <1>
  1466 000006B5 4CD96DC90EF92FE9C8- <1>   dw	0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB
  1466 000006BE 99E9898AB9ABA9      <1>
  1467 000006C5 4458654806782768C0- <1>   dw	0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3
  1467 000006CE 18E1088238A328      <1>
  1468 000006D5 7DCB5CDB3FEB1EFBF9- <1>   dw	0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A
  1468 000006DE 8BD89BBBAB9ABB      <1>
  1469 000006E5 754A545A376A167AF1- <1>   dw	0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92
  1469 000006EE 0AD01AB32A923A      <1>
  1470 000006F5 2EFD0FED6CDD4DCDAA- <1>   dw	0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9
  1470 000006FE BD8BADE89DC98D      <1>
  1471 00000705 267C076C645C454CA2- <1>   dw	0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1
  1471 0000070E 3C832CE01CC10C      <1>
  1472 00000715 1FEF3EFF5DCF7CDF9B- <1>   dw	0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8
  1472 0000071E AFBABFD98FF89F      <1>
  1473 00000725 176E367E554E745E93- <1>   dw	0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
  1473 0000072E 2EB23ED10EF01E      <1>
  1474                              <1> 
  1475                              <1> ; end crc16tab.inc
  1418                                  %endif
  1419                                  
  1420                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1421                                  ; xbits		extract BigEndian bits
  1422                                  ;
  1423                                  ;  Enter with:
  1424                                  ;	ES:SI	points at byte containing bit 0
  1425                                  ;	CH:CL	hi-bit : lo-bit	 to be extracted
  1426                                  ;
  1427                                  ;  Exit with:
  1428                                  ;	AX	extracted value
  1429                                  ;	no other registers altered
  1430                                  ;
  1431                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1432                                  xbits:
  1433 00000735 565153                  	pushm	bx,cx,si
  1434 00000738 88C8                    	mov	al,cl
  1435 0000073A 30E4                    	xor	ah,ah
  1436 0000073C C1E803                  	shr	ax,3			; AX is byte offset
  1437 0000073F 29C6                    	sub	si,ax			; SI points at first byte
  1438 00000741 28CD                    	sub	ch,cl			; CH is bit count - 1
  1439 00000743 268A04                    es	mov	al,[si]
  1440 00000746 268A64FF                  es	mov	ah,[si-1]
  1441 0000074A 268A5CFE                  es	mov	bl,[si-2]		; allow for max. of 12 bit field
  1442 0000074E 80E107                  	and	cl,7			; CL is bit offset
  1443 00000751 7408                    	jz	.3
  1444 00000753 D0EB                    .1:	shr	bl,1
  1445 00000755 D1D8                    	rcr	ax,1
  1446 00000757 FEC9                    	dec	cl
  1447 00000759 75F8                    	jnz	.1
  1448 0000075B BBFEFF                  .3:	mov	bx,0FFFEh		; mask 1 bit
  1449 0000075E C1E908                  	shr	cx,8			; mov CH to CL, zero extended
  1450 00000761 D3E3                    	shl	bx,cl			; make BX into a mask
  1451 00000763 F7D3                    	not	bx
  1452 00000765 21D8                    	and	ax,bx			; mask bits in AX
  1453 00000767 5B595E                  	popm	bx,cx,si
  1454 0000076A C3                      	ret
  1455                                  
  1456                                  
  1457                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1458                                  ; _SDcsd	extract information from the CSD register
  1459                                  ;
  1460                                  ;  word __cdecl SDcsd(word what, byte *csd)
  1461                                  ;
  1462                                  ;  Enter with:
  1463                                  ;	arg1  = what: AH=hi-bit number, AL=lo-bit number
  1464                                  ;	arg2  = far pointer to CSD array
  1465                                  ;
  1466                                  ;  Exit with:
  1467                                  ;	AX = extracted value
  1468                                  ;
  1469                                  ;  Uses:
  1470                                  ;	xbits
  1471                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1472                                  	global	_SDcsd
  1473                                  _SDcsd:
  1474 0000076B 55                      	push	bp
  1475 0000076C 89E5                    	mov	bp,sp
  1476 0000076E 065651                  	pushm	cx,si,es
  1477                                  
  1478 00000771 8B4E04                  	mov	cx,ARG(1)
  1479 00000774 C47606                  	les	si,ARG(2)
  1480 00000777 83C60F                  	add	si,15		; point at end of array
  1481 0000077A E8B8FF                  	call	xbits
  1482                                  
  1483 0000077D 595E07                  	popm	cx,si,es
  1484 00000780 C9                      	leave
  1485 00000781 C3                      	ret
  1486                                  
  1487                                  
  1488                                  %if DEBUG>0
  1489                                  writeCSD:
  1490                                  	mov	si,SDcsd
  1491                                  	mov	cx,16
  1492                                  .1:	lodsb
  1493                                  	call	boutsp
  1494                                  	loop	.1
  1495                                  ; NewLine
  1496                                  crlf:
  1497                                  	mov	al,0Dh
  1498                                  	call	cout
  1499                                  	mov	al,0Ah
  1500                                  	call	cout
  1501                                  	ret
  1502                                  
  1503                                  
  1504                                  ; output byte from AL, then a space
  1505                                  boutsp:
  1506                                  	call	bout
  1507                                  	mov	al,20h
  1508                                  	call	cout
  1509                                  	ret
  1510                                  ; word output from AX
  1511                                  wout:
  1512                                  	xchg	al,ah
  1513                                  	call	bout
  1514                                  	xchg	al,ah
  1515                                  ; byte output from AL
  1516                                  bout:
  1517                                  	rol	al,4
  1518                                  	call	nout
  1519                                  	rol	al,4
  1520                                  ; nibble output from low nibble in AL
  1521                                  nout:
  1522                                  	push	ax
  1523                                  	and	al,0Fh		; mask nibble
  1524                                  	daa			; convert to decimal
  1525                                  	add	al,0F0h		; overflow to Carry
  1526                                  	adc	al,040h		; convert to ASCII decimal or hex digit
  1527                                  	call	cout
  1528                                  	pop	ax
  1529                                  	ret
  1530                                  	
  1531                                  ; character output from AL
  1532                                  cout:
  1533                                  	pushm	ax,bx
  1534                                  	mov	ah,0Eh		; write character in AL
  1535                                  	mov	bx,0007h
  1536                                  	int	10h
  1537                                  	popm	ax,bx
  1538                                  	ret
  1539                                  %endif
  1540                                  
  1541                                  	SEGMENT	_DATA
  1542                                  ;;;SDcardtype	db	0, 0		; SD card type SDtypeSDSC=2, HC=3, ...
  1543                                  ;;;SDstatus	db	0, 0		; status byte from command
  1544                                  
  1545                                  ;;;SDcsd		times 16 db 0		; SD card CSD
  1546                                  
  1547                                  %if DEBUG>=1
  1548                                  buffer:	
  1549                                  	times	512 db 0E7h
  1550                                  lbuf	equ	$-buffer
  1551                                  %endif
  1552                                  
  1553                                  
  1554                                  ;-------------------------------------------------------------------------------
  1555                                  
  1556                                  ;-----------------------------------------------------------------------------
  1557                                  ; End of SDcard disk driver
  1558                                  ;
  1559                                  ; Begin SBC-188 BIOS code
  1560                                  ;------------------------------------------------------------------------------------	
  1561                                  %ifndef STANDALONE
  1562                                  	
  1563                                  	SEGMENT	_TEXT
  1564                                  
  1565                                  
  1566                                  ; Standard int 13h stack frame layout is 
  1567                                  ; created by:   PUSHM  ALL,DS,ES
  1568                                  ;               MOV    BP,SP
  1569                                  ;
  1570                                  offset_DI       equ     0
  1571                                  offset_SI       equ     offset_DI+2
  1572                                  offset_BP       equ     offset_SI+2
  1573                                  offset_SP       equ     offset_BP+2
  1574                                  offset_BX       equ     offset_SP+2
  1575                                  offset_DX       equ     offset_BX+2
  1576                                  offset_CX       equ     offset_DX+2
  1577                                  offset_AX       equ     offset_CX+2
  1578                                  offset_DS       equ     offset_AX+2
  1579                                  offset_ES       equ     offset_DS+2
  1580                                  offset_IP       equ     offset_ES+2
  1581                                  offset_CS       equ     offset_IP+2
  1582                                  offset_FLAGS    equ     offset_CS+2
  1583                                  
  1584                                  ; The byte registers in the stack
  1585                                  offset_AL       equ     offset_AX
  1586                                  offset_AH       equ     offset_AX+1
  1587                                  offset_BL       equ     offset_BX
  1588                                  offset_BH       equ     offset_BX+1
  1589                                  offset_CL       equ     offset_CX
  1590                                  offset_CH       equ     offset_CX+1
  1591                                  offset_DL       equ     offset_DX
  1592                                  offset_DH       equ     offset_DX+1
  1593                                  
  1594                                  ; FDC error codes (returned in AH)
  1595                                  ;
  1596                                  ERR_no_error            equ     0       ; no error (return Carry clear)
  1597                                  ;   everything below returns with the Carry set to indicate an error
  1598                                  ERR_invalid_command     equ     1
  1599                                  ERR_address_mark_not_found      equ     2
  1600                                  ERR_write_protect       equ     3
  1601                                  ERR_sector_not_found    equ     4
  1602                                  ERR_disk_removed        equ     6
  1603                                  ERR_dma_overrun         equ     8
  1604                                  ERR_dma_crossed_64k     equ     9
  1605                                  ERR_media_type_not_found        equ     12
  1606                                  ERR_uncorrectable_CRC_error     equ     10h
  1607                                  ERR_controller_failure  equ     20h
  1608                                  ERR_seek_failed         equ     40h
  1609                                  ERR_disk_timeout        equ     80h
  1610                                  
  1611                                  
  1612                                  ; Packet call offsets
  1613                                  ;
  1614                                  pkt_size        equ     0       ; byte, size of packet (==16)
  1615                                  pkt_reserved1   equ     1       ; byte, reserved, must be zero
  1616                                  pkt_blocks      equ     2       ; byte, number of blocks to transfer
  1617                                                                  ; max is 127 (7Fh); 0 means no transfer
  1618                                  pkt_reserved3   equ     3       ; byte; reserved, must be zero
  1619                                  pkt_address     equ     4       ; dword; segment:offset of transfer
  1620                                  pkt_LBA         equ     8       ; qword; LBA of transfer
  1621                                  ; for convenience:
  1622                                  pkt_LBA0        equ     8       ; word
  1623                                  pkt_LBA1        equ     10      ; word
  1624                                  pkt_LBA2        equ     12      ; word          ; MBZ
  1625                                  pkt_LBA3        equ     14      ; word          ; MBZ
  1626                                  
  1627                                  ; Parameter Packet returns:
  1628                                  ;
  1629                                  ;pkt_size       equ     0       ; word
  1630                                  pkt_info        equ     2       ; word, information bits
  1631                                          ; bit   usage
  1632                                          ;  0    DMA boundary errors are handled transparently
  1633                                          ;  1    Geometry valid (bytes 8-12)
  1634                                          ;  2    Removable device (no)
  1635                                          ;  3    Supports Write with Verify (no)
  1636                                          ;  4    change line support (no)
  1637                                          ;  5    removable & lockable (no)
  1638                                          ;  6    max. geometry for a removable drive (no)
  1639                                          ;  7-15  MBZ
  1640                                  pkt_phys_cyl    equ     4       ; dword, physical cylinders
  1641                                  pkt_phys_hds    equ     8       ; dword, physical heads
  1642                                  pkt_phys_spt    equ     12      ; dword, sectors per track
  1643                                  pkt_sectors     equ     16      ; qword, total number of sectors
  1644                                  pkt_bytes       equ     24      ; word, bytes per sector
  1645                                  pkt_ptr         equ     26      ; dword, EDD configuration paramter pointer
  1646                                                                  ; FFFF:FFFF means invalid pointer
  1647                                  
  1648                                  
  1649                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1650                                  ; integrity:    Check integrity of fixed disk table
  1651                                  ;
  1652                                  ;  Call with:
  1653                                  ;       DL = device code (80h..83h)
  1654                                  ;       DS set to BIOS data area
  1655                                  ;
  1656                                  ;  Exit with:
  1657                                  ;       DS:SI points at the fixed disk table
  1658                                  ;	DI = unit number
  1659                                  ;
  1660                                  ;  Error Exit:
  1661                                  ;       If the disk table checksum is bad, give immediate error return
  1662                                  ;
  1663                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1664                                  integrity:
  1665 00000782 5150                            pushm   ax,cx
  1666                                  %if 0
  1667                                          mov     al,7Fh
  1668                                          and     al,dl                   ; mask out the high bit
  1669                                          cmp     al,[n_fixed_disks]
  1670                                  %else
  1671                                  	extern	get_IDE_num
  1672 00000784 E8(0000)                	call	get_IDE_num		; get number of IDE disks total
  1673 00000787 88C4                    	mov	ah,al
  1674 00000789 B07F                    	mov	al,7Fh
  1675 0000078B 20D0                            and     al,dl                   ; mask out the high bit
  1676 0000078D 38E0                    	cmp	al,ah			; compare against max
  1677                                  %endif
  1678 0000078F 7203E995F8                      jae     undefined               ; harsh error exit
  1679 00000794 BEB000                          mov     si,fx80
  1680 00000797 B91000                          mov     cx,fx81-fx80            ; size of fixed disk table
  1681 0000079A 84C0                    	test    al,al
  1682 0000079C 7406                            jz      .1
  1683 0000079E 01CE                    .0:	add     si,cx                   ; point at fx81
  1684 000007A0 FEC8                    	dec	al
  1685 000007A2 75FA                    	jnz	.0
  1686                                  .1:
  1687 000007A4 56                              push    si
  1688 000007A5 B800EE                          mov     ax,0EE00h               ; error code and zero checksum
  1689                                  
  1690 000007A8 0204                    .2:     add     al,[si]                 ; compute checksum
  1691 000007AA 46                              inc     si
  1692 000007AB E2FB                            loop    .2                      ; loop back
  1693                                  
  1694 000007AD 5E                              pop     si
  1695 000007AE 08C0                            or      al,al                   ; test AL for zero
  1696 000007B0 7403E97EF8                      jnz     error_exit              ; BIOS data area clobbered
  1697                                  
  1698 000007B5 E8D5F8                  	call	SDsetunit		; get DI as unit number
  1699                                  
  1700 000007B8 5859                            popm    ax,cx
  1701 000007BA C3                              ret
  1702                                  
  1703                                  
  1704                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1705                                  ; cv_lba        Convert CHS in CX & DX to LBA address in DX:AX
  1706                                  ;
  1707                                  ;  Call with:
  1708                                  ;       DS:SI points to fixed disk table
  1709                                  ;       CX & DX are CHS input parameters
  1710                                  ;
  1711                                  ;  Exit with:
  1712                                  ;       DX:AX is the corresponding LBA address
  1713                                  ;       BX and CX are modified
  1714                                  ;
  1715                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1716                                  cv_lba:
  1717 000007BB 89C8                            mov     ax,cx           ; cylinder info to AX
  1718 000007BD C0C002                          rol     al,2            ; position high 2 bits
  1719 000007C0 2403                            and     al,3            ; mask 2 bits
  1720 000007C2 86C4                            xchg    al,ah           ; AX = cylinder number
  1721 000007C4 C1EA08                          shr     dx,8            ; heads to DL   DH=0
  1722                                  
  1723 000007C7 89D3                            mov     bx,dx           ; heads to BX
  1724 000007C9 8A5402                          mov     dl,[fx_log_heads - fx80 + si]   ; may be 0, meaning 256
  1725 000007CC FECA                            dec     dl
  1726 000007CE 42                              inc     dx              ; recover 256 !!!
  1727                                  
  1728 000007CF F7E2                            mul     dx
  1729 000007D1 01D8                            add     ax,bx           ; add in the head number
  1730 000007D3 83D200                          adc     dx,0            ; **
  1731                                  
  1732 000007D6 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]    ; BH is already 0
  1733 000007D9 51                              push    cx
  1734 000007DA E8(0000)                        call    @mulLS          ; DX:AX = DX:AX * BX
  1735 000007DD 59                              pop     cx
  1736 000007DE FEC9                            dec     cl              ; sector address is from 1, not 0
  1737 000007E0 83E13F                          and     cx,63
  1738 000007E3 01C8                            add     ax,cx           ; add in sector number
  1739 000007E5 83D200                          adc     dx,0            ; **
  1740 000007E8 C3                              ret
  1741                                  
  1742                                  
  1743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1744                                  ; fn00 -- Reset the Disk Subsystem
  1745                                  ;
  1746                                  ;  Call with:
  1747                                  ;       AH = 0  function code
  1748                                  ;
  1749                                  ;  Exit with:
  1750                                  ;       Nothing
  1751                                  ;
  1752                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1753                                  fn00:
  1754 000007E9 E896FF                          call    integrity       ; perhaps no subsystem
  1755 000007EC E875F9                  	call	SDinit		; no real init until referenced
  1756 000007EF B400                            mov     ah,0
  1757 000007F1 E93BF8                          jmp     exit_sequence
  1758                                  
  1759                                  
  1760                                  
  1761                                  
  1762                                  
  1763                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1764                                  ; fn02 -- Disk Read
  1765                                  ; fn03 -- Disk Write
  1766                                  ; fn04 -- Disk Verify (future)
  1767                                  ;
  1768                                  ;  Enter with:
  1769                                  ;       AH = 2 (read)
  1770                                  ;       AH = 3 (write)
  1771                                  ;       AH = 4 (verify)
  1772                                  ;       AL = number of sectors to transfer
  1773                                  ;       CH = low 8 bits of cylinder number
  1774                                  ;       CL = sector number & high 2 bits of sector number
  1775                                  ;       DH = head number
  1776                                  ;       DL = device code
  1777                                  ;       ES:BX = buffer to receive/provide the data (except on verify)
  1778                                  ;
  1779                                  ;  Exit with:
  1780                                  ;       AH = success(0) or error code
  1781                                  ;       Carry flag set, if error; clear otherwise
  1782                                  ;
  1783                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1784                                  fn02:
  1785                                  fn03:
  1786                                  fn04:
  1787 000007F4 E88BFF                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1788 000007F7 E8C1FF                          call    cv_lba          ; convert to LBA address in DX:AX
  1789 000007FA 30C9                    	xor	cl,cl		; no error to begin
  1790                                  
  1791 000007FC 8A6E0E                          mov     ch,[bp + offset_AL]      ; get sector count
  1792 000007FF 8B5E08                          mov     bx,[bp + offset_BX]      ; get transfer address
  1793                                  
  1794                                  ; Enter here on Read, Write, Verify or
  1795                                  ;     extended  Read, Write, Verify, Seek
  1796                                  RWV: 
  1797 00000802 FEC5                            inc     ch                      ; zero is valid for no transfer
  1798 00000804 EB31                            jmp     .6              ; enter loop at the bottom
  1799                                  ; the read/write/verify loop
  1800                                  .1:
  1801                                  ; LBA call is okay
  1802 00000806 F6460F04                        test    byte [bp+offset_AH],04h         ; Seek/Verify?
  1803 0000080A 7514                            jnz     .4
  1804 0000080C F6460F01                        test    byte [bp+offset_AH],01h         ; Write?
  1805 00000810 7507                            jnz     .3
  1806                                  .2:				; READ operation
  1807 00000812 E824FC                  	call	SDread1sec
  1808 00000815 740E                    	jz	.5
  1809 00000817 EB22                    	jmp	.8		; error code in CL
  1810                                  
  1811                                  .3:
  1812 00000819 E879FC                  	call	SDwrite1sec
  1813 0000081C 7407                    	jz	.5
  1814 0000081E EB1B                            jmp     .8		; error code in CL
  1815                                  
  1816                                  .4:
  1817 00000820 E8C6FC                  	call	SDverify1sec
  1818 00000823 7516                    	jnz	.8		; error code is in CL
  1819                                  
  1820                                  .5:
  1821 00000825 83C001                          add     ax,1            ; increment the LBA address
  1822 00000828 83D200                          adc     dx,0            ; **
  1823 0000082B 80C702                          add     bh,2            ; add 512 == 200h to the BX
  1824 0000082E 7307                            jnc     .6
  1825 00000830 8CC7                            mov     di,es
  1826 00000832 83C710                          add     di,10h
  1827 00000835 8EC7                            mov     es,di           ; update the segment register
  1828 00000837 FECD                    .6:     dec     ch
  1829 00000839 75CB                            jnz     .1
  1830                                  
  1831 0000083B 88CC                    .8:	mov	ah,cl		; error code to AH
  1832 0000083D E9EFF7                  	jmp     exit_sequence
  1833                                  
  1834                                  
  1835                                  
  1836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1837                                  ; fn08  --  Get Drive Parameters
  1838                                  ;
  1839                                  ;  Call with:
  1840                                  ;       AH = 8  function code
  1841                                  ;       DL = drive code (80h, 81h, ...)
  1842                                  ;
  1843                                  ;  Exit with:
  1844                                  ;       CH = maximum cylinder number (low 8 bits)
  1845                                  ;       CL = max. sector number; max. cyl in high 2 bits
  1846                                  ;       DH = maximum head number
  1847                                  ;       DL = number of fixed disks
  1848                                  
  1849                                  ;       AH = 0  and Carry is clear on success
  1850                                  ;       AH = error code; Carry set on error
  1851                                  ;
  1852                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1853                                  fn08:           ; Get Drive Parameters
  1854 00000840 C6460A00                        mov     byte [bp + offset_DL],0         ; say no fixed disks
  1855                                  
  1856 00000844 E83BFF                          call    integrity       ; bad device code or no fixed disks
  1857                                  
  1858 00000847 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1859 00000849 48                              dec     ax
  1860 0000084A C0E406                          shl     ah,6
  1861 0000084D 0A640E                          or      ah,[fx_log_sectors - fx80 + si]
  1862 00000850 86C4                            xchg    al,ah
  1863 00000852 89460C                          mov     [bp + offset_CX],ax
  1864 00000855 8A7402                          mov     dh,[fx_log_heads - fx80 + si]
  1865 00000858 FECE                            dec     dh
  1866                                  %if 0
  1867                                          mov     dl,[n_fixed_disks]      ; return parameter
  1868                                  %else
  1869 0000085A 52                      	push	dx			; protect DH
  1870 0000085B E8(0000)                	call	get_IDE_num		; get number of IDE disks
  1871 0000085E 5A                      	pop	dx			; restore DH
  1872 0000085F 88C2                    	mov	dl,al
  1873                                  %endif
  1874 00000861 89560A                          mov     [bp + offset_DX],dx
  1875                                  
  1876 00000864 30E4                            xor     ah,ah
  1877 00000866 E9C6F7                          jmp     exit_sequence
  1878                                  
  1879                                  
  1880                                          
  1881                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1882                                  ; fn15 -- Get Disk Type
  1883                                  ;
  1884                                  ;  Call With:
  1885                                  ;       AH = 15   function code
  1886                                  ;       DL = device code (80h or 81h)
  1887                                  ;
  1888                                  ;  Exit With:
  1889                                  ;     If successful, Carry is clear
  1890                                  ;       AH = 3  indicating a hard disk
  1891                                  ;       CX:DX   number of hard disk sectors
  1892                                  ;
  1893                                  ;     If unsuccessful, Carry is set
  1894                                  ;
  1895                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1896                                  fn15:
  1897 00000869 E816FF                          call    integrity       ; sets DS:SI
  1898 0000086C 8B04                            mov     ax,[fx_log_cylinders - fx80 + si]
  1899 0000086E 8A5C02                          mov     bl,[fx_log_heads - fx80 + si]
  1900 00000871 30FF                            xor     bh,bh
  1901 00000873 FECB                            dec     bl              ; 00 means 256
  1902 00000875 43                              inc     bx              ; do the conversion
  1903 00000876 F7E3                            mul     bx              ; cyls * heads
  1904 00000878 8A5C0E                          mov     bl,[fx_log_sectors - fx80 + si]
  1905 0000087B 30FF                            xor     bh,bh
  1906 0000087D E8(0000)                        call    @mulLS          ; cyls * heads * sectors
  1907 00000880 89560C                          mov     word [bp+offset_CX],dx  ; high order
  1908 00000883 89460A                          mov     word [bp+offset_DX],ax  ; low order word
  1909 00000886 B403                            mov     ah,3		   ; code for HARD DISK
  1910 00000888 F8                              clc
  1911 00000889 E9A8F7                          jmp     exit_pops
  1912                                  
  1913                                  
  1914                                  
  1915                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1916                                  ; fn41 -- Check Extensions Present
  1917                                  ;
  1918                                  ;  Call With:
  1919                                  ;       AH = 41h        function code
  1920                                  ;       BX = 55AAh      magic number
  1921                                  ;       DL = drive code (80h or 81h)
  1922                                  ;
  1923                                  ;  Exit With:
  1924                                  ;     carry clear
  1925                                  ;       AH = 21h        version 1.1 support
  1926                                  ;       BX = AA55h      magic number II
  1927                                  ;       CX = 0001b  bit0=packet support; bit2=EDD drive support
  1928                                  ;
  1929                                  ;     carry set
  1930                                  ;       AH = 01h        Invalid Command
  1931                                  ;
  1932                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1933                                  fn41:
  1934 0000088C E8F3FE                          call    integrity       ; test drive number (sets DS:SI)
  1935 0000088F 817E08AA55                      cmp     word [offset_BX + bp],55AAh
  1936 00000894 7403E990F7                      jne     undefined
  1937 00000899 F6440840                        test    byte [fx_drive_control - fx80 + si],40h         ; test LBA bit
  1938 0000089D 7503E987F7                      jz      undefined
  1939                                  
  1940 000008A2 C6460F21                        mov     byte [offset_AH + bp],21h       ; version 1.1
  1941 000008A6 C7460855AA                      mov     word [offset_BX + bp],0AA55h    ; magic number II
  1942 000008AB C7460C0500                      mov     word [offset_CX + bp],00000101b       ; packet calls & EDD i/f
  1943 000008B0 E97AF7                          jmp     good_exit
  1944                                  
  1945                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1946                                  ; fn42 -- Extended Read
  1947                                  ; fn43 -- Extended Write
  1948                                  ; fn44 -- Extended Verify
  1949                                  ; fn47 -- Extended Seek (implement as Verify)
  1950                                  ;
  1951                                  ;  Call With:
  1952                                  ;       AH = function code
  1953                                  ;       AL = 0,1 write with no verify; 2 write with verify
  1954                                  ;            not used for Read or Verify
  1955                                  ;       DL = drive number (80h or 81h)
  1956                                  ;       [DS:SI] was disk packet address; will be used in ES:BX
  1957                                  ;
  1958                                  ;  Exit With:
  1959                                  ;       AH = 0 (no error) and Carry Clear
  1960                                  ;       AH = error code and Carry Set
  1961                                  ;     The block count field is updated with the number of blocks
  1962                                  ;     correctly transferred/verified before the error occurred.
  1963                                  ;
  1964                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1965                                  fn42:
  1966                                  fn43:
  1967                                  fn44:
  1968                                  fn47:
  1969 000008B3 E8CCFE                          call    integrity       ; set pointer to Fixed Disk Table in SI
  1970 000008B6 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  1971 000008B9 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  1972 000008BC 26803F10                   es   cmp     byte [bx + pkt_size],16 ; check for correct size
  1973 000008C0 7303E964F7                      jb      undefined
  1974                                  
  1975 000008C5 268B470E                   es   mov     ax,[bx + pkt_LBA3]      ; LBA address
  1976 000008C9 260B470C                   es   or      ax,[bx + pkt_LBA2]      ; LBA address
  1977 000008CD 7403E957F7                      jnz     undefined
  1978 000008D2 268B4708                   es   mov     ax,[bx + pkt_LBA0]      ; LBA address
  1979 000008D6 268B570A                   es   mov     dx,[bx + pkt_LBA1]      ; LBA address hi
  1980                                  
  1981 000008DA B501                            mov     ch,1                    ; assume Seek
  1982 000008DC 807E0F47                        cmp     byte [offset_AH + bp],47h       ; Seek?
  1983 000008E0 7404                            je      .7
  1984 000008E2 268A6F02                   es   mov     ch,[bx + pkt_blocks]    ; sector count
  1985                                  .7:
  1986 000008E6 8A4C08                          mov     cl,[fx_drive_control - fx80 + si]
  1987 000008E9 26C45F04                   es   les     bx,[bx + pkt_address]   ; get transfer address
  1988                                  
  1989 000008ED E912FF                          jmp     RWV             ; common read/write/verify code
  1990                                  
  1991                                  
  1992                                          
  1993                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  1994                                  ; fn48 -- Get Drive Parameters
  1995                                  ;
  1996                                  ;  Call With:
  1997                                  ;       AH = 48h        function code
  1998                                  ;       DL = drive number
  1999                                  ;       DS:SI = pointer to return buffer (26 or 30 bytes)
  2000                                  ;
  2001                                  ;  Exit With:
  2002                                  ;       AH = 0 and carry clear
  2003                                  ;       results in the buffer
  2004                                  ;
  2005                                  ;       AH = error code and carry set
  2006                                  ;
  2007                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2008                                  fn48:
  2009 000008F0 E88FFE                          call    integrity               ; set DS:SI
  2010 000008F3 8E4610                          mov     es,[bp + offset_DS]     ; packet pointer
  2011 000008F6 8B5E02                          mov     bx,[bp + offset_SI]     ; **
  2012 000008F9 B9FFFF                          mov     cx,0FFFFh               ; CX = -1  (FFFFh)
  2013 000008FC B81A00                          mov     ax,pkt_ptr              ; AX = 26
  2014 000008FF 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 26
  2015 00000902 7303E922F7                      jb      undefined
  2016 00000907 83C004                          add     ax,4
  2017 0000090A 263907                     es   cmp     [bx + pkt_size],ax      ; check for correct size = 30
  2018 0000090D 7208                            jb      .1
  2019 0000090F 26894F1A                   es   mov     [bx + pkt_ptr],cx       ; flag invalid pointer
  2020 00000913 26894F1C                   es   mov     [bx + pkt_ptr+2],cx     ; **
  2021                                  .1:
  2022 00000917 268907                     es   mov     [bx + pkt_size],ax      ; set the returned size
  2023                                  
  2024 0000091A 41                              inc     cx                      ; CX = 0
  2025 0000091B 26C747020300               es   mov     word [bx + pkt_info], 000011b   ; DMA bound/ Geom OK
  2026                                  
  2027 00000921 8B4409                          mov     ax,[fx_phys_cylinders - fx80 + si]      ; cylinders
  2028 00000924 26894704                   es   mov     [bx + pkt_phys_cyl],ax  
  2029 00000928 26894F06                   es   mov     [bx + pkt_phys_cyl+2],cx
  2030                                  
  2031 0000092C 8A440B                          mov     al,[fx_phys_heads - fx80 + si]          ; heads
  2032 0000092F 88EC                            mov     ah,ch
  2033 00000931 26894708                   es   mov     [bx + pkt_phys_hds],ax  
  2034 00000935 26894F0A                   es   mov     [bx + pkt_phys_hds+2],cx
  2035                                  
  2036 00000939 8A4404                          mov     al,[fx_phys_sectors - fx80 + si]        ; sectors
  2037 0000093C 2689470C                   es   mov     [bx + pkt_phys_spt],ax  
  2038 00000940 26894F0E                   es   mov     [bx + pkt_phys_spt+2],cx
  2039                                  
  2040 00000944 8B440C                          mov     ax,[fx_LBA_low - fx80 + si]             ; total LBA sectors
  2041 00000947 26894710                   es   mov     [bx + pkt_sectors],ax                   ; total sectors
  2042 0000094B 8B4405                          mov     ax,[fx_LBA_high - fx80 + si]            ; **
  2043 0000094E 26894712                   es   mov     [bx + pkt_sectors+2],ax                 ; **
  2044 00000952 26894F14                   es   mov     [bx + pkt_sectors+4],cx                 ; **
  2045 00000956 26894F16                   es   mov     [bx + pkt_sectors+6],cx                 ; **
  2046 0000095A 26C747180002               es   mov     word [bx + pkt_bytes],512               ; sector size
  2047 00000960 B400                            mov     ah,0
  2048 00000962 E9CAF6                          jmp     exit_sequence
  2049                                  
  2050                                  
  2051                                  
  2052                                          
  2053                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2054                                  ; fn4E -- set hardware configuration
  2055                                  ;
  2056                                  ;  Call With:
  2057                                  ;       AH = 4Eh        function code
  2058                                  ;       AL = hardware function sub-code
  2059                                  ;       DL = drive number
  2060                                  ;
  2061                                  ;  Exit With:
  2062                                  ;       AH = 0          carry is clear
  2063                                  ;       AL = 1          other devices affected
  2064                                  ;
  2065                                  ;       AH = error code and carry is set
  2066                                  ;
  2067                                  ;  This operation is a complete No-Op for the DIDE
  2068                                  ;
  2069                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  2070                                  fn4E:
  2071 00000965 E81AFE                          call    integrity
  2072 00000968 B80100                          mov     ax,0001h
  2073 0000096B E9C1F6                          jmp     exit_sequence
  2074                                  
  2075                                  
  2076                                  
  2077                                  
  2078                                  %endif  ; STANDALONE
  2079                                  
  2080                                  
  2081                                  
